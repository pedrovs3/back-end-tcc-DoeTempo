
/**
 * Client
**/

import * as runtime from './runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  email: string
  password: string
  cpf: string
  id_gender: string
  birthdate: Date
  rg: string | null
  id_type: string
  description: string | null
  banner_photo: string
  photo_url: string
  created_at: Date
}

/**
 * Model Gender
 * 
 */
export type Gender = {
  id: string
  name: string
  abbreviation: string
}

/**
 * Model Phone
 * 
 */
export type Phone = {
  id: string
  number: string | null
}

/**
 * Model Address
 * 
 */
export type Address = {
  id: string
  postal_code: string
  number: string
  complement: string | null
}

/**
 * Model UserAddress
 * 
 */
export type UserAddress = {
  id: string
  id_address: string
  id_user: string
}

/**
 * Model Campaign
 * 
 */
export type Campaign = {
  id: string
  title: string
  description: string | null
  begin_date: Date
  end_date: Date
  home_office: boolean
  id_ngo: string
  how_to_contribute: string
  prerequisites: string
  created_at: Date
  is_active: boolean
}

/**
 * Model CampaignAddress
 * 
 */
export type CampaignAddress = {
  id: string
  id_campaign: string
  id_address: string
}

/**
 * Model CampaignCauses
 * 
 */
export type CampaignCauses = {
  id: string
  id_cause: string
  id_campaign: string
}

/**
 * Model CampaignParticipants
 * 
 */
export type CampaignParticipants = {
  id: string
  id_campaign: string
  id_user: string
  id_status: string
}

/**
 * Model CampaignPhotos
 * 
 */
export type CampaignPhotos = {
  id: string
  photo_url: string
  id_campaign: string
}

/**
 * Model Causes
 * 
 */
export type Causes = {
  id: string
  title: string
  description: string | null
}

/**
 * Model Following
 * 
 */
export type Following = {
  id: string
  id_user: string
  id_ngo: string
  id_status: string
}

/**
 * Model NGO
 * 
 */
export type NGO = {
  id: string
  name: string
  cnpj: string
  foundation_date: Date | null
  description: string | null
  email: string
  password: string
  id_type: string
  photo_url: string
  banner_photo: string
  created_at: Date
}

/**
 * Model NgoAddress
 * 
 */
export type NgoAddress = {
  id: string
  id_ngo: string
  id_address: string
}

/**
 * Model NgoCauses
 * 
 */
export type NgoCauses = {
  id: string
  id_causes: string
  id_ngo: string
}

/**
 * Model NgoPhone
 * 
 */
export type NgoPhone = {
  id: string
  id_ngo: string
  id_phone: string
}

/**
 * Model UserPhone
 * 
 */
export type UserPhone = {
  id: string
  id_phone: string
  id_user: string
}

/**
 * Model Type
 * 
 */
export type Type = {
  id: string
  name: string
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: string
  content: string | null
  created_at: Date
}

/**
 * Model PostPhoto
 * 
 */
export type PostPhoto = {
  id: string
  id_post: string
  photo_url: string
}

/**
 * Model PostNgo
 * 
 */
export type PostNgo = {
  id: string
  id_post: string
  id_ngo: string
}

/**
 * Model PostUser
 * 
 */
export type PostUser = {
  id: string
  id_post: string
  id_user: string
}

/**
 * Model Comment
 * 
 */
export type Comment = {
  id: string
  content: string
  created_at: Date
  id_post: string
}

/**
 * Model CommentUser
 * 
 */
export type CommentUser = {
  id: string
  id_comment: string
  id_user: string
}

/**
 * Model CommentNgo
 * 
 */
export type CommentNgo = {
  id: string
  id_comment: string
  id_ngo: string
}

/**
 * Model CommentLikes
 * 
 */
export type CommentLikes = {
  id: string
  id_comment: string
  id_user: string | null
  id_ngo: string | null
}

/**
 * Model PostLikes
 * 
 */
export type PostLikes = {
  id: string
  id_user: string | null
  id_ngo: string | null
  id_post: string
}

/**
 * Model AttachedLink
 * 
 */
export type AttachedLink = {
  id: string
  attached_link: string
  id_source: string
  id_user: string | null
  id_ngo: string | null
}

/**
 * Model Source
 * 
 */
export type Source = {
  id: string
  name: string
}

/**
 * Model Status
 * 
 */
export type Status = {
  id: string
  name: string
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.gender`: Exposes CRUD operations for the **Gender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genders
    * const genders = await prisma.gender.findMany()
    * ```
    */
  get gender(): Prisma.GenderDelegate<GlobalReject>;

  /**
   * `prisma.phone`: Exposes CRUD operations for the **Phone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phones
    * const phones = await prisma.phone.findMany()
    * ```
    */
  get phone(): Prisma.PhoneDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.userAddress`: Exposes CRUD operations for the **UserAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAddresses
    * const userAddresses = await prisma.userAddress.findMany()
    * ```
    */
  get userAddress(): Prisma.UserAddressDelegate<GlobalReject>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<GlobalReject>;

  /**
   * `prisma.campaignAddress`: Exposes CRUD operations for the **CampaignAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignAddresses
    * const campaignAddresses = await prisma.campaignAddress.findMany()
    * ```
    */
  get campaignAddress(): Prisma.CampaignAddressDelegate<GlobalReject>;

  /**
   * `prisma.campaignCauses`: Exposes CRUD operations for the **CampaignCauses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignCauses
    * const campaignCauses = await prisma.campaignCauses.findMany()
    * ```
    */
  get campaignCauses(): Prisma.CampaignCausesDelegate<GlobalReject>;

  /**
   * `prisma.campaignParticipants`: Exposes CRUD operations for the **CampaignParticipants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignParticipants
    * const campaignParticipants = await prisma.campaignParticipants.findMany()
    * ```
    */
  get campaignParticipants(): Prisma.CampaignParticipantsDelegate<GlobalReject>;

  /**
   * `prisma.campaignPhotos`: Exposes CRUD operations for the **CampaignPhotos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignPhotos
    * const campaignPhotos = await prisma.campaignPhotos.findMany()
    * ```
    */
  get campaignPhotos(): Prisma.CampaignPhotosDelegate<GlobalReject>;

  /**
   * `prisma.causes`: Exposes CRUD operations for the **Causes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Causes
    * const causes = await prisma.causes.findMany()
    * ```
    */
  get causes(): Prisma.CausesDelegate<GlobalReject>;

  /**
   * `prisma.following`: Exposes CRUD operations for the **Following** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Followings
    * const followings = await prisma.following.findMany()
    * ```
    */
  get following(): Prisma.FollowingDelegate<GlobalReject>;

  /**
   * `prisma.nGO`: Exposes CRUD operations for the **NGO** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NGOS
    * const nGOS = await prisma.nGO.findMany()
    * ```
    */
  get nGO(): Prisma.NGODelegate<GlobalReject>;

  /**
   * `prisma.ngoAddress`: Exposes CRUD operations for the **NgoAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NgoAddresses
    * const ngoAddresses = await prisma.ngoAddress.findMany()
    * ```
    */
  get ngoAddress(): Prisma.NgoAddressDelegate<GlobalReject>;

  /**
   * `prisma.ngoCauses`: Exposes CRUD operations for the **NgoCauses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NgoCauses
    * const ngoCauses = await prisma.ngoCauses.findMany()
    * ```
    */
  get ngoCauses(): Prisma.NgoCausesDelegate<GlobalReject>;

  /**
   * `prisma.ngoPhone`: Exposes CRUD operations for the **NgoPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NgoPhones
    * const ngoPhones = await prisma.ngoPhone.findMany()
    * ```
    */
  get ngoPhone(): Prisma.NgoPhoneDelegate<GlobalReject>;

  /**
   * `prisma.userPhone`: Exposes CRUD operations for the **UserPhone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPhones
    * const userPhones = await prisma.userPhone.findMany()
    * ```
    */
  get userPhone(): Prisma.UserPhoneDelegate<GlobalReject>;

  /**
   * `prisma.type`: Exposes CRUD operations for the **Type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.type.findMany()
    * ```
    */
  get type(): Prisma.TypeDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.postPhoto`: Exposes CRUD operations for the **PostPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostPhotos
    * const postPhotos = await prisma.postPhoto.findMany()
    * ```
    */
  get postPhoto(): Prisma.PostPhotoDelegate<GlobalReject>;

  /**
   * `prisma.postNgo`: Exposes CRUD operations for the **PostNgo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostNgos
    * const postNgos = await prisma.postNgo.findMany()
    * ```
    */
  get postNgo(): Prisma.PostNgoDelegate<GlobalReject>;

  /**
   * `prisma.postUser`: Exposes CRUD operations for the **PostUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostUsers
    * const postUsers = await prisma.postUser.findMany()
    * ```
    */
  get postUser(): Prisma.PostUserDelegate<GlobalReject>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject>;

  /**
   * `prisma.commentUser`: Exposes CRUD operations for the **CommentUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentUsers
    * const commentUsers = await prisma.commentUser.findMany()
    * ```
    */
  get commentUser(): Prisma.CommentUserDelegate<GlobalReject>;

  /**
   * `prisma.commentNgo`: Exposes CRUD operations for the **CommentNgo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentNgos
    * const commentNgos = await prisma.commentNgo.findMany()
    * ```
    */
  get commentNgo(): Prisma.CommentNgoDelegate<GlobalReject>;

  /**
   * `prisma.commentLikes`: Exposes CRUD operations for the **CommentLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentLikes
    * const commentLikes = await prisma.commentLikes.findMany()
    * ```
    */
  get commentLikes(): Prisma.CommentLikesDelegate<GlobalReject>;

  /**
   * `prisma.postLikes`: Exposes CRUD operations for the **PostLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostLikes
    * const postLikes = await prisma.postLikes.findMany()
    * ```
    */
  get postLikes(): Prisma.PostLikesDelegate<GlobalReject>;

  /**
   * `prisma.attachedLink`: Exposes CRUD operations for the **AttachedLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttachedLinks
    * const attachedLinks = await prisma.attachedLink.findMany()
    * ```
    */
  get attachedLink(): Prisma.AttachedLinkDelegate<GlobalReject>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<GlobalReject>;

  /**
   * `prisma.status`: Exposes CRUD operations for the **Status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Statuses
    * const statuses = await prisma.status.findMany()
    * ```
    */
  get status(): Prisma.StatusDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: 1e7af066ee9cb95cf3a403c78d9aab3e6b04f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Gender: 'Gender',
    Phone: 'Phone',
    Address: 'Address',
    UserAddress: 'UserAddress',
    Campaign: 'Campaign',
    CampaignAddress: 'CampaignAddress',
    CampaignCauses: 'CampaignCauses',
    CampaignParticipants: 'CampaignParticipants',
    CampaignPhotos: 'CampaignPhotos',
    Causes: 'Causes',
    Following: 'Following',
    NGO: 'NGO',
    NgoAddress: 'NgoAddress',
    NgoCauses: 'NgoCauses',
    NgoPhone: 'NgoPhone',
    UserPhone: 'UserPhone',
    Type: 'Type',
    Post: 'Post',
    PostPhoto: 'PostPhoto',
    PostNgo: 'PostNgo',
    PostUser: 'PostUser',
    Comment: 'Comment',
    CommentUser: 'CommentUser',
    CommentNgo: 'CommentNgo',
    CommentLikes: 'CommentLikes',
    PostLikes: 'PostLikes',
    AttachedLink: 'AttachedLink',
    Source: 'Source',
    Status: 'Status'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    supported_campaigns: number
    comment_user: number
    following: number
    post_user: number
    comment_likes: number
    post_likes: number
    attached_link: number
  }

  export type UserCountOutputTypeSelect = {
    supported_campaigns?: boolean
    comment_user?: boolean
    following?: boolean
    post_user?: boolean
    comment_likes?: boolean
    post_likes?: boolean
    attached_link?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type GenderCountOutputType
   */


  export type GenderCountOutputType = {
    user: number
  }

  export type GenderCountOutputTypeSelect = {
    user?: boolean
  }

  export type GenderCountOutputTypeGetPayload<S extends boolean | null | undefined | GenderCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GenderCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (GenderCountOutputTypeArgs)
    ? GenderCountOutputType 
    : S extends { select: any } & (GenderCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GenderCountOutputType ? GenderCountOutputType[P] : never
  } 
      : GenderCountOutputType




  // Custom InputTypes

  /**
   * GenderCountOutputType without action
   */
  export type GenderCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the GenderCountOutputType
     */
    select?: GenderCountOutputTypeSelect | null
  }



  /**
   * Count Type PhoneCountOutputType
   */


  export type PhoneCountOutputType = {
    ngo_phone: number
    user_phone: number
  }

  export type PhoneCountOutputTypeSelect = {
    ngo_phone?: boolean
    user_phone?: boolean
  }

  export type PhoneCountOutputTypeGetPayload<S extends boolean | null | undefined | PhoneCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PhoneCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PhoneCountOutputTypeArgs)
    ? PhoneCountOutputType 
    : S extends { select: any } & (PhoneCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PhoneCountOutputType ? PhoneCountOutputType[P] : never
  } 
      : PhoneCountOutputType




  // Custom InputTypes

  /**
   * PhoneCountOutputType without action
   */
  export type PhoneCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PhoneCountOutputType
     */
    select?: PhoneCountOutputTypeSelect | null
  }



  /**
   * Count Type AddressCountOutputType
   */


  export type AddressCountOutputType = {
    campaign_address: number
    ngo_address: number
    user_address: number
  }

  export type AddressCountOutputTypeSelect = {
    campaign_address?: boolean
    ngo_address?: boolean
    user_address?: boolean
  }

  export type AddressCountOutputTypeGetPayload<S extends boolean | null | undefined | AddressCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AddressCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (AddressCountOutputTypeArgs)
    ? AddressCountOutputType 
    : S extends { select: any } & (AddressCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AddressCountOutputType ? AddressCountOutputType[P] : never
  } 
      : AddressCountOutputType




  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect | null
  }



  /**
   * Count Type CampaignCountOutputType
   */


  export type CampaignCountOutputType = {
    campaign_causes: number
    campaign_participants: number
    campaign_photos: number
  }

  export type CampaignCountOutputTypeSelect = {
    campaign_causes?: boolean
    campaign_participants?: boolean
    campaign_photos?: boolean
  }

  export type CampaignCountOutputTypeGetPayload<S extends boolean | null | undefined | CampaignCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CampaignCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CampaignCountOutputTypeArgs)
    ? CampaignCountOutputType 
    : S extends { select: any } & (CampaignCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CampaignCountOutputType ? CampaignCountOutputType[P] : never
  } 
      : CampaignCountOutputType




  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect | null
  }



  /**
   * Count Type CausesCountOutputType
   */


  export type CausesCountOutputType = {
    campaign_causes: number
    ngo_causes: number
  }

  export type CausesCountOutputTypeSelect = {
    campaign_causes?: boolean
    ngo_causes?: boolean
  }

  export type CausesCountOutputTypeGetPayload<S extends boolean | null | undefined | CausesCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CausesCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CausesCountOutputTypeArgs)
    ? CausesCountOutputType 
    : S extends { select: any } & (CausesCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CausesCountOutputType ? CausesCountOutputType[P] : never
  } 
      : CausesCountOutputType




  // Custom InputTypes

  /**
   * CausesCountOutputType without action
   */
  export type CausesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CausesCountOutputType
     */
    select?: CausesCountOutputTypeSelect | null
  }



  /**
   * Count Type NGOCountOutputType
   */


  export type NGOCountOutputType = {
    campaign: number
    comment_ngo: number
    following: number
    ngo_causes: number
    ngo_phone: number
    post_ngo: number
    comment_likes: number
    post_likes: number
    attached_link: number
  }

  export type NGOCountOutputTypeSelect = {
    campaign?: boolean
    comment_ngo?: boolean
    following?: boolean
    ngo_causes?: boolean
    ngo_phone?: boolean
    post_ngo?: boolean
    comment_likes?: boolean
    post_likes?: boolean
    attached_link?: boolean
  }

  export type NGOCountOutputTypeGetPayload<S extends boolean | null | undefined | NGOCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NGOCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (NGOCountOutputTypeArgs)
    ? NGOCountOutputType 
    : S extends { select: any } & (NGOCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof NGOCountOutputType ? NGOCountOutputType[P] : never
  } 
      : NGOCountOutputType




  // Custom InputTypes

  /**
   * NGOCountOutputType without action
   */
  export type NGOCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NGOCountOutputType
     */
    select?: NGOCountOutputTypeSelect | null
  }



  /**
   * Count Type TypeCountOutputType
   */


  export type TypeCountOutputType = {
    ngo: number
    user: number
  }

  export type TypeCountOutputTypeSelect = {
    ngo?: boolean
    user?: boolean
  }

  export type TypeCountOutputTypeGetPayload<S extends boolean | null | undefined | TypeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TypeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TypeCountOutputTypeArgs)
    ? TypeCountOutputType 
    : S extends { select: any } & (TypeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TypeCountOutputType ? TypeCountOutputType[P] : never
  } 
      : TypeCountOutputType




  // Custom InputTypes

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TypeCountOutputType
     */
    select?: TypeCountOutputTypeSelect | null
  }



  /**
   * Count Type PostCountOutputType
   */


  export type PostCountOutputType = {
    comment: number
    post_ngo: number
    post_photo: number
    post_user: number
    post_likes: number
  }

  export type PostCountOutputTypeSelect = {
    comment?: boolean
    post_ngo?: boolean
    post_photo?: boolean
    post_user?: boolean
    post_likes?: boolean
  }

  export type PostCountOutputTypeGetPayload<S extends boolean | null | undefined | PostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PostCountOutputTypeArgs)
    ? PostCountOutputType 
    : S extends { select: any } & (PostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostCountOutputType ? PostCountOutputType[P] : never
  } 
      : PostCountOutputType




  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect | null
  }



  /**
   * Count Type CommentCountOutputType
   */


  export type CommentCountOutputType = {
    comment_ngo: number
    comment_user: number
    comment_likes: number
  }

  export type CommentCountOutputTypeSelect = {
    comment_ngo?: boolean
    comment_user?: boolean
    comment_likes?: boolean
  }

  export type CommentCountOutputTypeGetPayload<S extends boolean | null | undefined | CommentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CommentCountOutputTypeArgs)
    ? CommentCountOutputType 
    : S extends { select: any } & (CommentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CommentCountOutputType ? CommentCountOutputType[P] : never
  } 
      : CommentCountOutputType




  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect | null
  }



  /**
   * Count Type SourceCountOutputType
   */


  export type SourceCountOutputType = {
    attached_link: number
  }

  export type SourceCountOutputTypeSelect = {
    attached_link?: boolean
  }

  export type SourceCountOutputTypeGetPayload<S extends boolean | null | undefined | SourceCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SourceCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SourceCountOutputTypeArgs)
    ? SourceCountOutputType 
    : S extends { select: any } & (SourceCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SourceCountOutputType ? SourceCountOutputType[P] : never
  } 
      : SourceCountOutputType




  // Custom InputTypes

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect | null
  }



  /**
   * Count Type StatusCountOutputType
   */


  export type StatusCountOutputType = {
    CampaignParticipants: number
    Following: number
  }

  export type StatusCountOutputTypeSelect = {
    CampaignParticipants?: boolean
    Following?: boolean
  }

  export type StatusCountOutputTypeGetPayload<S extends boolean | null | undefined | StatusCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StatusCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StatusCountOutputTypeArgs)
    ? StatusCountOutputType 
    : S extends { select: any } & (StatusCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StatusCountOutputType ? StatusCountOutputType[P] : never
  } 
      : StatusCountOutputType




  // Custom InputTypes

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StatusCountOutputType
     */
    select?: StatusCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    cpf: string | null
    id_gender: string | null
    birthdate: Date | null
    rg: string | null
    id_type: string | null
    description: string | null
    banner_photo: string | null
    photo_url: string | null
    created_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    cpf: string | null
    id_gender: string | null
    birthdate: Date | null
    rg: string | null
    id_type: string | null
    description: string | null
    banner_photo: string | null
    photo_url: string | null
    created_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    cpf: number
    id_gender: number
    birthdate: number
    rg: number
    id_type: number
    description: number
    banner_photo: number
    photo_url: number
    created_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cpf?: true
    id_gender?: true
    birthdate?: true
    rg?: true
    id_type?: true
    description?: true
    banner_photo?: true
    photo_url?: true
    created_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cpf?: true
    id_gender?: true
    birthdate?: true
    rg?: true
    id_type?: true
    description?: true
    banner_photo?: true
    photo_url?: true
    created_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    cpf?: true
    id_gender?: true
    birthdate?: true
    rg?: true
    id_type?: true
    description?: true
    banner_photo?: true
    photo_url?: true
    created_at?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date
    rg: string | null
    id_type: string
    description: string | null
    banner_photo: string
    photo_url: string
    created_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    cpf?: boolean
    id_gender?: boolean
    birthdate?: boolean
    rg?: boolean
    id_type?: boolean
    description?: boolean
    banner_photo?: boolean
    photo_url?: boolean
    created_at?: boolean
    supported_campaigns?: boolean | User$supported_campaignsArgs
    comment_user?: boolean | User$comment_userArgs
    following?: boolean | User$followingArgs
    post_user?: boolean | User$post_userArgs
    gender?: boolean | GenderArgs
    type?: boolean | TypeArgs
    user_address?: boolean | UserAddressArgs
    user_phone?: boolean | UserPhoneArgs
    comment_likes?: boolean | User$comment_likesArgs
    post_likes?: boolean | User$post_likesArgs
    attached_link?: boolean | User$attached_linkArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    supported_campaigns?: boolean | User$supported_campaignsArgs
    comment_user?: boolean | User$comment_userArgs
    following?: boolean | User$followingArgs
    post_user?: boolean | User$post_userArgs
    gender?: boolean | GenderArgs
    type?: boolean | TypeArgs
    user_address?: boolean | UserAddressArgs
    user_phone?: boolean | UserPhoneArgs
    comment_likes?: boolean | User$comment_likesArgs
    post_likes?: boolean | User$post_likesArgs
    attached_link?: boolean | User$attached_linkArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'supported_campaigns' ? Array < CampaignParticipantsGetPayload<S['include'][P]>>  :
        P extends 'comment_user' ? Array < CommentUserGetPayload<S['include'][P]>>  :
        P extends 'following' ? Array < FollowingGetPayload<S['include'][P]>>  :
        P extends 'post_user' ? Array < PostUserGetPayload<S['include'][P]>>  :
        P extends 'gender' ? GenderGetPayload<S['include'][P]> :
        P extends 'type' ? TypeGetPayload<S['include'][P]> :
        P extends 'user_address' ? UserAddressGetPayload<S['include'][P]> | null :
        P extends 'user_phone' ? UserPhoneGetPayload<S['include'][P]> | null :
        P extends 'comment_likes' ? Array < CommentLikesGetPayload<S['include'][P]>>  :
        P extends 'post_likes' ? Array < PostLikesGetPayload<S['include'][P]>>  :
        P extends 'attached_link' ? Array < AttachedLinkGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'supported_campaigns' ? Array < CampaignParticipantsGetPayload<S['select'][P]>>  :
        P extends 'comment_user' ? Array < CommentUserGetPayload<S['select'][P]>>  :
        P extends 'following' ? Array < FollowingGetPayload<S['select'][P]>>  :
        P extends 'post_user' ? Array < PostUserGetPayload<S['select'][P]>>  :
        P extends 'gender' ? GenderGetPayload<S['select'][P]> :
        P extends 'type' ? TypeGetPayload<S['select'][P]> :
        P extends 'user_address' ? UserAddressGetPayload<S['select'][P]> | null :
        P extends 'user_phone' ? UserPhoneGetPayload<S['select'][P]> | null :
        P extends 'comment_likes' ? Array < CommentLikesGetPayload<S['select'][P]>>  :
        P extends 'post_likes' ? Array < PostLikesGetPayload<S['select'][P]>>  :
        P extends 'attached_link' ? Array < AttachedLinkGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    supported_campaigns<T extends User$supported_campaignsArgs= {}>(args?: Subset<T, User$supported_campaignsArgs>): Prisma.PrismaPromise<Array<CampaignParticipantsGetPayload<T>>| Null>;

    comment_user<T extends User$comment_userArgs= {}>(args?: Subset<T, User$comment_userArgs>): Prisma.PrismaPromise<Array<CommentUserGetPayload<T>>| Null>;

    following<T extends User$followingArgs= {}>(args?: Subset<T, User$followingArgs>): Prisma.PrismaPromise<Array<FollowingGetPayload<T>>| Null>;

    post_user<T extends User$post_userArgs= {}>(args?: Subset<T, User$post_userArgs>): Prisma.PrismaPromise<Array<PostUserGetPayload<T>>| Null>;

    gender<T extends GenderArgs= {}>(args?: Subset<T, GenderArgs>): Prisma__GenderClient<GenderGetPayload<T> | Null>;

    type<T extends TypeArgs= {}>(args?: Subset<T, TypeArgs>): Prisma__TypeClient<TypeGetPayload<T> | Null>;

    user_address<T extends UserAddressArgs= {}>(args?: Subset<T, UserAddressArgs>): Prisma__UserAddressClient<UserAddressGetPayload<T> | Null>;

    user_phone<T extends UserPhoneArgs= {}>(args?: Subset<T, UserPhoneArgs>): Prisma__UserPhoneClient<UserPhoneGetPayload<T> | Null>;

    comment_likes<T extends User$comment_likesArgs= {}>(args?: Subset<T, User$comment_likesArgs>): Prisma.PrismaPromise<Array<CommentLikesGetPayload<T>>| Null>;

    post_likes<T extends User$post_likesArgs= {}>(args?: Subset<T, User$post_likesArgs>): Prisma.PrismaPromise<Array<PostLikesGetPayload<T>>| Null>;

    attached_link<T extends User$attached_linkArgs= {}>(args?: Subset<T, User$attached_linkArgs>): Prisma.PrismaPromise<Array<AttachedLinkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.supported_campaigns
   */
  export type User$supported_campaignsArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    where?: CampaignParticipantsWhereInput
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    cursor?: CampaignParticipantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignParticipantsScalarFieldEnum>
  }


  /**
   * User.comment_user
   */
  export type User$comment_userArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    where?: CommentUserWhereInput
    orderBy?: Enumerable<CommentUserOrderByWithRelationInput>
    cursor?: CommentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentUserScalarFieldEnum>
  }


  /**
   * User.following
   */
  export type User$followingArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    where?: FollowingWhereInput
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    cursor?: FollowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FollowingScalarFieldEnum>
  }


  /**
   * User.post_user
   */
  export type User$post_userArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    where?: PostUserWhereInput
    orderBy?: Enumerable<PostUserOrderByWithRelationInput>
    cursor?: PostUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostUserScalarFieldEnum>
  }


  /**
   * User.comment_likes
   */
  export type User$comment_likesArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    where?: CommentLikesWhereInput
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    cursor?: CommentLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentLikesScalarFieldEnum>
  }


  /**
   * User.post_likes
   */
  export type User$post_likesArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    where?: PostLikesWhereInput
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    cursor?: PostLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostLikesScalarFieldEnum>
  }


  /**
   * User.attached_link
   */
  export type User$attached_linkArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    where?: AttachedLinkWhereInput
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    cursor?: AttachedLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AttachedLinkScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Gender
   */


  export type AggregateGender = {
    _count: GenderCountAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  export type GenderMinAggregateOutputType = {
    id: string | null
    name: string | null
    abbreviation: string | null
  }

  export type GenderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    abbreviation: string | null
  }

  export type GenderCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    _all: number
  }


  export type GenderMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
  }

  export type GenderMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
  }

  export type GenderCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    _all?: true
  }

  export type GenderAggregateArgs = {
    /**
     * Filter which Gender to aggregate.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genders
    **/
    _count?: true | GenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenderMaxAggregateInputType
  }

  export type GetGenderAggregateType<T extends GenderAggregateArgs> = {
        [P in keyof T & keyof AggregateGender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGender[P]>
      : GetScalarType<T[P], AggregateGender[P]>
  }




  export type GenderGroupByArgs = {
    where?: GenderWhereInput
    orderBy?: Enumerable<GenderOrderByWithAggregationInput>
    by: GenderScalarFieldEnum[]
    having?: GenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenderCountAggregateInputType | true
    _min?: GenderMinAggregateInputType
    _max?: GenderMaxAggregateInputType
  }


  export type GenderGroupByOutputType = {
    id: string
    name: string
    abbreviation: string
    _count: GenderCountAggregateOutputType | null
    _min: GenderMinAggregateOutputType | null
    _max: GenderMaxAggregateOutputType | null
  }

  type GetGenderGroupByPayload<T extends GenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenderGroupByOutputType[P]>
            : GetScalarType<T[P], GenderGroupByOutputType[P]>
        }
      >
    >


  export type GenderSelect = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    user?: boolean | Gender$userArgs
    _count?: boolean | GenderCountOutputTypeArgs
  }


  export type GenderInclude = {
    user?: boolean | Gender$userArgs
    _count?: boolean | GenderCountOutputTypeArgs
  }

  export type GenderGetPayload<S extends boolean | null | undefined | GenderArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Gender :
    S extends undefined ? never :
    S extends { include: any } & (GenderArgs | GenderFindManyArgs)
    ? Gender  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? GenderCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (GenderArgs | GenderFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? GenderCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Gender ? Gender[P] : never
  } 
      : Gender


  type GenderCountArgs = 
    Omit<GenderFindManyArgs, 'select' | 'include'> & {
      select?: GenderCountAggregateInputType | true
    }

  export interface GenderDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Gender that matches the filter.
     * @param {GenderFindUniqueArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GenderFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GenderFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Gender'> extends True ? Prisma__GenderClient<GenderGetPayload<T>> : Prisma__GenderClient<GenderGetPayload<T> | null, null>

    /**
     * Find one Gender that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GenderFindUniqueOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GenderFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GenderFindUniqueOrThrowArgs>
    ): Prisma__GenderClient<GenderGetPayload<T>>

    /**
     * Find the first Gender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GenderFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GenderFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Gender'> extends True ? Prisma__GenderClient<GenderGetPayload<T>> : Prisma__GenderClient<GenderGetPayload<T> | null, null>

    /**
     * Find the first Gender that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindFirstOrThrowArgs} args - Arguments to find a Gender
     * @example
     * // Get one Gender
     * const gender = await prisma.gender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GenderFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GenderFindFirstOrThrowArgs>
    ): Prisma__GenderClient<GenderGetPayload<T>>

    /**
     * Find zero or more Genders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genders
     * const genders = await prisma.gender.findMany()
     * 
     * // Get first 10 Genders
     * const genders = await prisma.gender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genderWithIdOnly = await prisma.gender.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GenderFindManyArgs>(
      args?: SelectSubset<T, GenderFindManyArgs>
    ): Prisma.PrismaPromise<Array<GenderGetPayload<T>>>

    /**
     * Create a Gender.
     * @param {GenderCreateArgs} args - Arguments to create a Gender.
     * @example
     * // Create one Gender
     * const Gender = await prisma.gender.create({
     *   data: {
     *     // ... data to create a Gender
     *   }
     * })
     * 
    **/
    create<T extends GenderCreateArgs>(
      args: SelectSubset<T, GenderCreateArgs>
    ): Prisma__GenderClient<GenderGetPayload<T>>

    /**
     * Create many Genders.
     *     @param {GenderCreateManyArgs} args - Arguments to create many Genders.
     *     @example
     *     // Create many Genders
     *     const gender = await prisma.gender.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GenderCreateManyArgs>(
      args?: SelectSubset<T, GenderCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Gender.
     * @param {GenderDeleteArgs} args - Arguments to delete one Gender.
     * @example
     * // Delete one Gender
     * const Gender = await prisma.gender.delete({
     *   where: {
     *     // ... filter to delete one Gender
     *   }
     * })
     * 
    **/
    delete<T extends GenderDeleteArgs>(
      args: SelectSubset<T, GenderDeleteArgs>
    ): Prisma__GenderClient<GenderGetPayload<T>>

    /**
     * Update one Gender.
     * @param {GenderUpdateArgs} args - Arguments to update one Gender.
     * @example
     * // Update one Gender
     * const gender = await prisma.gender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GenderUpdateArgs>(
      args: SelectSubset<T, GenderUpdateArgs>
    ): Prisma__GenderClient<GenderGetPayload<T>>

    /**
     * Delete zero or more Genders.
     * @param {GenderDeleteManyArgs} args - Arguments to filter Genders to delete.
     * @example
     * // Delete a few Genders
     * const { count } = await prisma.gender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GenderDeleteManyArgs>(
      args?: SelectSubset<T, GenderDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genders
     * const gender = await prisma.gender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GenderUpdateManyArgs>(
      args: SelectSubset<T, GenderUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gender.
     * @param {GenderUpsertArgs} args - Arguments to update or create a Gender.
     * @example
     * // Update or create a Gender
     * const gender = await prisma.gender.upsert({
     *   create: {
     *     // ... data to create a Gender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gender we want to update
     *   }
     * })
    **/
    upsert<T extends GenderUpsertArgs>(
      args: SelectSubset<T, GenderUpsertArgs>
    ): Prisma__GenderClient<GenderGetPayload<T>>

    /**
     * Count the number of Genders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderCountArgs} args - Arguments to filter Genders to count.
     * @example
     * // Count the number of Genders
     * const count = await prisma.gender.count({
     *   where: {
     *     // ... the filter for the Genders we want to count
     *   }
     * })
    **/
    count<T extends GenderCountArgs>(
      args?: Subset<T, GenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenderAggregateArgs>(args: Subset<T, GenderAggregateArgs>): Prisma.PrismaPromise<GetGenderAggregateType<T>>

    /**
     * Group by Gender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenderGroupByArgs['orderBy'] }
        : { orderBy?: GenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Gender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GenderClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends Gender$userArgs= {}>(args?: Subset<T, Gender$userArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Gender base type for findUnique actions
   */
  export type GenderFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }

  /**
   * Gender findUnique
   */
  export interface GenderFindUniqueArgs extends GenderFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gender findUniqueOrThrow
   */
  export type GenderFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * Filter, which Gender to fetch.
     */
    where: GenderWhereUniqueInput
  }


  /**
   * Gender base type for findFirst actions
   */
  export type GenderFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: Enumerable<GenderScalarFieldEnum>
  }

  /**
   * Gender findFirst
   */
  export interface GenderFindFirstArgs extends GenderFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Gender findFirstOrThrow
   */
  export type GenderFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * Filter, which Gender to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genders.
     */
    distinct?: Enumerable<GenderScalarFieldEnum>
  }


  /**
   * Gender findMany
   */
  export type GenderFindManyArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * Filter, which Genders to fetch.
     */
    where?: GenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genders to fetch.
     */
    orderBy?: Enumerable<GenderOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genders.
     */
    cursor?: GenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genders.
     */
    skip?: number
    distinct?: Enumerable<GenderScalarFieldEnum>
  }


  /**
   * Gender create
   */
  export type GenderCreateArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * The data needed to create a Gender.
     */
    data: XOR<GenderCreateInput, GenderUncheckedCreateInput>
  }


  /**
   * Gender createMany
   */
  export type GenderCreateManyArgs = {
    /**
     * The data used to create many Genders.
     */
    data: Enumerable<GenderCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Gender update
   */
  export type GenderUpdateArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * The data needed to update a Gender.
     */
    data: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
    /**
     * Choose, which Gender to update.
     */
    where: GenderWhereUniqueInput
  }


  /**
   * Gender updateMany
   */
  export type GenderUpdateManyArgs = {
    /**
     * The data used to update Genders.
     */
    data: XOR<GenderUpdateManyMutationInput, GenderUncheckedUpdateManyInput>
    /**
     * Filter which Genders to update
     */
    where?: GenderWhereInput
  }


  /**
   * Gender upsert
   */
  export type GenderUpsertArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * The filter to search for the Gender to update in case it exists.
     */
    where: GenderWhereUniqueInput
    /**
     * In case the Gender found by the `where` argument doesn't exist, create a new Gender with this data.
     */
    create: XOR<GenderCreateInput, GenderUncheckedCreateInput>
    /**
     * In case the Gender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenderUpdateInput, GenderUncheckedUpdateInput>
  }


  /**
   * Gender delete
   */
  export type GenderDeleteArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
    /**
     * Filter which Gender to delete.
     */
    where: GenderWhereUniqueInput
  }


  /**
   * Gender deleteMany
   */
  export type GenderDeleteManyArgs = {
    /**
     * Filter which Genders to delete
     */
    where?: GenderWhereInput
  }


  /**
   * Gender.user
   */
  export type Gender$userArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Gender without action
   */
  export type GenderArgs = {
    /**
     * Select specific fields to fetch from the Gender
     */
    select?: GenderSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GenderInclude | null
  }



  /**
   * Model Phone
   */


  export type AggregatePhone = {
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  export type PhoneMinAggregateOutputType = {
    id: string | null
    number: string | null
  }

  export type PhoneMaxAggregateOutputType = {
    id: string | null
    number: string | null
  }

  export type PhoneCountAggregateOutputType = {
    id: number
    number: number
    _all: number
  }


  export type PhoneMinAggregateInputType = {
    id?: true
    number?: true
  }

  export type PhoneMaxAggregateInputType = {
    id?: true
    number?: true
  }

  export type PhoneCountAggregateInputType = {
    id?: true
    number?: true
    _all?: true
  }

  export type PhoneAggregateArgs = {
    /**
     * Filter which Phone to aggregate.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phones
    **/
    _count?: true | PhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneMaxAggregateInputType
  }

  export type GetPhoneAggregateType<T extends PhoneAggregateArgs> = {
        [P in keyof T & keyof AggregatePhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhone[P]>
      : GetScalarType<T[P], AggregatePhone[P]>
  }




  export type PhoneGroupByArgs = {
    where?: PhoneWhereInput
    orderBy?: Enumerable<PhoneOrderByWithAggregationInput>
    by: PhoneScalarFieldEnum[]
    having?: PhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneCountAggregateInputType | true
    _min?: PhoneMinAggregateInputType
    _max?: PhoneMaxAggregateInputType
  }


  export type PhoneGroupByOutputType = {
    id: string
    number: string | null
    _count: PhoneCountAggregateOutputType | null
    _min: PhoneMinAggregateOutputType | null
    _max: PhoneMaxAggregateOutputType | null
  }

  type GetPhoneGroupByPayload<T extends PhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneGroupByOutputType[P]>
        }
      >
    >


  export type PhoneSelect = {
    id?: boolean
    number?: boolean
    ngo_phone?: boolean | Phone$ngo_phoneArgs
    user_phone?: boolean | Phone$user_phoneArgs
    _count?: boolean | PhoneCountOutputTypeArgs
  }


  export type PhoneInclude = {
    ngo_phone?: boolean | Phone$ngo_phoneArgs
    user_phone?: boolean | Phone$user_phoneArgs
    _count?: boolean | PhoneCountOutputTypeArgs
  }

  export type PhoneGetPayload<S extends boolean | null | undefined | PhoneArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Phone :
    S extends undefined ? never :
    S extends { include: any } & (PhoneArgs | PhoneFindManyArgs)
    ? Phone  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo_phone' ? Array < NgoPhoneGetPayload<S['include'][P]>>  :
        P extends 'user_phone' ? Array < UserPhoneGetPayload<S['include'][P]>>  :
        P extends '_count' ? PhoneCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PhoneArgs | PhoneFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo_phone' ? Array < NgoPhoneGetPayload<S['select'][P]>>  :
        P extends 'user_phone' ? Array < UserPhoneGetPayload<S['select'][P]>>  :
        P extends '_count' ? PhoneCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Phone ? Phone[P] : never
  } 
      : Phone


  type PhoneCountArgs = 
    Omit<PhoneFindManyArgs, 'select' | 'include'> & {
      select?: PhoneCountAggregateInputType | true
    }

  export interface PhoneDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Phone that matches the filter.
     * @param {PhoneFindUniqueArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhoneFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhoneFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Phone'> extends True ? Prisma__PhoneClient<PhoneGetPayload<T>> : Prisma__PhoneClient<PhoneGetPayload<T> | null, null>

    /**
     * Find one Phone that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhoneFindUniqueOrThrowArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhoneFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PhoneFindUniqueOrThrowArgs>
    ): Prisma__PhoneClient<PhoneGetPayload<T>>

    /**
     * Find the first Phone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhoneFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhoneFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Phone'> extends True ? Prisma__PhoneClient<PhoneGetPayload<T>> : Prisma__PhoneClient<PhoneGetPayload<T> | null, null>

    /**
     * Find the first Phone that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindFirstOrThrowArgs} args - Arguments to find a Phone
     * @example
     * // Get one Phone
     * const phone = await prisma.phone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhoneFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PhoneFindFirstOrThrowArgs>
    ): Prisma__PhoneClient<PhoneGetPayload<T>>

    /**
     * Find zero or more Phones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phones
     * const phones = await prisma.phone.findMany()
     * 
     * // Get first 10 Phones
     * const phones = await prisma.phone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneWithIdOnly = await prisma.phone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhoneFindManyArgs>(
      args?: SelectSubset<T, PhoneFindManyArgs>
    ): Prisma.PrismaPromise<Array<PhoneGetPayload<T>>>

    /**
     * Create a Phone.
     * @param {PhoneCreateArgs} args - Arguments to create a Phone.
     * @example
     * // Create one Phone
     * const Phone = await prisma.phone.create({
     *   data: {
     *     // ... data to create a Phone
     *   }
     * })
     * 
    **/
    create<T extends PhoneCreateArgs>(
      args: SelectSubset<T, PhoneCreateArgs>
    ): Prisma__PhoneClient<PhoneGetPayload<T>>

    /**
     * Create many Phones.
     *     @param {PhoneCreateManyArgs} args - Arguments to create many Phones.
     *     @example
     *     // Create many Phones
     *     const phone = await prisma.phone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhoneCreateManyArgs>(
      args?: SelectSubset<T, PhoneCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Phone.
     * @param {PhoneDeleteArgs} args - Arguments to delete one Phone.
     * @example
     * // Delete one Phone
     * const Phone = await prisma.phone.delete({
     *   where: {
     *     // ... filter to delete one Phone
     *   }
     * })
     * 
    **/
    delete<T extends PhoneDeleteArgs>(
      args: SelectSubset<T, PhoneDeleteArgs>
    ): Prisma__PhoneClient<PhoneGetPayload<T>>

    /**
     * Update one Phone.
     * @param {PhoneUpdateArgs} args - Arguments to update one Phone.
     * @example
     * // Update one Phone
     * const phone = await prisma.phone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhoneUpdateArgs>(
      args: SelectSubset<T, PhoneUpdateArgs>
    ): Prisma__PhoneClient<PhoneGetPayload<T>>

    /**
     * Delete zero or more Phones.
     * @param {PhoneDeleteManyArgs} args - Arguments to filter Phones to delete.
     * @example
     * // Delete a few Phones
     * const { count } = await prisma.phone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhoneDeleteManyArgs>(
      args?: SelectSubset<T, PhoneDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phones
     * const phone = await prisma.phone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhoneUpdateManyArgs>(
      args: SelectSubset<T, PhoneUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Phone.
     * @param {PhoneUpsertArgs} args - Arguments to update or create a Phone.
     * @example
     * // Update or create a Phone
     * const phone = await prisma.phone.upsert({
     *   create: {
     *     // ... data to create a Phone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phone we want to update
     *   }
     * })
    **/
    upsert<T extends PhoneUpsertArgs>(
      args: SelectSubset<T, PhoneUpsertArgs>
    ): Prisma__PhoneClient<PhoneGetPayload<T>>

    /**
     * Count the number of Phones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneCountArgs} args - Arguments to filter Phones to count.
     * @example
     * // Count the number of Phones
     * const count = await prisma.phone.count({
     *   where: {
     *     // ... the filter for the Phones we want to count
     *   }
     * })
    **/
    count<T extends PhoneCountArgs>(
      args?: Subset<T, PhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneAggregateArgs>(args: Subset<T, PhoneAggregateArgs>): Prisma.PrismaPromise<GetPhoneAggregateType<T>>

    /**
     * Group by Phone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneGroupByArgs['orderBy'] }
        : { orderBy?: PhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Phone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhoneClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo_phone<T extends Phone$ngo_phoneArgs= {}>(args?: Subset<T, Phone$ngo_phoneArgs>): Prisma.PrismaPromise<Array<NgoPhoneGetPayload<T>>| Null>;

    user_phone<T extends Phone$user_phoneArgs= {}>(args?: Subset<T, Phone$user_phoneArgs>): Prisma.PrismaPromise<Array<UserPhoneGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Phone base type for findUnique actions
   */
  export type PhoneFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * Filter, which Phone to fetch.
     */
    where: PhoneWhereUniqueInput
  }

  /**
   * Phone findUnique
   */
  export interface PhoneFindUniqueArgs extends PhoneFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Phone findUniqueOrThrow
   */
  export type PhoneFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * Filter, which Phone to fetch.
     */
    where: PhoneWhereUniqueInput
  }


  /**
   * Phone base type for findFirst actions
   */
  export type PhoneFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * Filter, which Phone to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     */
    distinct?: Enumerable<PhoneScalarFieldEnum>
  }

  /**
   * Phone findFirst
   */
  export interface PhoneFindFirstArgs extends PhoneFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Phone findFirstOrThrow
   */
  export type PhoneFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * Filter, which Phone to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phones.
     */
    distinct?: Enumerable<PhoneScalarFieldEnum>
  }


  /**
   * Phone findMany
   */
  export type PhoneFindManyArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * Filter, which Phones to fetch.
     */
    where?: PhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phones to fetch.
     */
    orderBy?: Enumerable<PhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phones.
     */
    cursor?: PhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phones.
     */
    skip?: number
    distinct?: Enumerable<PhoneScalarFieldEnum>
  }


  /**
   * Phone create
   */
  export type PhoneCreateArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * The data needed to create a Phone.
     */
    data: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
  }


  /**
   * Phone createMany
   */
  export type PhoneCreateManyArgs = {
    /**
     * The data used to create many Phones.
     */
    data: Enumerable<PhoneCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Phone update
   */
  export type PhoneUpdateArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * The data needed to update a Phone.
     */
    data: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
    /**
     * Choose, which Phone to update.
     */
    where: PhoneWhereUniqueInput
  }


  /**
   * Phone updateMany
   */
  export type PhoneUpdateManyArgs = {
    /**
     * The data used to update Phones.
     */
    data: XOR<PhoneUpdateManyMutationInput, PhoneUncheckedUpdateManyInput>
    /**
     * Filter which Phones to update
     */
    where?: PhoneWhereInput
  }


  /**
   * Phone upsert
   */
  export type PhoneUpsertArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * The filter to search for the Phone to update in case it exists.
     */
    where: PhoneWhereUniqueInput
    /**
     * In case the Phone found by the `where` argument doesn't exist, create a new Phone with this data.
     */
    create: XOR<PhoneCreateInput, PhoneUncheckedCreateInput>
    /**
     * In case the Phone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneUpdateInput, PhoneUncheckedUpdateInput>
  }


  /**
   * Phone delete
   */
  export type PhoneDeleteArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
    /**
     * Filter which Phone to delete.
     */
    where: PhoneWhereUniqueInput
  }


  /**
   * Phone deleteMany
   */
  export type PhoneDeleteManyArgs = {
    /**
     * Filter which Phones to delete
     */
    where?: PhoneWhereInput
  }


  /**
   * Phone.ngo_phone
   */
  export type Phone$ngo_phoneArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    where?: NgoPhoneWhereInput
    orderBy?: Enumerable<NgoPhoneOrderByWithRelationInput>
    cursor?: NgoPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NgoPhoneScalarFieldEnum>
  }


  /**
   * Phone.user_phone
   */
  export type Phone$user_phoneArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    where?: UserPhoneWhereInput
    orderBy?: Enumerable<UserPhoneOrderByWithRelationInput>
    cursor?: UserPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserPhoneScalarFieldEnum>
  }


  /**
   * Phone without action
   */
  export type PhoneArgs = {
    /**
     * Select specific fields to fetch from the Phone
     */
    select?: PhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhoneInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    postal_code: string | null
    number: string | null
    complement: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    postal_code: string | null
    number: string | null
    complement: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    postal_code: number
    number: number
    complement: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    postal_code?: true
    number?: true
    complement?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    postal_code?: true
    number?: true
    complement?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    postal_code?: true
    number?: true
    complement?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs = {
    where?: AddressWhereInput
    orderBy?: Enumerable<AddressOrderByWithAggregationInput>
    by: AddressScalarFieldEnum[]
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }


  export type AddressGroupByOutputType = {
    id: string
    postal_code: string
    number: string
    complement: string | null
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect = {
    id?: boolean
    postal_code?: boolean
    number?: boolean
    complement?: boolean
    campaign_address?: boolean | Address$campaign_addressArgs
    ngo_address?: boolean | Address$ngo_addressArgs
    user_address?: boolean | Address$user_addressArgs
    _count?: boolean | AddressCountOutputTypeArgs
  }


  export type AddressInclude = {
    campaign_address?: boolean | Address$campaign_addressArgs
    ngo_address?: boolean | Address$ngo_addressArgs
    user_address?: boolean | Address$user_addressArgs
    _count?: boolean | AddressCountOutputTypeArgs
  }

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs | AddressFindManyArgs)
    ? Address  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign_address' ? Array < CampaignAddressGetPayload<S['include'][P]>>  :
        P extends 'ngo_address' ? Array < NgoAddressGetPayload<S['include'][P]>>  :
        P extends 'user_address' ? Array < UserAddressGetPayload<S['include'][P]>>  :
        P extends '_count' ? AddressCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (AddressArgs | AddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign_address' ? Array < CampaignAddressGetPayload<S['select'][P]>>  :
        P extends 'ngo_address' ? Array < NgoAddressGetPayload<S['select'][P]>>  :
        P extends 'user_address' ? Array < UserAddressGetPayload<S['select'][P]>>  :
        P extends '_count' ? AddressCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Address ? Address[P] : never
  } 
      : Address


  type AddressCountArgs = 
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AddressFindUniqueOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? Prisma__AddressClient<AddressGetPayload<T>> : Prisma__AddressClient<AddressGetPayload<T> | null, null>

    /**
     * Find the first Address that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): Prisma.PrismaPromise<Array<AddressGetPayload<T>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Create many Addresses.
     *     @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): Prisma__AddressClient<AddressGetPayload<T>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign_address<T extends Address$campaign_addressArgs= {}>(args?: Subset<T, Address$campaign_addressArgs>): Prisma.PrismaPromise<Array<CampaignAddressGetPayload<T>>| Null>;

    ngo_address<T extends Address$ngo_addressArgs= {}>(args?: Subset<T, Address$ngo_addressArgs>): Prisma.PrismaPromise<Array<NgoAddressGetPayload<T>>| Null>;

    user_address<T extends Address$user_addressArgs= {}>(args?: Subset<T, Address$user_addressArgs>): Prisma.PrismaPromise<Array<UserAddressGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address base type for findUnique actions
   */
  export type AddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUnique
   */
  export interface AddressFindUniqueArgs extends AddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address base type for findFirst actions
   */
  export type AddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }

  /**
   * Address findFirst
   */
  export interface AddressFindFirstArgs extends AddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: Enumerable<AddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address createMany
   */
  export type AddressCreateManyArgs = {
    /**
     * The data used to create many Addresses.
     */
    data: Enumerable<AddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }


  /**
   * Address.campaign_address
   */
  export type Address$campaign_addressArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    where?: CampaignAddressWhereInput
    orderBy?: Enumerable<CampaignAddressOrderByWithRelationInput>
    cursor?: CampaignAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignAddressScalarFieldEnum>
  }


  /**
   * Address.ngo_address
   */
  export type Address$ngo_addressArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    where?: NgoAddressWhereInput
    orderBy?: Enumerable<NgoAddressOrderByWithRelationInput>
    cursor?: NgoAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NgoAddressScalarFieldEnum>
  }


  /**
   * Address.user_address
   */
  export type Address$user_addressArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    cursor?: UserAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
  }



  /**
   * Model UserAddress
   */


  export type AggregateUserAddress = {
    _count: UserAddressCountAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  export type UserAddressMinAggregateOutputType = {
    id: string | null
    id_address: string | null
    id_user: string | null
  }

  export type UserAddressMaxAggregateOutputType = {
    id: string | null
    id_address: string | null
    id_user: string | null
  }

  export type UserAddressCountAggregateOutputType = {
    id: number
    id_address: number
    id_user: number
    _all: number
  }


  export type UserAddressMinAggregateInputType = {
    id?: true
    id_address?: true
    id_user?: true
  }

  export type UserAddressMaxAggregateInputType = {
    id?: true
    id_address?: true
    id_user?: true
  }

  export type UserAddressCountAggregateInputType = {
    id?: true
    id_address?: true
    id_user?: true
    _all?: true
  }

  export type UserAddressAggregateArgs = {
    /**
     * Filter which UserAddress to aggregate.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAddresses
    **/
    _count?: true | UserAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAddressMaxAggregateInputType
  }

  export type GetUserAddressAggregateType<T extends UserAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAddress[P]>
      : GetScalarType<T[P], AggregateUserAddress[P]>
  }




  export type UserAddressGroupByArgs = {
    where?: UserAddressWhereInput
    orderBy?: Enumerable<UserAddressOrderByWithAggregationInput>
    by: UserAddressScalarFieldEnum[]
    having?: UserAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAddressCountAggregateInputType | true
    _min?: UserAddressMinAggregateInputType
    _max?: UserAddressMaxAggregateInputType
  }


  export type UserAddressGroupByOutputType = {
    id: string
    id_address: string
    id_user: string
    _count: UserAddressCountAggregateOutputType | null
    _min: UserAddressMinAggregateOutputType | null
    _max: UserAddressMaxAggregateOutputType | null
  }

  type GetUserAddressGroupByPayload<T extends UserAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAddressGroupByOutputType[P]>
        }
      >
    >


  export type UserAddressSelect = {
    id?: boolean
    id_address?: boolean
    id_user?: boolean
    address?: boolean | AddressArgs
    user?: boolean | UserArgs
  }


  export type UserAddressInclude = {
    address?: boolean | AddressArgs
    user?: boolean | UserArgs
  }

  export type UserAddressGetPayload<S extends boolean | null | undefined | UserAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserAddress :
    S extends undefined ? never :
    S extends { include: any } & (UserAddressArgs | UserAddressFindManyArgs)
    ? UserAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? AddressGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserAddressArgs | UserAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserAddress ? UserAddress[P] : never
  } 
      : UserAddress


  type UserAddressCountArgs = 
    Omit<UserAddressFindManyArgs, 'select' | 'include'> & {
      select?: UserAddressCountAggregateInputType | true
    }

  export interface UserAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserAddress that matches the filter.
     * @param {UserAddressFindUniqueArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserAddress'> extends True ? Prisma__UserAddressClient<UserAddressGetPayload<T>> : Prisma__UserAddressClient<UserAddressGetPayload<T> | null, null>

    /**
     * Find one UserAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserAddressFindUniqueOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserAddressFindUniqueOrThrowArgs>
    ): Prisma__UserAddressClient<UserAddressGetPayload<T>>

    /**
     * Find the first UserAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserAddress'> extends True ? Prisma__UserAddressClient<UserAddressGetPayload<T>> : Prisma__UserAddressClient<UserAddressGetPayload<T> | null, null>

    /**
     * Find the first UserAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindFirstOrThrowArgs} args - Arguments to find a UserAddress
     * @example
     * // Get one UserAddress
     * const userAddress = await prisma.userAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserAddressFindFirstOrThrowArgs>
    ): Prisma__UserAddressClient<UserAddressGetPayload<T>>

    /**
     * Find zero or more UserAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAddresses
     * const userAddresses = await prisma.userAddress.findMany()
     * 
     * // Get first 10 UserAddresses
     * const userAddresses = await prisma.userAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAddressWithIdOnly = await prisma.userAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAddressFindManyArgs>(
      args?: SelectSubset<T, UserAddressFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserAddressGetPayload<T>>>

    /**
     * Create a UserAddress.
     * @param {UserAddressCreateArgs} args - Arguments to create a UserAddress.
     * @example
     * // Create one UserAddress
     * const UserAddress = await prisma.userAddress.create({
     *   data: {
     *     // ... data to create a UserAddress
     *   }
     * })
     * 
    **/
    create<T extends UserAddressCreateArgs>(
      args: SelectSubset<T, UserAddressCreateArgs>
    ): Prisma__UserAddressClient<UserAddressGetPayload<T>>

    /**
     * Create many UserAddresses.
     *     @param {UserAddressCreateManyArgs} args - Arguments to create many UserAddresses.
     *     @example
     *     // Create many UserAddresses
     *     const userAddress = await prisma.userAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAddressCreateManyArgs>(
      args?: SelectSubset<T, UserAddressCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAddress.
     * @param {UserAddressDeleteArgs} args - Arguments to delete one UserAddress.
     * @example
     * // Delete one UserAddress
     * const UserAddress = await prisma.userAddress.delete({
     *   where: {
     *     // ... filter to delete one UserAddress
     *   }
     * })
     * 
    **/
    delete<T extends UserAddressDeleteArgs>(
      args: SelectSubset<T, UserAddressDeleteArgs>
    ): Prisma__UserAddressClient<UserAddressGetPayload<T>>

    /**
     * Update one UserAddress.
     * @param {UserAddressUpdateArgs} args - Arguments to update one UserAddress.
     * @example
     * // Update one UserAddress
     * const userAddress = await prisma.userAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAddressUpdateArgs>(
      args: SelectSubset<T, UserAddressUpdateArgs>
    ): Prisma__UserAddressClient<UserAddressGetPayload<T>>

    /**
     * Delete zero or more UserAddresses.
     * @param {UserAddressDeleteManyArgs} args - Arguments to filter UserAddresses to delete.
     * @example
     * // Delete a few UserAddresses
     * const { count } = await prisma.userAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAddressDeleteManyArgs>(
      args?: SelectSubset<T, UserAddressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAddresses
     * const userAddress = await prisma.userAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAddressUpdateManyArgs>(
      args: SelectSubset<T, UserAddressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAddress.
     * @param {UserAddressUpsertArgs} args - Arguments to update or create a UserAddress.
     * @example
     * // Update or create a UserAddress
     * const userAddress = await prisma.userAddress.upsert({
     *   create: {
     *     // ... data to create a UserAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAddress we want to update
     *   }
     * })
    **/
    upsert<T extends UserAddressUpsertArgs>(
      args: SelectSubset<T, UserAddressUpsertArgs>
    ): Prisma__UserAddressClient<UserAddressGetPayload<T>>

    /**
     * Count the number of UserAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressCountArgs} args - Arguments to filter UserAddresses to count.
     * @example
     * // Count the number of UserAddresses
     * const count = await prisma.userAddress.count({
     *   where: {
     *     // ... the filter for the UserAddresses we want to count
     *   }
     * })
    **/
    count<T extends UserAddressCountArgs>(
      args?: Subset<T, UserAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAddressAggregateArgs>(args: Subset<T, UserAddressAggregateArgs>): Prisma.PrismaPromise<GetUserAddressAggregateType<T>>

    /**
     * Group by UserAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAddressGroupByArgs['orderBy'] }
        : { orderBy?: UserAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserAddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserAddress base type for findUnique actions
   */
  export type UserAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }

  /**
   * UserAddress findUnique
   */
  export interface UserAddressFindUniqueArgs extends UserAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAddress findUniqueOrThrow
   */
  export type UserAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress base type for findFirst actions
   */
  export type UserAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }

  /**
   * UserAddress findFirst
   */
  export interface UserAddressFindFirstArgs extends UserAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAddress findFirstOrThrow
   */
  export type UserAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddress to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAddresses.
     */
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress findMany
   */
  export type UserAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * Filter, which UserAddresses to fetch.
     */
    where?: UserAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAddresses to fetch.
     */
    orderBy?: Enumerable<UserAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAddresses.
     */
    cursor?: UserAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAddresses.
     */
    skip?: number
    distinct?: Enumerable<UserAddressScalarFieldEnum>
  }


  /**
   * UserAddress create
   */
  export type UserAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * The data needed to create a UserAddress.
     */
    data: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
  }


  /**
   * UserAddress createMany
   */
  export type UserAddressCreateManyArgs = {
    /**
     * The data used to create many UserAddresses.
     */
    data: Enumerable<UserAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserAddress update
   */
  export type UserAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * The data needed to update a UserAddress.
     */
    data: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
    /**
     * Choose, which UserAddress to update.
     */
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress updateMany
   */
  export type UserAddressUpdateManyArgs = {
    /**
     * The data used to update UserAddresses.
     */
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyInput>
    /**
     * Filter which UserAddresses to update
     */
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress upsert
   */
  export type UserAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * The filter to search for the UserAddress to update in case it exists.
     */
    where: UserAddressWhereUniqueInput
    /**
     * In case the UserAddress found by the `where` argument doesn't exist, create a new UserAddress with this data.
     */
    create: XOR<UserAddressCreateInput, UserAddressUncheckedCreateInput>
    /**
     * In case the UserAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAddressUpdateInput, UserAddressUncheckedUpdateInput>
  }


  /**
   * UserAddress delete
   */
  export type UserAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
    /**
     * Filter which UserAddress to delete.
     */
    where: UserAddressWhereUniqueInput
  }


  /**
   * UserAddress deleteMany
   */
  export type UserAddressDeleteManyArgs = {
    /**
     * Filter which UserAddresses to delete
     */
    where?: UserAddressWhereInput
  }


  /**
   * UserAddress without action
   */
  export type UserAddressArgs = {
    /**
     * Select specific fields to fetch from the UserAddress
     */
    select?: UserAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAddressInclude | null
  }



  /**
   * Model Campaign
   */


  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    begin_date: Date | null
    end_date: Date | null
    home_office: boolean | null
    id_ngo: string | null
    how_to_contribute: string | null
    prerequisites: string | null
    created_at: Date | null
    is_active: boolean | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    begin_date: Date | null
    end_date: Date | null
    home_office: boolean | null
    id_ngo: string | null
    how_to_contribute: string | null
    prerequisites: string | null
    created_at: Date | null
    is_active: boolean | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    title: number
    description: number
    begin_date: number
    end_date: number
    home_office: number
    id_ngo: number
    how_to_contribute: number
    prerequisites: number
    created_at: number
    is_active: number
    _all: number
  }


  export type CampaignMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    begin_date?: true
    end_date?: true
    home_office?: true
    id_ngo?: true
    how_to_contribute?: true
    prerequisites?: true
    created_at?: true
    is_active?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    begin_date?: true
    end_date?: true
    home_office?: true
    id_ngo?: true
    how_to_contribute?: true
    prerequisites?: true
    created_at?: true
    is_active?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    begin_date?: true
    end_date?: true
    home_office?: true
    id_ngo?: true
    how_to_contribute?: true
    prerequisites?: true
    created_at?: true
    is_active?: true
    _all?: true
  }

  export type CampaignAggregateArgs = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs = {
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithAggregationInput>
    by: CampaignScalarFieldEnum[]
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }


  export type CampaignGroupByOutputType = {
    id: string
    title: string
    description: string | null
    begin_date: Date
    end_date: Date
    home_office: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at: Date
    is_active: boolean
    _count: CampaignCountAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    begin_date?: boolean
    end_date?: boolean
    home_office?: boolean
    id_ngo?: boolean
    how_to_contribute?: boolean
    prerequisites?: boolean
    created_at?: boolean
    is_active?: boolean
    ngo?: boolean | NGOArgs
    campaign_address?: boolean | CampaignAddressArgs
    campaign_causes?: boolean | Campaign$campaign_causesArgs
    campaign_participants?: boolean | Campaign$campaign_participantsArgs
    campaign_photos?: boolean | Campaign$campaign_photosArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }


  export type CampaignInclude = {
    ngo?: boolean | NGOArgs
    campaign_address?: boolean | CampaignAddressArgs
    campaign_causes?: boolean | Campaign$campaign_causesArgs
    campaign_participants?: boolean | Campaign$campaign_participantsArgs
    campaign_photos?: boolean | Campaign$campaign_photosArgs
    _count?: boolean | CampaignCountOutputTypeArgs
  }

  export type CampaignGetPayload<S extends boolean | null | undefined | CampaignArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Campaign :
    S extends undefined ? never :
    S extends { include: any } & (CampaignArgs | CampaignFindManyArgs)
    ? Campaign  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :
        P extends 'campaign_address' ? CampaignAddressGetPayload<S['include'][P]> | null :
        P extends 'campaign_causes' ? Array < CampaignCausesGetPayload<S['include'][P]>>  :
        P extends 'campaign_participants' ? Array < CampaignParticipantsGetPayload<S['include'][P]>>  :
        P extends 'campaign_photos' ? Array < CampaignPhotosGetPayload<S['include'][P]>>  :
        P extends '_count' ? CampaignCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CampaignArgs | CampaignFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :
        P extends 'campaign_address' ? CampaignAddressGetPayload<S['select'][P]> | null :
        P extends 'campaign_causes' ? Array < CampaignCausesGetPayload<S['select'][P]>>  :
        P extends 'campaign_participants' ? Array < CampaignParticipantsGetPayload<S['select'][P]>>  :
        P extends 'campaign_photos' ? Array < CampaignPhotosGetPayload<S['select'][P]>>  :
        P extends '_count' ? CampaignCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Campaign ? Campaign[P] : never
  } 
      : Campaign


  type CampaignCountArgs = 
    Omit<CampaignFindManyArgs, 'select' | 'include'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Campaign'> extends True ? Prisma__CampaignClient<CampaignGetPayload<T>> : Prisma__CampaignClient<CampaignGetPayload<T> | null, null>

    /**
     * Find one Campaign that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignFindUniqueOrThrowArgs>
    ): Prisma__CampaignClient<CampaignGetPayload<T>>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Campaign'> extends True ? Prisma__CampaignClient<CampaignGetPayload<T>> : Prisma__CampaignClient<CampaignGetPayload<T> | null, null>

    /**
     * Find the first Campaign that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignFindFirstOrThrowArgs>
    ): Prisma__CampaignClient<CampaignGetPayload<T>>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignFindManyArgs>(
      args?: SelectSubset<T, CampaignFindManyArgs>
    ): Prisma.PrismaPromise<Array<CampaignGetPayload<T>>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
    **/
    create<T extends CampaignCreateArgs>(
      args: SelectSubset<T, CampaignCreateArgs>
    ): Prisma__CampaignClient<CampaignGetPayload<T>>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCreateManyArgs>(
      args?: SelectSubset<T, CampaignCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
    **/
    delete<T extends CampaignDeleteArgs>(
      args: SelectSubset<T, CampaignDeleteArgs>
    ): Prisma__CampaignClient<CampaignGetPayload<T>>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignUpdateArgs>(
      args: SelectSubset<T, CampaignUpdateArgs>
    ): Prisma__CampaignClient<CampaignGetPayload<T>>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignDeleteManyArgs>(
      args?: SelectSubset<T, CampaignDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignUpdateManyArgs>(
      args: SelectSubset<T, CampaignUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs>(
      args: SelectSubset<T, CampaignUpsertArgs>
    ): Prisma__CampaignClient<CampaignGetPayload<T>>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    campaign_address<T extends CampaignAddressArgs= {}>(args?: Subset<T, CampaignAddressArgs>): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T> | Null>;

    campaign_causes<T extends Campaign$campaign_causesArgs= {}>(args?: Subset<T, Campaign$campaign_causesArgs>): Prisma.PrismaPromise<Array<CampaignCausesGetPayload<T>>| Null>;

    campaign_participants<T extends Campaign$campaign_participantsArgs= {}>(args?: Subset<T, Campaign$campaign_participantsArgs>): Prisma.PrismaPromise<Array<CampaignParticipantsGetPayload<T>>| Null>;

    campaign_photos<T extends Campaign$campaign_photosArgs= {}>(args?: Subset<T, Campaign$campaign_photosArgs>): Prisma.PrismaPromise<Array<CampaignPhotosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Campaign base type for findUnique actions
   */
  export type CampaignFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUnique
   */
  export interface CampaignFindUniqueArgs extends CampaignFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign base type for findFirst actions
   */
  export type CampaignFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }

  /**
   * Campaign findFirst
   */
  export interface CampaignFindFirstArgs extends CampaignFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs = {
    /**
     * The data used to create many Campaigns.
     */
    data: Enumerable<CampaignCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign.campaign_causes
   */
  export type Campaign$campaign_causesArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    where?: CampaignCausesWhereInput
    orderBy?: Enumerable<CampaignCausesOrderByWithRelationInput>
    cursor?: CampaignCausesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignCausesScalarFieldEnum>
  }


  /**
   * Campaign.campaign_participants
   */
  export type Campaign$campaign_participantsArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    where?: CampaignParticipantsWhereInput
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    cursor?: CampaignParticipantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignParticipantsScalarFieldEnum>
  }


  /**
   * Campaign.campaign_photos
   */
  export type Campaign$campaign_photosArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    where?: CampaignPhotosWhereInput
    orderBy?: Enumerable<CampaignPhotosOrderByWithRelationInput>
    cursor?: CampaignPhotosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignPhotosScalarFieldEnum>
  }


  /**
   * Campaign without action
   */
  export type CampaignArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
  }



  /**
   * Model CampaignAddress
   */


  export type AggregateCampaignAddress = {
    _count: CampaignAddressCountAggregateOutputType | null
    _min: CampaignAddressMinAggregateOutputType | null
    _max: CampaignAddressMaxAggregateOutputType | null
  }

  export type CampaignAddressMinAggregateOutputType = {
    id: string | null
    id_campaign: string | null
    id_address: string | null
  }

  export type CampaignAddressMaxAggregateOutputType = {
    id: string | null
    id_campaign: string | null
    id_address: string | null
  }

  export type CampaignAddressCountAggregateOutputType = {
    id: number
    id_campaign: number
    id_address: number
    _all: number
  }


  export type CampaignAddressMinAggregateInputType = {
    id?: true
    id_campaign?: true
    id_address?: true
  }

  export type CampaignAddressMaxAggregateInputType = {
    id?: true
    id_campaign?: true
    id_address?: true
  }

  export type CampaignAddressCountAggregateInputType = {
    id?: true
    id_campaign?: true
    id_address?: true
    _all?: true
  }

  export type CampaignAddressAggregateArgs = {
    /**
     * Filter which CampaignAddress to aggregate.
     */
    where?: CampaignAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAddresses to fetch.
     */
    orderBy?: Enumerable<CampaignAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignAddresses
    **/
    _count?: true | CampaignAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignAddressMaxAggregateInputType
  }

  export type GetCampaignAddressAggregateType<T extends CampaignAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignAddress[P]>
      : GetScalarType<T[P], AggregateCampaignAddress[P]>
  }




  export type CampaignAddressGroupByArgs = {
    where?: CampaignAddressWhereInput
    orderBy?: Enumerable<CampaignAddressOrderByWithAggregationInput>
    by: CampaignAddressScalarFieldEnum[]
    having?: CampaignAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignAddressCountAggregateInputType | true
    _min?: CampaignAddressMinAggregateInputType
    _max?: CampaignAddressMaxAggregateInputType
  }


  export type CampaignAddressGroupByOutputType = {
    id: string
    id_campaign: string
    id_address: string
    _count: CampaignAddressCountAggregateOutputType | null
    _min: CampaignAddressMinAggregateOutputType | null
    _max: CampaignAddressMaxAggregateOutputType | null
  }

  type GetCampaignAddressGroupByPayload<T extends CampaignAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CampaignAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignAddressGroupByOutputType[P]>
        }
      >
    >


  export type CampaignAddressSelect = {
    id?: boolean
    id_campaign?: boolean
    id_address?: boolean
    campaign?: boolean | CampaignArgs
    address?: boolean | AddressArgs
  }


  export type CampaignAddressInclude = {
    campaign?: boolean | CampaignArgs
    address?: boolean | AddressArgs
  }

  export type CampaignAddressGetPayload<S extends boolean | null | undefined | CampaignAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CampaignAddress :
    S extends undefined ? never :
    S extends { include: any } & (CampaignAddressArgs | CampaignAddressFindManyArgs)
    ? CampaignAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign' ? CampaignGetPayload<S['include'][P]> :
        P extends 'address' ? AddressGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CampaignAddressArgs | CampaignAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign' ? CampaignGetPayload<S['select'][P]> :
        P extends 'address' ? AddressGetPayload<S['select'][P]> :  P extends keyof CampaignAddress ? CampaignAddress[P] : never
  } 
      : CampaignAddress


  type CampaignAddressCountArgs = 
    Omit<CampaignAddressFindManyArgs, 'select' | 'include'> & {
      select?: CampaignAddressCountAggregateInputType | true
    }

  export interface CampaignAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CampaignAddress that matches the filter.
     * @param {CampaignAddressFindUniqueArgs} args - Arguments to find a CampaignAddress
     * @example
     * // Get one CampaignAddress
     * const campaignAddress = await prisma.campaignAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignAddress'> extends True ? Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>> : Prisma__CampaignAddressClient<CampaignAddressGetPayload<T> | null, null>

    /**
     * Find one CampaignAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignAddressFindUniqueOrThrowArgs} args - Arguments to find a CampaignAddress
     * @example
     * // Get one CampaignAddress
     * const campaignAddress = await prisma.campaignAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignAddressFindUniqueOrThrowArgs>
    ): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>>

    /**
     * Find the first CampaignAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressFindFirstArgs} args - Arguments to find a CampaignAddress
     * @example
     * // Get one CampaignAddress
     * const campaignAddress = await prisma.campaignAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignAddress'> extends True ? Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>> : Prisma__CampaignAddressClient<CampaignAddressGetPayload<T> | null, null>

    /**
     * Find the first CampaignAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressFindFirstOrThrowArgs} args - Arguments to find a CampaignAddress
     * @example
     * // Get one CampaignAddress
     * const campaignAddress = await prisma.campaignAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignAddressFindFirstOrThrowArgs>
    ): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>>

    /**
     * Find zero or more CampaignAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignAddresses
     * const campaignAddresses = await prisma.campaignAddress.findMany()
     * 
     * // Get first 10 CampaignAddresses
     * const campaignAddresses = await prisma.campaignAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignAddressWithIdOnly = await prisma.campaignAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignAddressFindManyArgs>(
      args?: SelectSubset<T, CampaignAddressFindManyArgs>
    ): Prisma.PrismaPromise<Array<CampaignAddressGetPayload<T>>>

    /**
     * Create a CampaignAddress.
     * @param {CampaignAddressCreateArgs} args - Arguments to create a CampaignAddress.
     * @example
     * // Create one CampaignAddress
     * const CampaignAddress = await prisma.campaignAddress.create({
     *   data: {
     *     // ... data to create a CampaignAddress
     *   }
     * })
     * 
    **/
    create<T extends CampaignAddressCreateArgs>(
      args: SelectSubset<T, CampaignAddressCreateArgs>
    ): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>>

    /**
     * Create many CampaignAddresses.
     *     @param {CampaignAddressCreateManyArgs} args - Arguments to create many CampaignAddresses.
     *     @example
     *     // Create many CampaignAddresses
     *     const campaignAddress = await prisma.campaignAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignAddressCreateManyArgs>(
      args?: SelectSubset<T, CampaignAddressCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignAddress.
     * @param {CampaignAddressDeleteArgs} args - Arguments to delete one CampaignAddress.
     * @example
     * // Delete one CampaignAddress
     * const CampaignAddress = await prisma.campaignAddress.delete({
     *   where: {
     *     // ... filter to delete one CampaignAddress
     *   }
     * })
     * 
    **/
    delete<T extends CampaignAddressDeleteArgs>(
      args: SelectSubset<T, CampaignAddressDeleteArgs>
    ): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>>

    /**
     * Update one CampaignAddress.
     * @param {CampaignAddressUpdateArgs} args - Arguments to update one CampaignAddress.
     * @example
     * // Update one CampaignAddress
     * const campaignAddress = await prisma.campaignAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignAddressUpdateArgs>(
      args: SelectSubset<T, CampaignAddressUpdateArgs>
    ): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>>

    /**
     * Delete zero or more CampaignAddresses.
     * @param {CampaignAddressDeleteManyArgs} args - Arguments to filter CampaignAddresses to delete.
     * @example
     * // Delete a few CampaignAddresses
     * const { count } = await prisma.campaignAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignAddressDeleteManyArgs>(
      args?: SelectSubset<T, CampaignAddressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignAddresses
     * const campaignAddress = await prisma.campaignAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignAddressUpdateManyArgs>(
      args: SelectSubset<T, CampaignAddressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignAddress.
     * @param {CampaignAddressUpsertArgs} args - Arguments to update or create a CampaignAddress.
     * @example
     * // Update or create a CampaignAddress
     * const campaignAddress = await prisma.campaignAddress.upsert({
     *   create: {
     *     // ... data to create a CampaignAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignAddress we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignAddressUpsertArgs>(
      args: SelectSubset<T, CampaignAddressUpsertArgs>
    ): Prisma__CampaignAddressClient<CampaignAddressGetPayload<T>>

    /**
     * Count the number of CampaignAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressCountArgs} args - Arguments to filter CampaignAddresses to count.
     * @example
     * // Count the number of CampaignAddresses
     * const count = await prisma.campaignAddress.count({
     *   where: {
     *     // ... the filter for the CampaignAddresses we want to count
     *   }
     * })
    **/
    count<T extends CampaignAddressCountArgs>(
      args?: Subset<T, CampaignAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAddressAggregateArgs>(args: Subset<T, CampaignAddressAggregateArgs>): Prisma.PrismaPromise<GetCampaignAddressAggregateType<T>>

    /**
     * Group by CampaignAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignAddressGroupByArgs['orderBy'] }
        : { orderBy?: CampaignAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignAddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign<T extends CampaignArgs= {}>(args?: Subset<T, CampaignArgs>): Prisma__CampaignClient<CampaignGetPayload<T> | Null>;

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignAddress base type for findUnique actions
   */
  export type CampaignAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * Filter, which CampaignAddress to fetch.
     */
    where: CampaignAddressWhereUniqueInput
  }

  /**
   * CampaignAddress findUnique
   */
  export interface CampaignAddressFindUniqueArgs extends CampaignAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignAddress findUniqueOrThrow
   */
  export type CampaignAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * Filter, which CampaignAddress to fetch.
     */
    where: CampaignAddressWhereUniqueInput
  }


  /**
   * CampaignAddress base type for findFirst actions
   */
  export type CampaignAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * Filter, which CampaignAddress to fetch.
     */
    where?: CampaignAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAddresses to fetch.
     */
    orderBy?: Enumerable<CampaignAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAddresses.
     */
    cursor?: CampaignAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAddresses.
     */
    distinct?: Enumerable<CampaignAddressScalarFieldEnum>
  }

  /**
   * CampaignAddress findFirst
   */
  export interface CampaignAddressFindFirstArgs extends CampaignAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignAddress findFirstOrThrow
   */
  export type CampaignAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * Filter, which CampaignAddress to fetch.
     */
    where?: CampaignAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAddresses to fetch.
     */
    orderBy?: Enumerable<CampaignAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAddresses.
     */
    cursor?: CampaignAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAddresses.
     */
    distinct?: Enumerable<CampaignAddressScalarFieldEnum>
  }


  /**
   * CampaignAddress findMany
   */
  export type CampaignAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * Filter, which CampaignAddresses to fetch.
     */
    where?: CampaignAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAddresses to fetch.
     */
    orderBy?: Enumerable<CampaignAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignAddresses.
     */
    cursor?: CampaignAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAddresses.
     */
    skip?: number
    distinct?: Enumerable<CampaignAddressScalarFieldEnum>
  }


  /**
   * CampaignAddress create
   */
  export type CampaignAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * The data needed to create a CampaignAddress.
     */
    data: XOR<CampaignAddressCreateInput, CampaignAddressUncheckedCreateInput>
  }


  /**
   * CampaignAddress createMany
   */
  export type CampaignAddressCreateManyArgs = {
    /**
     * The data used to create many CampaignAddresses.
     */
    data: Enumerable<CampaignAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignAddress update
   */
  export type CampaignAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * The data needed to update a CampaignAddress.
     */
    data: XOR<CampaignAddressUpdateInput, CampaignAddressUncheckedUpdateInput>
    /**
     * Choose, which CampaignAddress to update.
     */
    where: CampaignAddressWhereUniqueInput
  }


  /**
   * CampaignAddress updateMany
   */
  export type CampaignAddressUpdateManyArgs = {
    /**
     * The data used to update CampaignAddresses.
     */
    data: XOR<CampaignAddressUpdateManyMutationInput, CampaignAddressUncheckedUpdateManyInput>
    /**
     * Filter which CampaignAddresses to update
     */
    where?: CampaignAddressWhereInput
  }


  /**
   * CampaignAddress upsert
   */
  export type CampaignAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * The filter to search for the CampaignAddress to update in case it exists.
     */
    where: CampaignAddressWhereUniqueInput
    /**
     * In case the CampaignAddress found by the `where` argument doesn't exist, create a new CampaignAddress with this data.
     */
    create: XOR<CampaignAddressCreateInput, CampaignAddressUncheckedCreateInput>
    /**
     * In case the CampaignAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignAddressUpdateInput, CampaignAddressUncheckedUpdateInput>
  }


  /**
   * CampaignAddress delete
   */
  export type CampaignAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
    /**
     * Filter which CampaignAddress to delete.
     */
    where: CampaignAddressWhereUniqueInput
  }


  /**
   * CampaignAddress deleteMany
   */
  export type CampaignAddressDeleteManyArgs = {
    /**
     * Filter which CampaignAddresses to delete
     */
    where?: CampaignAddressWhereInput
  }


  /**
   * CampaignAddress without action
   */
  export type CampaignAddressArgs = {
    /**
     * Select specific fields to fetch from the CampaignAddress
     */
    select?: CampaignAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignAddressInclude | null
  }



  /**
   * Model CampaignCauses
   */


  export type AggregateCampaignCauses = {
    _count: CampaignCausesCountAggregateOutputType | null
    _min: CampaignCausesMinAggregateOutputType | null
    _max: CampaignCausesMaxAggregateOutputType | null
  }

  export type CampaignCausesMinAggregateOutputType = {
    id: string | null
    id_cause: string | null
    id_campaign: string | null
  }

  export type CampaignCausesMaxAggregateOutputType = {
    id: string | null
    id_cause: string | null
    id_campaign: string | null
  }

  export type CampaignCausesCountAggregateOutputType = {
    id: number
    id_cause: number
    id_campaign: number
    _all: number
  }


  export type CampaignCausesMinAggregateInputType = {
    id?: true
    id_cause?: true
    id_campaign?: true
  }

  export type CampaignCausesMaxAggregateInputType = {
    id?: true
    id_cause?: true
    id_campaign?: true
  }

  export type CampaignCausesCountAggregateInputType = {
    id?: true
    id_cause?: true
    id_campaign?: true
    _all?: true
  }

  export type CampaignCausesAggregateArgs = {
    /**
     * Filter which CampaignCauses to aggregate.
     */
    where?: CampaignCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignCauses to fetch.
     */
    orderBy?: Enumerable<CampaignCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignCauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignCauses
    **/
    _count?: true | CampaignCausesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignCausesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignCausesMaxAggregateInputType
  }

  export type GetCampaignCausesAggregateType<T extends CampaignCausesAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignCauses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignCauses[P]>
      : GetScalarType<T[P], AggregateCampaignCauses[P]>
  }




  export type CampaignCausesGroupByArgs = {
    where?: CampaignCausesWhereInput
    orderBy?: Enumerable<CampaignCausesOrderByWithAggregationInput>
    by: CampaignCausesScalarFieldEnum[]
    having?: CampaignCausesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCausesCountAggregateInputType | true
    _min?: CampaignCausesMinAggregateInputType
    _max?: CampaignCausesMaxAggregateInputType
  }


  export type CampaignCausesGroupByOutputType = {
    id: string
    id_cause: string
    id_campaign: string
    _count: CampaignCausesCountAggregateOutputType | null
    _min: CampaignCausesMinAggregateOutputType | null
    _max: CampaignCausesMaxAggregateOutputType | null
  }

  type GetCampaignCausesGroupByPayload<T extends CampaignCausesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CampaignCausesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignCausesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignCausesGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignCausesGroupByOutputType[P]>
        }
      >
    >


  export type CampaignCausesSelect = {
    id?: boolean
    id_cause?: boolean
    id_campaign?: boolean
    campaign?: boolean | CampaignArgs
    causes?: boolean | CausesArgs
  }


  export type CampaignCausesInclude = {
    campaign?: boolean | CampaignArgs
    causes?: boolean | CausesArgs
  }

  export type CampaignCausesGetPayload<S extends boolean | null | undefined | CampaignCausesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CampaignCauses :
    S extends undefined ? never :
    S extends { include: any } & (CampaignCausesArgs | CampaignCausesFindManyArgs)
    ? CampaignCauses  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign' ? CampaignGetPayload<S['include'][P]> :
        P extends 'causes' ? CausesGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CampaignCausesArgs | CampaignCausesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign' ? CampaignGetPayload<S['select'][P]> :
        P extends 'causes' ? CausesGetPayload<S['select'][P]> :  P extends keyof CampaignCauses ? CampaignCauses[P] : never
  } 
      : CampaignCauses


  type CampaignCausesCountArgs = 
    Omit<CampaignCausesFindManyArgs, 'select' | 'include'> & {
      select?: CampaignCausesCountAggregateInputType | true
    }

  export interface CampaignCausesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CampaignCauses that matches the filter.
     * @param {CampaignCausesFindUniqueArgs} args - Arguments to find a CampaignCauses
     * @example
     * // Get one CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignCausesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignCausesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignCauses'> extends True ? Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>> : Prisma__CampaignCausesClient<CampaignCausesGetPayload<T> | null, null>

    /**
     * Find one CampaignCauses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignCausesFindUniqueOrThrowArgs} args - Arguments to find a CampaignCauses
     * @example
     * // Get one CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignCausesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignCausesFindUniqueOrThrowArgs>
    ): Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>>

    /**
     * Find the first CampaignCauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesFindFirstArgs} args - Arguments to find a CampaignCauses
     * @example
     * // Get one CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignCausesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignCausesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignCauses'> extends True ? Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>> : Prisma__CampaignCausesClient<CampaignCausesGetPayload<T> | null, null>

    /**
     * Find the first CampaignCauses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesFindFirstOrThrowArgs} args - Arguments to find a CampaignCauses
     * @example
     * // Get one CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignCausesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignCausesFindFirstOrThrowArgs>
    ): Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>>

    /**
     * Find zero or more CampaignCauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.findMany()
     * 
     * // Get first 10 CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignCausesWithIdOnly = await prisma.campaignCauses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignCausesFindManyArgs>(
      args?: SelectSubset<T, CampaignCausesFindManyArgs>
    ): Prisma.PrismaPromise<Array<CampaignCausesGetPayload<T>>>

    /**
     * Create a CampaignCauses.
     * @param {CampaignCausesCreateArgs} args - Arguments to create a CampaignCauses.
     * @example
     * // Create one CampaignCauses
     * const CampaignCauses = await prisma.campaignCauses.create({
     *   data: {
     *     // ... data to create a CampaignCauses
     *   }
     * })
     * 
    **/
    create<T extends CampaignCausesCreateArgs>(
      args: SelectSubset<T, CampaignCausesCreateArgs>
    ): Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>>

    /**
     * Create many CampaignCauses.
     *     @param {CampaignCausesCreateManyArgs} args - Arguments to create many CampaignCauses.
     *     @example
     *     // Create many CampaignCauses
     *     const campaignCauses = await prisma.campaignCauses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCausesCreateManyArgs>(
      args?: SelectSubset<T, CampaignCausesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignCauses.
     * @param {CampaignCausesDeleteArgs} args - Arguments to delete one CampaignCauses.
     * @example
     * // Delete one CampaignCauses
     * const CampaignCauses = await prisma.campaignCauses.delete({
     *   where: {
     *     // ... filter to delete one CampaignCauses
     *   }
     * })
     * 
    **/
    delete<T extends CampaignCausesDeleteArgs>(
      args: SelectSubset<T, CampaignCausesDeleteArgs>
    ): Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>>

    /**
     * Update one CampaignCauses.
     * @param {CampaignCausesUpdateArgs} args - Arguments to update one CampaignCauses.
     * @example
     * // Update one CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignCausesUpdateArgs>(
      args: SelectSubset<T, CampaignCausesUpdateArgs>
    ): Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>>

    /**
     * Delete zero or more CampaignCauses.
     * @param {CampaignCausesDeleteManyArgs} args - Arguments to filter CampaignCauses to delete.
     * @example
     * // Delete a few CampaignCauses
     * const { count } = await prisma.campaignCauses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignCausesDeleteManyArgs>(
      args?: SelectSubset<T, CampaignCausesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignCausesUpdateManyArgs>(
      args: SelectSubset<T, CampaignCausesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignCauses.
     * @param {CampaignCausesUpsertArgs} args - Arguments to update or create a CampaignCauses.
     * @example
     * // Update or create a CampaignCauses
     * const campaignCauses = await prisma.campaignCauses.upsert({
     *   create: {
     *     // ... data to create a CampaignCauses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignCauses we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignCausesUpsertArgs>(
      args: SelectSubset<T, CampaignCausesUpsertArgs>
    ): Prisma__CampaignCausesClient<CampaignCausesGetPayload<T>>

    /**
     * Count the number of CampaignCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesCountArgs} args - Arguments to filter CampaignCauses to count.
     * @example
     * // Count the number of CampaignCauses
     * const count = await prisma.campaignCauses.count({
     *   where: {
     *     // ... the filter for the CampaignCauses we want to count
     *   }
     * })
    **/
    count<T extends CampaignCausesCountArgs>(
      args?: Subset<T, CampaignCausesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCausesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignCausesAggregateArgs>(args: Subset<T, CampaignCausesAggregateArgs>): Prisma.PrismaPromise<GetCampaignCausesAggregateType<T>>

    /**
     * Group by CampaignCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCausesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignCausesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignCausesGroupByArgs['orderBy'] }
        : { orderBy?: CampaignCausesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignCausesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignCausesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignCauses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignCausesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign<T extends CampaignArgs= {}>(args?: Subset<T, CampaignArgs>): Prisma__CampaignClient<CampaignGetPayload<T> | Null>;

    causes<T extends CausesArgs= {}>(args?: Subset<T, CausesArgs>): Prisma__CausesClient<CausesGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignCauses base type for findUnique actions
   */
  export type CampaignCausesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * Filter, which CampaignCauses to fetch.
     */
    where: CampaignCausesWhereUniqueInput
  }

  /**
   * CampaignCauses findUnique
   */
  export interface CampaignCausesFindUniqueArgs extends CampaignCausesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignCauses findUniqueOrThrow
   */
  export type CampaignCausesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * Filter, which CampaignCauses to fetch.
     */
    where: CampaignCausesWhereUniqueInput
  }


  /**
   * CampaignCauses base type for findFirst actions
   */
  export type CampaignCausesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * Filter, which CampaignCauses to fetch.
     */
    where?: CampaignCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignCauses to fetch.
     */
    orderBy?: Enumerable<CampaignCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignCauses.
     */
    cursor?: CampaignCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignCauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignCauses.
     */
    distinct?: Enumerable<CampaignCausesScalarFieldEnum>
  }

  /**
   * CampaignCauses findFirst
   */
  export interface CampaignCausesFindFirstArgs extends CampaignCausesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignCauses findFirstOrThrow
   */
  export type CampaignCausesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * Filter, which CampaignCauses to fetch.
     */
    where?: CampaignCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignCauses to fetch.
     */
    orderBy?: Enumerable<CampaignCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignCauses.
     */
    cursor?: CampaignCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignCauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignCauses.
     */
    distinct?: Enumerable<CampaignCausesScalarFieldEnum>
  }


  /**
   * CampaignCauses findMany
   */
  export type CampaignCausesFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * Filter, which CampaignCauses to fetch.
     */
    where?: CampaignCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignCauses to fetch.
     */
    orderBy?: Enumerable<CampaignCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignCauses.
     */
    cursor?: CampaignCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignCauses.
     */
    skip?: number
    distinct?: Enumerable<CampaignCausesScalarFieldEnum>
  }


  /**
   * CampaignCauses create
   */
  export type CampaignCausesCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * The data needed to create a CampaignCauses.
     */
    data: XOR<CampaignCausesCreateInput, CampaignCausesUncheckedCreateInput>
  }


  /**
   * CampaignCauses createMany
   */
  export type CampaignCausesCreateManyArgs = {
    /**
     * The data used to create many CampaignCauses.
     */
    data: Enumerable<CampaignCausesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignCauses update
   */
  export type CampaignCausesUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * The data needed to update a CampaignCauses.
     */
    data: XOR<CampaignCausesUpdateInput, CampaignCausesUncheckedUpdateInput>
    /**
     * Choose, which CampaignCauses to update.
     */
    where: CampaignCausesWhereUniqueInput
  }


  /**
   * CampaignCauses updateMany
   */
  export type CampaignCausesUpdateManyArgs = {
    /**
     * The data used to update CampaignCauses.
     */
    data: XOR<CampaignCausesUpdateManyMutationInput, CampaignCausesUncheckedUpdateManyInput>
    /**
     * Filter which CampaignCauses to update
     */
    where?: CampaignCausesWhereInput
  }


  /**
   * CampaignCauses upsert
   */
  export type CampaignCausesUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * The filter to search for the CampaignCauses to update in case it exists.
     */
    where: CampaignCausesWhereUniqueInput
    /**
     * In case the CampaignCauses found by the `where` argument doesn't exist, create a new CampaignCauses with this data.
     */
    create: XOR<CampaignCausesCreateInput, CampaignCausesUncheckedCreateInput>
    /**
     * In case the CampaignCauses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignCausesUpdateInput, CampaignCausesUncheckedUpdateInput>
  }


  /**
   * CampaignCauses delete
   */
  export type CampaignCausesDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    /**
     * Filter which CampaignCauses to delete.
     */
    where: CampaignCausesWhereUniqueInput
  }


  /**
   * CampaignCauses deleteMany
   */
  export type CampaignCausesDeleteManyArgs = {
    /**
     * Filter which CampaignCauses to delete
     */
    where?: CampaignCausesWhereInput
  }


  /**
   * CampaignCauses without action
   */
  export type CampaignCausesArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
  }



  /**
   * Model CampaignParticipants
   */


  export type AggregateCampaignParticipants = {
    _count: CampaignParticipantsCountAggregateOutputType | null
    _min: CampaignParticipantsMinAggregateOutputType | null
    _max: CampaignParticipantsMaxAggregateOutputType | null
  }

  export type CampaignParticipantsMinAggregateOutputType = {
    id: string | null
    id_campaign: string | null
    id_user: string | null
    id_status: string | null
  }

  export type CampaignParticipantsMaxAggregateOutputType = {
    id: string | null
    id_campaign: string | null
    id_user: string | null
    id_status: string | null
  }

  export type CampaignParticipantsCountAggregateOutputType = {
    id: number
    id_campaign: number
    id_user: number
    id_status: number
    _all: number
  }


  export type CampaignParticipantsMinAggregateInputType = {
    id?: true
    id_campaign?: true
    id_user?: true
    id_status?: true
  }

  export type CampaignParticipantsMaxAggregateInputType = {
    id?: true
    id_campaign?: true
    id_user?: true
    id_status?: true
  }

  export type CampaignParticipantsCountAggregateInputType = {
    id?: true
    id_campaign?: true
    id_user?: true
    id_status?: true
    _all?: true
  }

  export type CampaignParticipantsAggregateArgs = {
    /**
     * Filter which CampaignParticipants to aggregate.
     */
    where?: CampaignParticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipants to fetch.
     */
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignParticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignParticipants
    **/
    _count?: true | CampaignParticipantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignParticipantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignParticipantsMaxAggregateInputType
  }

  export type GetCampaignParticipantsAggregateType<T extends CampaignParticipantsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignParticipants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignParticipants[P]>
      : GetScalarType<T[P], AggregateCampaignParticipants[P]>
  }




  export type CampaignParticipantsGroupByArgs = {
    where?: CampaignParticipantsWhereInput
    orderBy?: Enumerable<CampaignParticipantsOrderByWithAggregationInput>
    by: CampaignParticipantsScalarFieldEnum[]
    having?: CampaignParticipantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignParticipantsCountAggregateInputType | true
    _min?: CampaignParticipantsMinAggregateInputType
    _max?: CampaignParticipantsMaxAggregateInputType
  }


  export type CampaignParticipantsGroupByOutputType = {
    id: string
    id_campaign: string
    id_user: string
    id_status: string
    _count: CampaignParticipantsCountAggregateOutputType | null
    _min: CampaignParticipantsMinAggregateOutputType | null
    _max: CampaignParticipantsMaxAggregateOutputType | null
  }

  type GetCampaignParticipantsGroupByPayload<T extends CampaignParticipantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CampaignParticipantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignParticipantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignParticipantsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignParticipantsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignParticipantsSelect = {
    id?: boolean
    id_campaign?: boolean
    id_user?: boolean
    id_status?: boolean
    campaign?: boolean | CampaignArgs
    user?: boolean | UserArgs
    status?: boolean | StatusArgs
  }


  export type CampaignParticipantsInclude = {
    campaign?: boolean | CampaignArgs
    user?: boolean | UserArgs
    status?: boolean | StatusArgs
  }

  export type CampaignParticipantsGetPayload<S extends boolean | null | undefined | CampaignParticipantsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CampaignParticipants :
    S extends undefined ? never :
    S extends { include: any } & (CampaignParticipantsArgs | CampaignParticipantsFindManyArgs)
    ? CampaignParticipants  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign' ? CampaignGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :
        P extends 'status' ? StatusGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CampaignParticipantsArgs | CampaignParticipantsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign' ? CampaignGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :
        P extends 'status' ? StatusGetPayload<S['select'][P]> :  P extends keyof CampaignParticipants ? CampaignParticipants[P] : never
  } 
      : CampaignParticipants


  type CampaignParticipantsCountArgs = 
    Omit<CampaignParticipantsFindManyArgs, 'select' | 'include'> & {
      select?: CampaignParticipantsCountAggregateInputType | true
    }

  export interface CampaignParticipantsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CampaignParticipants that matches the filter.
     * @param {CampaignParticipantsFindUniqueArgs} args - Arguments to find a CampaignParticipants
     * @example
     * // Get one CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignParticipantsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignParticipantsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignParticipants'> extends True ? Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>> : Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T> | null, null>

    /**
     * Find one CampaignParticipants that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignParticipantsFindUniqueOrThrowArgs} args - Arguments to find a CampaignParticipants
     * @example
     * // Get one CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignParticipantsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignParticipantsFindUniqueOrThrowArgs>
    ): Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>>

    /**
     * Find the first CampaignParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsFindFirstArgs} args - Arguments to find a CampaignParticipants
     * @example
     * // Get one CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignParticipantsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignParticipantsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignParticipants'> extends True ? Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>> : Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T> | null, null>

    /**
     * Find the first CampaignParticipants that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsFindFirstOrThrowArgs} args - Arguments to find a CampaignParticipants
     * @example
     * // Get one CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignParticipantsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignParticipantsFindFirstOrThrowArgs>
    ): Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>>

    /**
     * Find zero or more CampaignParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.findMany()
     * 
     * // Get first 10 CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignParticipantsWithIdOnly = await prisma.campaignParticipants.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignParticipantsFindManyArgs>(
      args?: SelectSubset<T, CampaignParticipantsFindManyArgs>
    ): Prisma.PrismaPromise<Array<CampaignParticipantsGetPayload<T>>>

    /**
     * Create a CampaignParticipants.
     * @param {CampaignParticipantsCreateArgs} args - Arguments to create a CampaignParticipants.
     * @example
     * // Create one CampaignParticipants
     * const CampaignParticipants = await prisma.campaignParticipants.create({
     *   data: {
     *     // ... data to create a CampaignParticipants
     *   }
     * })
     * 
    **/
    create<T extends CampaignParticipantsCreateArgs>(
      args: SelectSubset<T, CampaignParticipantsCreateArgs>
    ): Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>>

    /**
     * Create many CampaignParticipants.
     *     @param {CampaignParticipantsCreateManyArgs} args - Arguments to create many CampaignParticipants.
     *     @example
     *     // Create many CampaignParticipants
     *     const campaignParticipants = await prisma.campaignParticipants.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignParticipantsCreateManyArgs>(
      args?: SelectSubset<T, CampaignParticipantsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignParticipants.
     * @param {CampaignParticipantsDeleteArgs} args - Arguments to delete one CampaignParticipants.
     * @example
     * // Delete one CampaignParticipants
     * const CampaignParticipants = await prisma.campaignParticipants.delete({
     *   where: {
     *     // ... filter to delete one CampaignParticipants
     *   }
     * })
     * 
    **/
    delete<T extends CampaignParticipantsDeleteArgs>(
      args: SelectSubset<T, CampaignParticipantsDeleteArgs>
    ): Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>>

    /**
     * Update one CampaignParticipants.
     * @param {CampaignParticipantsUpdateArgs} args - Arguments to update one CampaignParticipants.
     * @example
     * // Update one CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignParticipantsUpdateArgs>(
      args: SelectSubset<T, CampaignParticipantsUpdateArgs>
    ): Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>>

    /**
     * Delete zero or more CampaignParticipants.
     * @param {CampaignParticipantsDeleteManyArgs} args - Arguments to filter CampaignParticipants to delete.
     * @example
     * // Delete a few CampaignParticipants
     * const { count } = await prisma.campaignParticipants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignParticipantsDeleteManyArgs>(
      args?: SelectSubset<T, CampaignParticipantsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignParticipantsUpdateManyArgs>(
      args: SelectSubset<T, CampaignParticipantsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignParticipants.
     * @param {CampaignParticipantsUpsertArgs} args - Arguments to update or create a CampaignParticipants.
     * @example
     * // Update or create a CampaignParticipants
     * const campaignParticipants = await prisma.campaignParticipants.upsert({
     *   create: {
     *     // ... data to create a CampaignParticipants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignParticipants we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignParticipantsUpsertArgs>(
      args: SelectSubset<T, CampaignParticipantsUpsertArgs>
    ): Prisma__CampaignParticipantsClient<CampaignParticipantsGetPayload<T>>

    /**
     * Count the number of CampaignParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsCountArgs} args - Arguments to filter CampaignParticipants to count.
     * @example
     * // Count the number of CampaignParticipants
     * const count = await prisma.campaignParticipants.count({
     *   where: {
     *     // ... the filter for the CampaignParticipants we want to count
     *   }
     * })
    **/
    count<T extends CampaignParticipantsCountArgs>(
      args?: Subset<T, CampaignParticipantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignParticipantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignParticipantsAggregateArgs>(args: Subset<T, CampaignParticipantsAggregateArgs>): Prisma.PrismaPromise<GetCampaignParticipantsAggregateType<T>>

    /**
     * Group by CampaignParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignParticipantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignParticipantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignParticipantsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignParticipantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignParticipantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignParticipantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignParticipants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignParticipantsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign<T extends CampaignArgs= {}>(args?: Subset<T, CampaignArgs>): Prisma__CampaignClient<CampaignGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    status<T extends StatusArgs= {}>(args?: Subset<T, StatusArgs>): Prisma__StatusClient<StatusGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignParticipants base type for findUnique actions
   */
  export type CampaignParticipantsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * Filter, which CampaignParticipants to fetch.
     */
    where: CampaignParticipantsWhereUniqueInput
  }

  /**
   * CampaignParticipants findUnique
   */
  export interface CampaignParticipantsFindUniqueArgs extends CampaignParticipantsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignParticipants findUniqueOrThrow
   */
  export type CampaignParticipantsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * Filter, which CampaignParticipants to fetch.
     */
    where: CampaignParticipantsWhereUniqueInput
  }


  /**
   * CampaignParticipants base type for findFirst actions
   */
  export type CampaignParticipantsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * Filter, which CampaignParticipants to fetch.
     */
    where?: CampaignParticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipants to fetch.
     */
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignParticipants.
     */
    cursor?: CampaignParticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignParticipants.
     */
    distinct?: Enumerable<CampaignParticipantsScalarFieldEnum>
  }

  /**
   * CampaignParticipants findFirst
   */
  export interface CampaignParticipantsFindFirstArgs extends CampaignParticipantsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignParticipants findFirstOrThrow
   */
  export type CampaignParticipantsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * Filter, which CampaignParticipants to fetch.
     */
    where?: CampaignParticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipants to fetch.
     */
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignParticipants.
     */
    cursor?: CampaignParticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignParticipants.
     */
    distinct?: Enumerable<CampaignParticipantsScalarFieldEnum>
  }


  /**
   * CampaignParticipants findMany
   */
  export type CampaignParticipantsFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * Filter, which CampaignParticipants to fetch.
     */
    where?: CampaignParticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignParticipants to fetch.
     */
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignParticipants.
     */
    cursor?: CampaignParticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignParticipants.
     */
    skip?: number
    distinct?: Enumerable<CampaignParticipantsScalarFieldEnum>
  }


  /**
   * CampaignParticipants create
   */
  export type CampaignParticipantsCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * The data needed to create a CampaignParticipants.
     */
    data: XOR<CampaignParticipantsCreateInput, CampaignParticipantsUncheckedCreateInput>
  }


  /**
   * CampaignParticipants createMany
   */
  export type CampaignParticipantsCreateManyArgs = {
    /**
     * The data used to create many CampaignParticipants.
     */
    data: Enumerable<CampaignParticipantsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignParticipants update
   */
  export type CampaignParticipantsUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * The data needed to update a CampaignParticipants.
     */
    data: XOR<CampaignParticipantsUpdateInput, CampaignParticipantsUncheckedUpdateInput>
    /**
     * Choose, which CampaignParticipants to update.
     */
    where: CampaignParticipantsWhereUniqueInput
  }


  /**
   * CampaignParticipants updateMany
   */
  export type CampaignParticipantsUpdateManyArgs = {
    /**
     * The data used to update CampaignParticipants.
     */
    data: XOR<CampaignParticipantsUpdateManyMutationInput, CampaignParticipantsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignParticipants to update
     */
    where?: CampaignParticipantsWhereInput
  }


  /**
   * CampaignParticipants upsert
   */
  export type CampaignParticipantsUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * The filter to search for the CampaignParticipants to update in case it exists.
     */
    where: CampaignParticipantsWhereUniqueInput
    /**
     * In case the CampaignParticipants found by the `where` argument doesn't exist, create a new CampaignParticipants with this data.
     */
    create: XOR<CampaignParticipantsCreateInput, CampaignParticipantsUncheckedCreateInput>
    /**
     * In case the CampaignParticipants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignParticipantsUpdateInput, CampaignParticipantsUncheckedUpdateInput>
  }


  /**
   * CampaignParticipants delete
   */
  export type CampaignParticipantsDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    /**
     * Filter which CampaignParticipants to delete.
     */
    where: CampaignParticipantsWhereUniqueInput
  }


  /**
   * CampaignParticipants deleteMany
   */
  export type CampaignParticipantsDeleteManyArgs = {
    /**
     * Filter which CampaignParticipants to delete
     */
    where?: CampaignParticipantsWhereInput
  }


  /**
   * CampaignParticipants without action
   */
  export type CampaignParticipantsArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
  }



  /**
   * Model CampaignPhotos
   */


  export type AggregateCampaignPhotos = {
    _count: CampaignPhotosCountAggregateOutputType | null
    _min: CampaignPhotosMinAggregateOutputType | null
    _max: CampaignPhotosMaxAggregateOutputType | null
  }

  export type CampaignPhotosMinAggregateOutputType = {
    id: string | null
    photo_url: string | null
    id_campaign: string | null
  }

  export type CampaignPhotosMaxAggregateOutputType = {
    id: string | null
    photo_url: string | null
    id_campaign: string | null
  }

  export type CampaignPhotosCountAggregateOutputType = {
    id: number
    photo_url: number
    id_campaign: number
    _all: number
  }


  export type CampaignPhotosMinAggregateInputType = {
    id?: true
    photo_url?: true
    id_campaign?: true
  }

  export type CampaignPhotosMaxAggregateInputType = {
    id?: true
    photo_url?: true
    id_campaign?: true
  }

  export type CampaignPhotosCountAggregateInputType = {
    id?: true
    photo_url?: true
    id_campaign?: true
    _all?: true
  }

  export type CampaignPhotosAggregateArgs = {
    /**
     * Filter which CampaignPhotos to aggregate.
     */
    where?: CampaignPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPhotos to fetch.
     */
    orderBy?: Enumerable<CampaignPhotosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignPhotos
    **/
    _count?: true | CampaignPhotosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignPhotosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignPhotosMaxAggregateInputType
  }

  export type GetCampaignPhotosAggregateType<T extends CampaignPhotosAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignPhotos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignPhotos[P]>
      : GetScalarType<T[P], AggregateCampaignPhotos[P]>
  }




  export type CampaignPhotosGroupByArgs = {
    where?: CampaignPhotosWhereInput
    orderBy?: Enumerable<CampaignPhotosOrderByWithAggregationInput>
    by: CampaignPhotosScalarFieldEnum[]
    having?: CampaignPhotosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignPhotosCountAggregateInputType | true
    _min?: CampaignPhotosMinAggregateInputType
    _max?: CampaignPhotosMaxAggregateInputType
  }


  export type CampaignPhotosGroupByOutputType = {
    id: string
    photo_url: string
    id_campaign: string
    _count: CampaignPhotosCountAggregateOutputType | null
    _min: CampaignPhotosMinAggregateOutputType | null
    _max: CampaignPhotosMaxAggregateOutputType | null
  }

  type GetCampaignPhotosGroupByPayload<T extends CampaignPhotosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CampaignPhotosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignPhotosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignPhotosGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignPhotosGroupByOutputType[P]>
        }
      >
    >


  export type CampaignPhotosSelect = {
    id?: boolean
    photo_url?: boolean
    id_campaign?: boolean
    campaign?: boolean | CampaignArgs
  }


  export type CampaignPhotosInclude = {
    campaign?: boolean | CampaignArgs
  }

  export type CampaignPhotosGetPayload<S extends boolean | null | undefined | CampaignPhotosArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CampaignPhotos :
    S extends undefined ? never :
    S extends { include: any } & (CampaignPhotosArgs | CampaignPhotosFindManyArgs)
    ? CampaignPhotos  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign' ? CampaignGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CampaignPhotosArgs | CampaignPhotosFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign' ? CampaignGetPayload<S['select'][P]> :  P extends keyof CampaignPhotos ? CampaignPhotos[P] : never
  } 
      : CampaignPhotos


  type CampaignPhotosCountArgs = 
    Omit<CampaignPhotosFindManyArgs, 'select' | 'include'> & {
      select?: CampaignPhotosCountAggregateInputType | true
    }

  export interface CampaignPhotosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CampaignPhotos that matches the filter.
     * @param {CampaignPhotosFindUniqueArgs} args - Arguments to find a CampaignPhotos
     * @example
     * // Get one CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignPhotosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CampaignPhotosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CampaignPhotos'> extends True ? Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>> : Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T> | null, null>

    /**
     * Find one CampaignPhotos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignPhotosFindUniqueOrThrowArgs} args - Arguments to find a CampaignPhotos
     * @example
     * // Get one CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignPhotosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CampaignPhotosFindUniqueOrThrowArgs>
    ): Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>>

    /**
     * Find the first CampaignPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosFindFirstArgs} args - Arguments to find a CampaignPhotos
     * @example
     * // Get one CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignPhotosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CampaignPhotosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CampaignPhotos'> extends True ? Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>> : Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T> | null, null>

    /**
     * Find the first CampaignPhotos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosFindFirstOrThrowArgs} args - Arguments to find a CampaignPhotos
     * @example
     * // Get one CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignPhotosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CampaignPhotosFindFirstOrThrowArgs>
    ): Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>>

    /**
     * Find zero or more CampaignPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.findMany()
     * 
     * // Get first 10 CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignPhotosWithIdOnly = await prisma.campaignPhotos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignPhotosFindManyArgs>(
      args?: SelectSubset<T, CampaignPhotosFindManyArgs>
    ): Prisma.PrismaPromise<Array<CampaignPhotosGetPayload<T>>>

    /**
     * Create a CampaignPhotos.
     * @param {CampaignPhotosCreateArgs} args - Arguments to create a CampaignPhotos.
     * @example
     * // Create one CampaignPhotos
     * const CampaignPhotos = await prisma.campaignPhotos.create({
     *   data: {
     *     // ... data to create a CampaignPhotos
     *   }
     * })
     * 
    **/
    create<T extends CampaignPhotosCreateArgs>(
      args: SelectSubset<T, CampaignPhotosCreateArgs>
    ): Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>>

    /**
     * Create many CampaignPhotos.
     *     @param {CampaignPhotosCreateManyArgs} args - Arguments to create many CampaignPhotos.
     *     @example
     *     // Create many CampaignPhotos
     *     const campaignPhotos = await prisma.campaignPhotos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignPhotosCreateManyArgs>(
      args?: SelectSubset<T, CampaignPhotosCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CampaignPhotos.
     * @param {CampaignPhotosDeleteArgs} args - Arguments to delete one CampaignPhotos.
     * @example
     * // Delete one CampaignPhotos
     * const CampaignPhotos = await prisma.campaignPhotos.delete({
     *   where: {
     *     // ... filter to delete one CampaignPhotos
     *   }
     * })
     * 
    **/
    delete<T extends CampaignPhotosDeleteArgs>(
      args: SelectSubset<T, CampaignPhotosDeleteArgs>
    ): Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>>

    /**
     * Update one CampaignPhotos.
     * @param {CampaignPhotosUpdateArgs} args - Arguments to update one CampaignPhotos.
     * @example
     * // Update one CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignPhotosUpdateArgs>(
      args: SelectSubset<T, CampaignPhotosUpdateArgs>
    ): Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>>

    /**
     * Delete zero or more CampaignPhotos.
     * @param {CampaignPhotosDeleteManyArgs} args - Arguments to filter CampaignPhotos to delete.
     * @example
     * // Delete a few CampaignPhotos
     * const { count } = await prisma.campaignPhotos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignPhotosDeleteManyArgs>(
      args?: SelectSubset<T, CampaignPhotosDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignPhotosUpdateManyArgs>(
      args: SelectSubset<T, CampaignPhotosUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignPhotos.
     * @param {CampaignPhotosUpsertArgs} args - Arguments to update or create a CampaignPhotos.
     * @example
     * // Update or create a CampaignPhotos
     * const campaignPhotos = await prisma.campaignPhotos.upsert({
     *   create: {
     *     // ... data to create a CampaignPhotos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignPhotos we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignPhotosUpsertArgs>(
      args: SelectSubset<T, CampaignPhotosUpsertArgs>
    ): Prisma__CampaignPhotosClient<CampaignPhotosGetPayload<T>>

    /**
     * Count the number of CampaignPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosCountArgs} args - Arguments to filter CampaignPhotos to count.
     * @example
     * // Count the number of CampaignPhotos
     * const count = await prisma.campaignPhotos.count({
     *   where: {
     *     // ... the filter for the CampaignPhotos we want to count
     *   }
     * })
    **/
    count<T extends CampaignPhotosCountArgs>(
      args?: Subset<T, CampaignPhotosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignPhotosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignPhotosAggregateArgs>(args: Subset<T, CampaignPhotosAggregateArgs>): Prisma.PrismaPromise<GetCampaignPhotosAggregateType<T>>

    /**
     * Group by CampaignPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignPhotosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignPhotosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignPhotosGroupByArgs['orderBy'] }
        : { orderBy?: CampaignPhotosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignPhotosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignPhotosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignPhotos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CampaignPhotosClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign<T extends CampaignArgs= {}>(args?: Subset<T, CampaignArgs>): Prisma__CampaignClient<CampaignGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CampaignPhotos base type for findUnique actions
   */
  export type CampaignPhotosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * Filter, which CampaignPhotos to fetch.
     */
    where: CampaignPhotosWhereUniqueInput
  }

  /**
   * CampaignPhotos findUnique
   */
  export interface CampaignPhotosFindUniqueArgs extends CampaignPhotosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignPhotos findUniqueOrThrow
   */
  export type CampaignPhotosFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * Filter, which CampaignPhotos to fetch.
     */
    where: CampaignPhotosWhereUniqueInput
  }


  /**
   * CampaignPhotos base type for findFirst actions
   */
  export type CampaignPhotosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * Filter, which CampaignPhotos to fetch.
     */
    where?: CampaignPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPhotos to fetch.
     */
    orderBy?: Enumerable<CampaignPhotosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignPhotos.
     */
    cursor?: CampaignPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignPhotos.
     */
    distinct?: Enumerable<CampaignPhotosScalarFieldEnum>
  }

  /**
   * CampaignPhotos findFirst
   */
  export interface CampaignPhotosFindFirstArgs extends CampaignPhotosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CampaignPhotos findFirstOrThrow
   */
  export type CampaignPhotosFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * Filter, which CampaignPhotos to fetch.
     */
    where?: CampaignPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPhotos to fetch.
     */
    orderBy?: Enumerable<CampaignPhotosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignPhotos.
     */
    cursor?: CampaignPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignPhotos.
     */
    distinct?: Enumerable<CampaignPhotosScalarFieldEnum>
  }


  /**
   * CampaignPhotos findMany
   */
  export type CampaignPhotosFindManyArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * Filter, which CampaignPhotos to fetch.
     */
    where?: CampaignPhotosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignPhotos to fetch.
     */
    orderBy?: Enumerable<CampaignPhotosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignPhotos.
     */
    cursor?: CampaignPhotosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignPhotos.
     */
    skip?: number
    distinct?: Enumerable<CampaignPhotosScalarFieldEnum>
  }


  /**
   * CampaignPhotos create
   */
  export type CampaignPhotosCreateArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * The data needed to create a CampaignPhotos.
     */
    data: XOR<CampaignPhotosCreateInput, CampaignPhotosUncheckedCreateInput>
  }


  /**
   * CampaignPhotos createMany
   */
  export type CampaignPhotosCreateManyArgs = {
    /**
     * The data used to create many CampaignPhotos.
     */
    data: Enumerable<CampaignPhotosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CampaignPhotos update
   */
  export type CampaignPhotosUpdateArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * The data needed to update a CampaignPhotos.
     */
    data: XOR<CampaignPhotosUpdateInput, CampaignPhotosUncheckedUpdateInput>
    /**
     * Choose, which CampaignPhotos to update.
     */
    where: CampaignPhotosWhereUniqueInput
  }


  /**
   * CampaignPhotos updateMany
   */
  export type CampaignPhotosUpdateManyArgs = {
    /**
     * The data used to update CampaignPhotos.
     */
    data: XOR<CampaignPhotosUpdateManyMutationInput, CampaignPhotosUncheckedUpdateManyInput>
    /**
     * Filter which CampaignPhotos to update
     */
    where?: CampaignPhotosWhereInput
  }


  /**
   * CampaignPhotos upsert
   */
  export type CampaignPhotosUpsertArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * The filter to search for the CampaignPhotos to update in case it exists.
     */
    where: CampaignPhotosWhereUniqueInput
    /**
     * In case the CampaignPhotos found by the `where` argument doesn't exist, create a new CampaignPhotos with this data.
     */
    create: XOR<CampaignPhotosCreateInput, CampaignPhotosUncheckedCreateInput>
    /**
     * In case the CampaignPhotos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignPhotosUpdateInput, CampaignPhotosUncheckedUpdateInput>
  }


  /**
   * CampaignPhotos delete
   */
  export type CampaignPhotosDeleteArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
    /**
     * Filter which CampaignPhotos to delete.
     */
    where: CampaignPhotosWhereUniqueInput
  }


  /**
   * CampaignPhotos deleteMany
   */
  export type CampaignPhotosDeleteManyArgs = {
    /**
     * Filter which CampaignPhotos to delete
     */
    where?: CampaignPhotosWhereInput
  }


  /**
   * CampaignPhotos without action
   */
  export type CampaignPhotosArgs = {
    /**
     * Select specific fields to fetch from the CampaignPhotos
     */
    select?: CampaignPhotosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignPhotosInclude | null
  }



  /**
   * Model Causes
   */


  export type AggregateCauses = {
    _count: CausesCountAggregateOutputType | null
    _min: CausesMinAggregateOutputType | null
    _max: CausesMaxAggregateOutputType | null
  }

  export type CausesMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
  }

  export type CausesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
  }

  export type CausesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    _all: number
  }


  export type CausesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
  }

  export type CausesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
  }

  export type CausesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    _all?: true
  }

  export type CausesAggregateArgs = {
    /**
     * Filter which Causes to aggregate.
     */
    where?: CausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Causes to fetch.
     */
    orderBy?: Enumerable<CausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Causes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Causes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Causes
    **/
    _count?: true | CausesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CausesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CausesMaxAggregateInputType
  }

  export type GetCausesAggregateType<T extends CausesAggregateArgs> = {
        [P in keyof T & keyof AggregateCauses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCauses[P]>
      : GetScalarType<T[P], AggregateCauses[P]>
  }




  export type CausesGroupByArgs = {
    where?: CausesWhereInput
    orderBy?: Enumerable<CausesOrderByWithAggregationInput>
    by: CausesScalarFieldEnum[]
    having?: CausesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CausesCountAggregateInputType | true
    _min?: CausesMinAggregateInputType
    _max?: CausesMaxAggregateInputType
  }


  export type CausesGroupByOutputType = {
    id: string
    title: string
    description: string | null
    _count: CausesCountAggregateOutputType | null
    _min: CausesMinAggregateOutputType | null
    _max: CausesMaxAggregateOutputType | null
  }

  type GetCausesGroupByPayload<T extends CausesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CausesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CausesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CausesGroupByOutputType[P]>
            : GetScalarType<T[P], CausesGroupByOutputType[P]>
        }
      >
    >


  export type CausesSelect = {
    id?: boolean
    title?: boolean
    description?: boolean
    campaign_causes?: boolean | Causes$campaign_causesArgs
    ngo_causes?: boolean | Causes$ngo_causesArgs
    _count?: boolean | CausesCountOutputTypeArgs
  }


  export type CausesInclude = {
    campaign_causes?: boolean | Causes$campaign_causesArgs
    ngo_causes?: boolean | Causes$ngo_causesArgs
    _count?: boolean | CausesCountOutputTypeArgs
  }

  export type CausesGetPayload<S extends boolean | null | undefined | CausesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Causes :
    S extends undefined ? never :
    S extends { include: any } & (CausesArgs | CausesFindManyArgs)
    ? Causes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign_causes' ? Array < CampaignCausesGetPayload<S['include'][P]>>  :
        P extends 'ngo_causes' ? Array < NgoCausesGetPayload<S['include'][P]>>  :
        P extends '_count' ? CausesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CausesArgs | CausesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign_causes' ? Array < CampaignCausesGetPayload<S['select'][P]>>  :
        P extends 'ngo_causes' ? Array < NgoCausesGetPayload<S['select'][P]>>  :
        P extends '_count' ? CausesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Causes ? Causes[P] : never
  } 
      : Causes


  type CausesCountArgs = 
    Omit<CausesFindManyArgs, 'select' | 'include'> & {
      select?: CausesCountAggregateInputType | true
    }

  export interface CausesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Causes that matches the filter.
     * @param {CausesFindUniqueArgs} args - Arguments to find a Causes
     * @example
     * // Get one Causes
     * const causes = await prisma.causes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CausesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CausesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Causes'> extends True ? Prisma__CausesClient<CausesGetPayload<T>> : Prisma__CausesClient<CausesGetPayload<T> | null, null>

    /**
     * Find one Causes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CausesFindUniqueOrThrowArgs} args - Arguments to find a Causes
     * @example
     * // Get one Causes
     * const causes = await prisma.causes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CausesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CausesFindUniqueOrThrowArgs>
    ): Prisma__CausesClient<CausesGetPayload<T>>

    /**
     * Find the first Causes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesFindFirstArgs} args - Arguments to find a Causes
     * @example
     * // Get one Causes
     * const causes = await prisma.causes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CausesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CausesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Causes'> extends True ? Prisma__CausesClient<CausesGetPayload<T>> : Prisma__CausesClient<CausesGetPayload<T> | null, null>

    /**
     * Find the first Causes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesFindFirstOrThrowArgs} args - Arguments to find a Causes
     * @example
     * // Get one Causes
     * const causes = await prisma.causes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CausesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CausesFindFirstOrThrowArgs>
    ): Prisma__CausesClient<CausesGetPayload<T>>

    /**
     * Find zero or more Causes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Causes
     * const causes = await prisma.causes.findMany()
     * 
     * // Get first 10 Causes
     * const causes = await prisma.causes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const causesWithIdOnly = await prisma.causes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CausesFindManyArgs>(
      args?: SelectSubset<T, CausesFindManyArgs>
    ): Prisma.PrismaPromise<Array<CausesGetPayload<T>>>

    /**
     * Create a Causes.
     * @param {CausesCreateArgs} args - Arguments to create a Causes.
     * @example
     * // Create one Causes
     * const Causes = await prisma.causes.create({
     *   data: {
     *     // ... data to create a Causes
     *   }
     * })
     * 
    **/
    create<T extends CausesCreateArgs>(
      args: SelectSubset<T, CausesCreateArgs>
    ): Prisma__CausesClient<CausesGetPayload<T>>

    /**
     * Create many Causes.
     *     @param {CausesCreateManyArgs} args - Arguments to create many Causes.
     *     @example
     *     // Create many Causes
     *     const causes = await prisma.causes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CausesCreateManyArgs>(
      args?: SelectSubset<T, CausesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Causes.
     * @param {CausesDeleteArgs} args - Arguments to delete one Causes.
     * @example
     * // Delete one Causes
     * const Causes = await prisma.causes.delete({
     *   where: {
     *     // ... filter to delete one Causes
     *   }
     * })
     * 
    **/
    delete<T extends CausesDeleteArgs>(
      args: SelectSubset<T, CausesDeleteArgs>
    ): Prisma__CausesClient<CausesGetPayload<T>>

    /**
     * Update one Causes.
     * @param {CausesUpdateArgs} args - Arguments to update one Causes.
     * @example
     * // Update one Causes
     * const causes = await prisma.causes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CausesUpdateArgs>(
      args: SelectSubset<T, CausesUpdateArgs>
    ): Prisma__CausesClient<CausesGetPayload<T>>

    /**
     * Delete zero or more Causes.
     * @param {CausesDeleteManyArgs} args - Arguments to filter Causes to delete.
     * @example
     * // Delete a few Causes
     * const { count } = await prisma.causes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CausesDeleteManyArgs>(
      args?: SelectSubset<T, CausesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Causes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Causes
     * const causes = await prisma.causes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CausesUpdateManyArgs>(
      args: SelectSubset<T, CausesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Causes.
     * @param {CausesUpsertArgs} args - Arguments to update or create a Causes.
     * @example
     * // Update or create a Causes
     * const causes = await prisma.causes.upsert({
     *   create: {
     *     // ... data to create a Causes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Causes we want to update
     *   }
     * })
    **/
    upsert<T extends CausesUpsertArgs>(
      args: SelectSubset<T, CausesUpsertArgs>
    ): Prisma__CausesClient<CausesGetPayload<T>>

    /**
     * Count the number of Causes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesCountArgs} args - Arguments to filter Causes to count.
     * @example
     * // Count the number of Causes
     * const count = await prisma.causes.count({
     *   where: {
     *     // ... the filter for the Causes we want to count
     *   }
     * })
    **/
    count<T extends CausesCountArgs>(
      args?: Subset<T, CausesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CausesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Causes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CausesAggregateArgs>(args: Subset<T, CausesAggregateArgs>): Prisma.PrismaPromise<GetCausesAggregateType<T>>

    /**
     * Group by Causes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CausesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CausesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CausesGroupByArgs['orderBy'] }
        : { orderBy?: CausesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CausesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCausesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Causes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CausesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign_causes<T extends Causes$campaign_causesArgs= {}>(args?: Subset<T, Causes$campaign_causesArgs>): Prisma.PrismaPromise<Array<CampaignCausesGetPayload<T>>| Null>;

    ngo_causes<T extends Causes$ngo_causesArgs= {}>(args?: Subset<T, Causes$ngo_causesArgs>): Prisma.PrismaPromise<Array<NgoCausesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Causes base type for findUnique actions
   */
  export type CausesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * Filter, which Causes to fetch.
     */
    where: CausesWhereUniqueInput
  }

  /**
   * Causes findUnique
   */
  export interface CausesFindUniqueArgs extends CausesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Causes findUniqueOrThrow
   */
  export type CausesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * Filter, which Causes to fetch.
     */
    where: CausesWhereUniqueInput
  }


  /**
   * Causes base type for findFirst actions
   */
  export type CausesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * Filter, which Causes to fetch.
     */
    where?: CausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Causes to fetch.
     */
    orderBy?: Enumerable<CausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Causes.
     */
    cursor?: CausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Causes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Causes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Causes.
     */
    distinct?: Enumerable<CausesScalarFieldEnum>
  }

  /**
   * Causes findFirst
   */
  export interface CausesFindFirstArgs extends CausesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Causes findFirstOrThrow
   */
  export type CausesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * Filter, which Causes to fetch.
     */
    where?: CausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Causes to fetch.
     */
    orderBy?: Enumerable<CausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Causes.
     */
    cursor?: CausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Causes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Causes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Causes.
     */
    distinct?: Enumerable<CausesScalarFieldEnum>
  }


  /**
   * Causes findMany
   */
  export type CausesFindManyArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * Filter, which Causes to fetch.
     */
    where?: CausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Causes to fetch.
     */
    orderBy?: Enumerable<CausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Causes.
     */
    cursor?: CausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Causes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Causes.
     */
    skip?: number
    distinct?: Enumerable<CausesScalarFieldEnum>
  }


  /**
   * Causes create
   */
  export type CausesCreateArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * The data needed to create a Causes.
     */
    data: XOR<CausesCreateInput, CausesUncheckedCreateInput>
  }


  /**
   * Causes createMany
   */
  export type CausesCreateManyArgs = {
    /**
     * The data used to create many Causes.
     */
    data: Enumerable<CausesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Causes update
   */
  export type CausesUpdateArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * The data needed to update a Causes.
     */
    data: XOR<CausesUpdateInput, CausesUncheckedUpdateInput>
    /**
     * Choose, which Causes to update.
     */
    where: CausesWhereUniqueInput
  }


  /**
   * Causes updateMany
   */
  export type CausesUpdateManyArgs = {
    /**
     * The data used to update Causes.
     */
    data: XOR<CausesUpdateManyMutationInput, CausesUncheckedUpdateManyInput>
    /**
     * Filter which Causes to update
     */
    where?: CausesWhereInput
  }


  /**
   * Causes upsert
   */
  export type CausesUpsertArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * The filter to search for the Causes to update in case it exists.
     */
    where: CausesWhereUniqueInput
    /**
     * In case the Causes found by the `where` argument doesn't exist, create a new Causes with this data.
     */
    create: XOR<CausesCreateInput, CausesUncheckedCreateInput>
    /**
     * In case the Causes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CausesUpdateInput, CausesUncheckedUpdateInput>
  }


  /**
   * Causes delete
   */
  export type CausesDeleteArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
    /**
     * Filter which Causes to delete.
     */
    where: CausesWhereUniqueInput
  }


  /**
   * Causes deleteMany
   */
  export type CausesDeleteManyArgs = {
    /**
     * Filter which Causes to delete
     */
    where?: CausesWhereInput
  }


  /**
   * Causes.campaign_causes
   */
  export type Causes$campaign_causesArgs = {
    /**
     * Select specific fields to fetch from the CampaignCauses
     */
    select?: CampaignCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignCausesInclude | null
    where?: CampaignCausesWhereInput
    orderBy?: Enumerable<CampaignCausesOrderByWithRelationInput>
    cursor?: CampaignCausesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignCausesScalarFieldEnum>
  }


  /**
   * Causes.ngo_causes
   */
  export type Causes$ngo_causesArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    where?: NgoCausesWhereInput
    orderBy?: Enumerable<NgoCausesOrderByWithRelationInput>
    cursor?: NgoCausesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NgoCausesScalarFieldEnum>
  }


  /**
   * Causes without action
   */
  export type CausesArgs = {
    /**
     * Select specific fields to fetch from the Causes
     */
    select?: CausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CausesInclude | null
  }



  /**
   * Model Following
   */


  export type AggregateFollowing = {
    _count: FollowingCountAggregateOutputType | null
    _min: FollowingMinAggregateOutputType | null
    _max: FollowingMaxAggregateOutputType | null
  }

  export type FollowingMinAggregateOutputType = {
    id: string | null
    id_user: string | null
    id_ngo: string | null
    id_status: string | null
  }

  export type FollowingMaxAggregateOutputType = {
    id: string | null
    id_user: string | null
    id_ngo: string | null
    id_status: string | null
  }

  export type FollowingCountAggregateOutputType = {
    id: number
    id_user: number
    id_ngo: number
    id_status: number
    _all: number
  }


  export type FollowingMinAggregateInputType = {
    id?: true
    id_user?: true
    id_ngo?: true
    id_status?: true
  }

  export type FollowingMaxAggregateInputType = {
    id?: true
    id_user?: true
    id_ngo?: true
    id_status?: true
  }

  export type FollowingCountAggregateInputType = {
    id?: true
    id_user?: true
    id_ngo?: true
    id_status?: true
    _all?: true
  }

  export type FollowingAggregateArgs = {
    /**
     * Filter which Following to aggregate.
     */
    where?: FollowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followings to fetch.
     */
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Followings
    **/
    _count?: true | FollowingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowingMaxAggregateInputType
  }

  export type GetFollowingAggregateType<T extends FollowingAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowing[P]>
      : GetScalarType<T[P], AggregateFollowing[P]>
  }




  export type FollowingGroupByArgs = {
    where?: FollowingWhereInput
    orderBy?: Enumerable<FollowingOrderByWithAggregationInput>
    by: FollowingScalarFieldEnum[]
    having?: FollowingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowingCountAggregateInputType | true
    _min?: FollowingMinAggregateInputType
    _max?: FollowingMaxAggregateInputType
  }


  export type FollowingGroupByOutputType = {
    id: string
    id_user: string
    id_ngo: string
    id_status: string
    _count: FollowingCountAggregateOutputType | null
    _min: FollowingMinAggregateOutputType | null
    _max: FollowingMaxAggregateOutputType | null
  }

  type GetFollowingGroupByPayload<T extends FollowingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FollowingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowingGroupByOutputType[P]>
            : GetScalarType<T[P], FollowingGroupByOutputType[P]>
        }
      >
    >


  export type FollowingSelect = {
    id?: boolean
    id_user?: boolean
    id_ngo?: boolean
    id_status?: boolean
    status?: boolean | StatusArgs
    ngo?: boolean | NGOArgs
    user?: boolean | UserArgs
  }


  export type FollowingInclude = {
    status?: boolean | StatusArgs
    ngo?: boolean | NGOArgs
    user?: boolean | UserArgs
  }

  export type FollowingGetPayload<S extends boolean | null | undefined | FollowingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Following :
    S extends undefined ? never :
    S extends { include: any } & (FollowingArgs | FollowingFindManyArgs)
    ? Following  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'status' ? StatusGetPayload<S['include'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FollowingArgs | FollowingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'status' ? StatusGetPayload<S['select'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Following ? Following[P] : never
  } 
      : Following


  type FollowingCountArgs = 
    Omit<FollowingFindManyArgs, 'select' | 'include'> & {
      select?: FollowingCountAggregateInputType | true
    }

  export interface FollowingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Following that matches the filter.
     * @param {FollowingFindUniqueArgs} args - Arguments to find a Following
     * @example
     * // Get one Following
     * const following = await prisma.following.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FollowingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FollowingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Following'> extends True ? Prisma__FollowingClient<FollowingGetPayload<T>> : Prisma__FollowingClient<FollowingGetPayload<T> | null, null>

    /**
     * Find one Following that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FollowingFindUniqueOrThrowArgs} args - Arguments to find a Following
     * @example
     * // Get one Following
     * const following = await prisma.following.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FollowingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FollowingFindUniqueOrThrowArgs>
    ): Prisma__FollowingClient<FollowingGetPayload<T>>

    /**
     * Find the first Following that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingFindFirstArgs} args - Arguments to find a Following
     * @example
     * // Get one Following
     * const following = await prisma.following.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FollowingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FollowingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Following'> extends True ? Prisma__FollowingClient<FollowingGetPayload<T>> : Prisma__FollowingClient<FollowingGetPayload<T> | null, null>

    /**
     * Find the first Following that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingFindFirstOrThrowArgs} args - Arguments to find a Following
     * @example
     * // Get one Following
     * const following = await prisma.following.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FollowingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FollowingFindFirstOrThrowArgs>
    ): Prisma__FollowingClient<FollowingGetPayload<T>>

    /**
     * Find zero or more Followings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Followings
     * const followings = await prisma.following.findMany()
     * 
     * // Get first 10 Followings
     * const followings = await prisma.following.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followingWithIdOnly = await prisma.following.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FollowingFindManyArgs>(
      args?: SelectSubset<T, FollowingFindManyArgs>
    ): Prisma.PrismaPromise<Array<FollowingGetPayload<T>>>

    /**
     * Create a Following.
     * @param {FollowingCreateArgs} args - Arguments to create a Following.
     * @example
     * // Create one Following
     * const Following = await prisma.following.create({
     *   data: {
     *     // ... data to create a Following
     *   }
     * })
     * 
    **/
    create<T extends FollowingCreateArgs>(
      args: SelectSubset<T, FollowingCreateArgs>
    ): Prisma__FollowingClient<FollowingGetPayload<T>>

    /**
     * Create many Followings.
     *     @param {FollowingCreateManyArgs} args - Arguments to create many Followings.
     *     @example
     *     // Create many Followings
     *     const following = await prisma.following.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FollowingCreateManyArgs>(
      args?: SelectSubset<T, FollowingCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Following.
     * @param {FollowingDeleteArgs} args - Arguments to delete one Following.
     * @example
     * // Delete one Following
     * const Following = await prisma.following.delete({
     *   where: {
     *     // ... filter to delete one Following
     *   }
     * })
     * 
    **/
    delete<T extends FollowingDeleteArgs>(
      args: SelectSubset<T, FollowingDeleteArgs>
    ): Prisma__FollowingClient<FollowingGetPayload<T>>

    /**
     * Update one Following.
     * @param {FollowingUpdateArgs} args - Arguments to update one Following.
     * @example
     * // Update one Following
     * const following = await prisma.following.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FollowingUpdateArgs>(
      args: SelectSubset<T, FollowingUpdateArgs>
    ): Prisma__FollowingClient<FollowingGetPayload<T>>

    /**
     * Delete zero or more Followings.
     * @param {FollowingDeleteManyArgs} args - Arguments to filter Followings to delete.
     * @example
     * // Delete a few Followings
     * const { count } = await prisma.following.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FollowingDeleteManyArgs>(
      args?: SelectSubset<T, FollowingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Followings
     * const following = await prisma.following.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FollowingUpdateManyArgs>(
      args: SelectSubset<T, FollowingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Following.
     * @param {FollowingUpsertArgs} args - Arguments to update or create a Following.
     * @example
     * // Update or create a Following
     * const following = await prisma.following.upsert({
     *   create: {
     *     // ... data to create a Following
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Following we want to update
     *   }
     * })
    **/
    upsert<T extends FollowingUpsertArgs>(
      args: SelectSubset<T, FollowingUpsertArgs>
    ): Prisma__FollowingClient<FollowingGetPayload<T>>

    /**
     * Count the number of Followings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingCountArgs} args - Arguments to filter Followings to count.
     * @example
     * // Count the number of Followings
     * const count = await prisma.following.count({
     *   where: {
     *     // ... the filter for the Followings we want to count
     *   }
     * })
    **/
    count<T extends FollowingCountArgs>(
      args?: Subset<T, FollowingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Following.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowingAggregateArgs>(args: Subset<T, FollowingAggregateArgs>): Prisma.PrismaPromise<GetFollowingAggregateType<T>>

    /**
     * Group by Following.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowingGroupByArgs['orderBy'] }
        : { orderBy?: FollowingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Following.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FollowingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    status<T extends StatusArgs= {}>(args?: Subset<T, StatusArgs>): Prisma__StatusClient<StatusGetPayload<T> | Null>;

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Following base type for findUnique actions
   */
  export type FollowingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * Filter, which Following to fetch.
     */
    where: FollowingWhereUniqueInput
  }

  /**
   * Following findUnique
   */
  export interface FollowingFindUniqueArgs extends FollowingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Following findUniqueOrThrow
   */
  export type FollowingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * Filter, which Following to fetch.
     */
    where: FollowingWhereUniqueInput
  }


  /**
   * Following base type for findFirst actions
   */
  export type FollowingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * Filter, which Following to fetch.
     */
    where?: FollowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followings to fetch.
     */
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followings.
     */
    cursor?: FollowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followings.
     */
    distinct?: Enumerable<FollowingScalarFieldEnum>
  }

  /**
   * Following findFirst
   */
  export interface FollowingFindFirstArgs extends FollowingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Following findFirstOrThrow
   */
  export type FollowingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * Filter, which Following to fetch.
     */
    where?: FollowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followings to fetch.
     */
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followings.
     */
    cursor?: FollowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followings.
     */
    distinct?: Enumerable<FollowingScalarFieldEnum>
  }


  /**
   * Following findMany
   */
  export type FollowingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * Filter, which Followings to fetch.
     */
    where?: FollowingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followings to fetch.
     */
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Followings.
     */
    cursor?: FollowingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followings.
     */
    skip?: number
    distinct?: Enumerable<FollowingScalarFieldEnum>
  }


  /**
   * Following create
   */
  export type FollowingCreateArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * The data needed to create a Following.
     */
    data: XOR<FollowingCreateInput, FollowingUncheckedCreateInput>
  }


  /**
   * Following createMany
   */
  export type FollowingCreateManyArgs = {
    /**
     * The data used to create many Followings.
     */
    data: Enumerable<FollowingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Following update
   */
  export type FollowingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * The data needed to update a Following.
     */
    data: XOR<FollowingUpdateInput, FollowingUncheckedUpdateInput>
    /**
     * Choose, which Following to update.
     */
    where: FollowingWhereUniqueInput
  }


  /**
   * Following updateMany
   */
  export type FollowingUpdateManyArgs = {
    /**
     * The data used to update Followings.
     */
    data: XOR<FollowingUpdateManyMutationInput, FollowingUncheckedUpdateManyInput>
    /**
     * Filter which Followings to update
     */
    where?: FollowingWhereInput
  }


  /**
   * Following upsert
   */
  export type FollowingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * The filter to search for the Following to update in case it exists.
     */
    where: FollowingWhereUniqueInput
    /**
     * In case the Following found by the `where` argument doesn't exist, create a new Following with this data.
     */
    create: XOR<FollowingCreateInput, FollowingUncheckedCreateInput>
    /**
     * In case the Following was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowingUpdateInput, FollowingUncheckedUpdateInput>
  }


  /**
   * Following delete
   */
  export type FollowingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    /**
     * Filter which Following to delete.
     */
    where: FollowingWhereUniqueInput
  }


  /**
   * Following deleteMany
   */
  export type FollowingDeleteManyArgs = {
    /**
     * Filter which Followings to delete
     */
    where?: FollowingWhereInput
  }


  /**
   * Following without action
   */
  export type FollowingArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
  }



  /**
   * Model NGO
   */


  export type AggregateNGO = {
    _count: NGOCountAggregateOutputType | null
    _min: NGOMinAggregateOutputType | null
    _max: NGOMaxAggregateOutputType | null
  }

  export type NGOMinAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    foundation_date: Date | null
    description: string | null
    email: string | null
    password: string | null
    id_type: string | null
    photo_url: string | null
    banner_photo: string | null
    created_at: Date | null
  }

  export type NGOMaxAggregateOutputType = {
    id: string | null
    name: string | null
    cnpj: string | null
    foundation_date: Date | null
    description: string | null
    email: string | null
    password: string | null
    id_type: string | null
    photo_url: string | null
    banner_photo: string | null
    created_at: Date | null
  }

  export type NGOCountAggregateOutputType = {
    id: number
    name: number
    cnpj: number
    foundation_date: number
    description: number
    email: number
    password: number
    id_type: number
    photo_url: number
    banner_photo: number
    created_at: number
    _all: number
  }


  export type NGOMinAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    foundation_date?: true
    description?: true
    email?: true
    password?: true
    id_type?: true
    photo_url?: true
    banner_photo?: true
    created_at?: true
  }

  export type NGOMaxAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    foundation_date?: true
    description?: true
    email?: true
    password?: true
    id_type?: true
    photo_url?: true
    banner_photo?: true
    created_at?: true
  }

  export type NGOCountAggregateInputType = {
    id?: true
    name?: true
    cnpj?: true
    foundation_date?: true
    description?: true
    email?: true
    password?: true
    id_type?: true
    photo_url?: true
    banner_photo?: true
    created_at?: true
    _all?: true
  }

  export type NGOAggregateArgs = {
    /**
     * Filter which NGO to aggregate.
     */
    where?: NGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NGOS to fetch.
     */
    orderBy?: Enumerable<NGOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NGOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NGOS
    **/
    _count?: true | NGOCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NGOMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NGOMaxAggregateInputType
  }

  export type GetNGOAggregateType<T extends NGOAggregateArgs> = {
        [P in keyof T & keyof AggregateNGO]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNGO[P]>
      : GetScalarType<T[P], AggregateNGO[P]>
  }




  export type NGOGroupByArgs = {
    where?: NGOWhereInput
    orderBy?: Enumerable<NGOOrderByWithAggregationInput>
    by: NGOScalarFieldEnum[]
    having?: NGOScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NGOCountAggregateInputType | true
    _min?: NGOMinAggregateInputType
    _max?: NGOMaxAggregateInputType
  }


  export type NGOGroupByOutputType = {
    id: string
    name: string
    cnpj: string
    foundation_date: Date | null
    description: string | null
    email: string
    password: string
    id_type: string
    photo_url: string
    banner_photo: string
    created_at: Date
    _count: NGOCountAggregateOutputType | null
    _min: NGOMinAggregateOutputType | null
    _max: NGOMaxAggregateOutputType | null
  }

  type GetNGOGroupByPayload<T extends NGOGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NGOGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NGOGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NGOGroupByOutputType[P]>
            : GetScalarType<T[P], NGOGroupByOutputType[P]>
        }
      >
    >


  export type NGOSelect = {
    id?: boolean
    name?: boolean
    cnpj?: boolean
    foundation_date?: boolean
    description?: boolean
    email?: boolean
    password?: boolean
    id_type?: boolean
    photo_url?: boolean
    banner_photo?: boolean
    created_at?: boolean
    campaign?: boolean | NGO$campaignArgs
    comment_ngo?: boolean | NGO$comment_ngoArgs
    following?: boolean | NGO$followingArgs
    type?: boolean | TypeArgs
    ngo_address?: boolean | NgoAddressArgs
    ngo_causes?: boolean | NGO$ngo_causesArgs
    ngo_phone?: boolean | NGO$ngo_phoneArgs
    post_ngo?: boolean | NGO$post_ngoArgs
    comment_likes?: boolean | NGO$comment_likesArgs
    post_likes?: boolean | NGO$post_likesArgs
    attached_link?: boolean | NGO$attached_linkArgs
    _count?: boolean | NGOCountOutputTypeArgs
  }


  export type NGOInclude = {
    campaign?: boolean | NGO$campaignArgs
    comment_ngo?: boolean | NGO$comment_ngoArgs
    following?: boolean | NGO$followingArgs
    type?: boolean | TypeArgs
    ngo_address?: boolean | NgoAddressArgs
    ngo_causes?: boolean | NGO$ngo_causesArgs
    ngo_phone?: boolean | NGO$ngo_phoneArgs
    post_ngo?: boolean | NGO$post_ngoArgs
    comment_likes?: boolean | NGO$comment_likesArgs
    post_likes?: boolean | NGO$post_likesArgs
    attached_link?: boolean | NGO$attached_linkArgs
    _count?: boolean | NGOCountOutputTypeArgs
  }

  export type NGOGetPayload<S extends boolean | null | undefined | NGOArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NGO :
    S extends undefined ? never :
    S extends { include: any } & (NGOArgs | NGOFindManyArgs)
    ? NGO  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'campaign' ? Array < CampaignGetPayload<S['include'][P]>>  :
        P extends 'comment_ngo' ? Array < CommentNgoGetPayload<S['include'][P]>>  :
        P extends 'following' ? Array < FollowingGetPayload<S['include'][P]>>  :
        P extends 'type' ? TypeGetPayload<S['include'][P]> :
        P extends 'ngo_address' ? NgoAddressGetPayload<S['include'][P]> | null :
        P extends 'ngo_causes' ? Array < NgoCausesGetPayload<S['include'][P]>>  :
        P extends 'ngo_phone' ? Array < NgoPhoneGetPayload<S['include'][P]>>  :
        P extends 'post_ngo' ? Array < PostNgoGetPayload<S['include'][P]>>  :
        P extends 'comment_likes' ? Array < CommentLikesGetPayload<S['include'][P]>>  :
        P extends 'post_likes' ? Array < PostLikesGetPayload<S['include'][P]>>  :
        P extends 'attached_link' ? Array < AttachedLinkGetPayload<S['include'][P]>>  :
        P extends '_count' ? NGOCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NGOArgs | NGOFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'campaign' ? Array < CampaignGetPayload<S['select'][P]>>  :
        P extends 'comment_ngo' ? Array < CommentNgoGetPayload<S['select'][P]>>  :
        P extends 'following' ? Array < FollowingGetPayload<S['select'][P]>>  :
        P extends 'type' ? TypeGetPayload<S['select'][P]> :
        P extends 'ngo_address' ? NgoAddressGetPayload<S['select'][P]> | null :
        P extends 'ngo_causes' ? Array < NgoCausesGetPayload<S['select'][P]>>  :
        P extends 'ngo_phone' ? Array < NgoPhoneGetPayload<S['select'][P]>>  :
        P extends 'post_ngo' ? Array < PostNgoGetPayload<S['select'][P]>>  :
        P extends 'comment_likes' ? Array < CommentLikesGetPayload<S['select'][P]>>  :
        P extends 'post_likes' ? Array < PostLikesGetPayload<S['select'][P]>>  :
        P extends 'attached_link' ? Array < AttachedLinkGetPayload<S['select'][P]>>  :
        P extends '_count' ? NGOCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof NGO ? NGO[P] : never
  } 
      : NGO


  type NGOCountArgs = 
    Omit<NGOFindManyArgs, 'select' | 'include'> & {
      select?: NGOCountAggregateInputType | true
    }

  export interface NGODelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NGO that matches the filter.
     * @param {NGOFindUniqueArgs} args - Arguments to find a NGO
     * @example
     * // Get one NGO
     * const nGO = await prisma.nGO.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NGOFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NGOFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NGO'> extends True ? Prisma__NGOClient<NGOGetPayload<T>> : Prisma__NGOClient<NGOGetPayload<T> | null, null>

    /**
     * Find one NGO that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NGOFindUniqueOrThrowArgs} args - Arguments to find a NGO
     * @example
     * // Get one NGO
     * const nGO = await prisma.nGO.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NGOFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NGOFindUniqueOrThrowArgs>
    ): Prisma__NGOClient<NGOGetPayload<T>>

    /**
     * Find the first NGO that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOFindFirstArgs} args - Arguments to find a NGO
     * @example
     * // Get one NGO
     * const nGO = await prisma.nGO.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NGOFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NGOFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NGO'> extends True ? Prisma__NGOClient<NGOGetPayload<T>> : Prisma__NGOClient<NGOGetPayload<T> | null, null>

    /**
     * Find the first NGO that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOFindFirstOrThrowArgs} args - Arguments to find a NGO
     * @example
     * // Get one NGO
     * const nGO = await prisma.nGO.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NGOFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NGOFindFirstOrThrowArgs>
    ): Prisma__NGOClient<NGOGetPayload<T>>

    /**
     * Find zero or more NGOS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NGOS
     * const nGOS = await prisma.nGO.findMany()
     * 
     * // Get first 10 NGOS
     * const nGOS = await prisma.nGO.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nGOWithIdOnly = await prisma.nGO.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NGOFindManyArgs>(
      args?: SelectSubset<T, NGOFindManyArgs>
    ): Prisma.PrismaPromise<Array<NGOGetPayload<T>>>

    /**
     * Create a NGO.
     * @param {NGOCreateArgs} args - Arguments to create a NGO.
     * @example
     * // Create one NGO
     * const NGO = await prisma.nGO.create({
     *   data: {
     *     // ... data to create a NGO
     *   }
     * })
     * 
    **/
    create<T extends NGOCreateArgs>(
      args: SelectSubset<T, NGOCreateArgs>
    ): Prisma__NGOClient<NGOGetPayload<T>>

    /**
     * Create many NGOS.
     *     @param {NGOCreateManyArgs} args - Arguments to create many NGOS.
     *     @example
     *     // Create many NGOS
     *     const nGO = await prisma.nGO.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NGOCreateManyArgs>(
      args?: SelectSubset<T, NGOCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NGO.
     * @param {NGODeleteArgs} args - Arguments to delete one NGO.
     * @example
     * // Delete one NGO
     * const NGO = await prisma.nGO.delete({
     *   where: {
     *     // ... filter to delete one NGO
     *   }
     * })
     * 
    **/
    delete<T extends NGODeleteArgs>(
      args: SelectSubset<T, NGODeleteArgs>
    ): Prisma__NGOClient<NGOGetPayload<T>>

    /**
     * Update one NGO.
     * @param {NGOUpdateArgs} args - Arguments to update one NGO.
     * @example
     * // Update one NGO
     * const nGO = await prisma.nGO.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NGOUpdateArgs>(
      args: SelectSubset<T, NGOUpdateArgs>
    ): Prisma__NGOClient<NGOGetPayload<T>>

    /**
     * Delete zero or more NGOS.
     * @param {NGODeleteManyArgs} args - Arguments to filter NGOS to delete.
     * @example
     * // Delete a few NGOS
     * const { count } = await prisma.nGO.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NGODeleteManyArgs>(
      args?: SelectSubset<T, NGODeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NGOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NGOS
     * const nGO = await prisma.nGO.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NGOUpdateManyArgs>(
      args: SelectSubset<T, NGOUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NGO.
     * @param {NGOUpsertArgs} args - Arguments to update or create a NGO.
     * @example
     * // Update or create a NGO
     * const nGO = await prisma.nGO.upsert({
     *   create: {
     *     // ... data to create a NGO
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NGO we want to update
     *   }
     * })
    **/
    upsert<T extends NGOUpsertArgs>(
      args: SelectSubset<T, NGOUpsertArgs>
    ): Prisma__NGOClient<NGOGetPayload<T>>

    /**
     * Count the number of NGOS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOCountArgs} args - Arguments to filter NGOS to count.
     * @example
     * // Count the number of NGOS
     * const count = await prisma.nGO.count({
     *   where: {
     *     // ... the filter for the NGOS we want to count
     *   }
     * })
    **/
    count<T extends NGOCountArgs>(
      args?: Subset<T, NGOCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NGOCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NGO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NGOAggregateArgs>(args: Subset<T, NGOAggregateArgs>): Prisma.PrismaPromise<GetNGOAggregateType<T>>

    /**
     * Group by NGO.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NGOGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NGOGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NGOGroupByArgs['orderBy'] }
        : { orderBy?: NGOGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NGOGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNGOGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NGO.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NGOClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    campaign<T extends NGO$campaignArgs= {}>(args?: Subset<T, NGO$campaignArgs>): Prisma.PrismaPromise<Array<CampaignGetPayload<T>>| Null>;

    comment_ngo<T extends NGO$comment_ngoArgs= {}>(args?: Subset<T, NGO$comment_ngoArgs>): Prisma.PrismaPromise<Array<CommentNgoGetPayload<T>>| Null>;

    following<T extends NGO$followingArgs= {}>(args?: Subset<T, NGO$followingArgs>): Prisma.PrismaPromise<Array<FollowingGetPayload<T>>| Null>;

    type<T extends TypeArgs= {}>(args?: Subset<T, TypeArgs>): Prisma__TypeClient<TypeGetPayload<T> | Null>;

    ngo_address<T extends NgoAddressArgs= {}>(args?: Subset<T, NgoAddressArgs>): Prisma__NgoAddressClient<NgoAddressGetPayload<T> | Null>;

    ngo_causes<T extends NGO$ngo_causesArgs= {}>(args?: Subset<T, NGO$ngo_causesArgs>): Prisma.PrismaPromise<Array<NgoCausesGetPayload<T>>| Null>;

    ngo_phone<T extends NGO$ngo_phoneArgs= {}>(args?: Subset<T, NGO$ngo_phoneArgs>): Prisma.PrismaPromise<Array<NgoPhoneGetPayload<T>>| Null>;

    post_ngo<T extends NGO$post_ngoArgs= {}>(args?: Subset<T, NGO$post_ngoArgs>): Prisma.PrismaPromise<Array<PostNgoGetPayload<T>>| Null>;

    comment_likes<T extends NGO$comment_likesArgs= {}>(args?: Subset<T, NGO$comment_likesArgs>): Prisma.PrismaPromise<Array<CommentLikesGetPayload<T>>| Null>;

    post_likes<T extends NGO$post_likesArgs= {}>(args?: Subset<T, NGO$post_likesArgs>): Prisma.PrismaPromise<Array<PostLikesGetPayload<T>>| Null>;

    attached_link<T extends NGO$attached_linkArgs= {}>(args?: Subset<T, NGO$attached_linkArgs>): Prisma.PrismaPromise<Array<AttachedLinkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NGO base type for findUnique actions
   */
  export type NGOFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * Filter, which NGO to fetch.
     */
    where: NGOWhereUniqueInput
  }

  /**
   * NGO findUnique
   */
  export interface NGOFindUniqueArgs extends NGOFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NGO findUniqueOrThrow
   */
  export type NGOFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * Filter, which NGO to fetch.
     */
    where: NGOWhereUniqueInput
  }


  /**
   * NGO base type for findFirst actions
   */
  export type NGOFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * Filter, which NGO to fetch.
     */
    where?: NGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NGOS to fetch.
     */
    orderBy?: Enumerable<NGOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NGOS.
     */
    cursor?: NGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NGOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NGOS.
     */
    distinct?: Enumerable<NGOScalarFieldEnum>
  }

  /**
   * NGO findFirst
   */
  export interface NGOFindFirstArgs extends NGOFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NGO findFirstOrThrow
   */
  export type NGOFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * Filter, which NGO to fetch.
     */
    where?: NGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NGOS to fetch.
     */
    orderBy?: Enumerable<NGOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NGOS.
     */
    cursor?: NGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NGOS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NGOS.
     */
    distinct?: Enumerable<NGOScalarFieldEnum>
  }


  /**
   * NGO findMany
   */
  export type NGOFindManyArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * Filter, which NGOS to fetch.
     */
    where?: NGOWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NGOS to fetch.
     */
    orderBy?: Enumerable<NGOOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NGOS.
     */
    cursor?: NGOWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NGOS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NGOS.
     */
    skip?: number
    distinct?: Enumerable<NGOScalarFieldEnum>
  }


  /**
   * NGO create
   */
  export type NGOCreateArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * The data needed to create a NGO.
     */
    data: XOR<NGOCreateInput, NGOUncheckedCreateInput>
  }


  /**
   * NGO createMany
   */
  export type NGOCreateManyArgs = {
    /**
     * The data used to create many NGOS.
     */
    data: Enumerable<NGOCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NGO update
   */
  export type NGOUpdateArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * The data needed to update a NGO.
     */
    data: XOR<NGOUpdateInput, NGOUncheckedUpdateInput>
    /**
     * Choose, which NGO to update.
     */
    where: NGOWhereUniqueInput
  }


  /**
   * NGO updateMany
   */
  export type NGOUpdateManyArgs = {
    /**
     * The data used to update NGOS.
     */
    data: XOR<NGOUpdateManyMutationInput, NGOUncheckedUpdateManyInput>
    /**
     * Filter which NGOS to update
     */
    where?: NGOWhereInput
  }


  /**
   * NGO upsert
   */
  export type NGOUpsertArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * The filter to search for the NGO to update in case it exists.
     */
    where: NGOWhereUniqueInput
    /**
     * In case the NGO found by the `where` argument doesn't exist, create a new NGO with this data.
     */
    create: XOR<NGOCreateInput, NGOUncheckedCreateInput>
    /**
     * In case the NGO was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NGOUpdateInput, NGOUncheckedUpdateInput>
  }


  /**
   * NGO delete
   */
  export type NGODeleteArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    /**
     * Filter which NGO to delete.
     */
    where: NGOWhereUniqueInput
  }


  /**
   * NGO deleteMany
   */
  export type NGODeleteManyArgs = {
    /**
     * Filter which NGOS to delete
     */
    where?: NGOWhereInput
  }


  /**
   * NGO.campaign
   */
  export type NGO$campaignArgs = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude | null
    where?: CampaignWhereInput
    orderBy?: Enumerable<CampaignOrderByWithRelationInput>
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignScalarFieldEnum>
  }


  /**
   * NGO.comment_ngo
   */
  export type NGO$comment_ngoArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    where?: CommentNgoWhereInput
    orderBy?: Enumerable<CommentNgoOrderByWithRelationInput>
    cursor?: CommentNgoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentNgoScalarFieldEnum>
  }


  /**
   * NGO.following
   */
  export type NGO$followingArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    where?: FollowingWhereInput
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    cursor?: FollowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FollowingScalarFieldEnum>
  }


  /**
   * NGO.ngo_causes
   */
  export type NGO$ngo_causesArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    where?: NgoCausesWhereInput
    orderBy?: Enumerable<NgoCausesOrderByWithRelationInput>
    cursor?: NgoCausesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NgoCausesScalarFieldEnum>
  }


  /**
   * NGO.ngo_phone
   */
  export type NGO$ngo_phoneArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    where?: NgoPhoneWhereInput
    orderBy?: Enumerable<NgoPhoneOrderByWithRelationInput>
    cursor?: NgoPhoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NgoPhoneScalarFieldEnum>
  }


  /**
   * NGO.post_ngo
   */
  export type NGO$post_ngoArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    where?: PostNgoWhereInput
    orderBy?: Enumerable<PostNgoOrderByWithRelationInput>
    cursor?: PostNgoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostNgoScalarFieldEnum>
  }


  /**
   * NGO.comment_likes
   */
  export type NGO$comment_likesArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    where?: CommentLikesWhereInput
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    cursor?: CommentLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentLikesScalarFieldEnum>
  }


  /**
   * NGO.post_likes
   */
  export type NGO$post_likesArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    where?: PostLikesWhereInput
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    cursor?: PostLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostLikesScalarFieldEnum>
  }


  /**
   * NGO.attached_link
   */
  export type NGO$attached_linkArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    where?: AttachedLinkWhereInput
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    cursor?: AttachedLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AttachedLinkScalarFieldEnum>
  }


  /**
   * NGO without action
   */
  export type NGOArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
  }



  /**
   * Model NgoAddress
   */


  export type AggregateNgoAddress = {
    _count: NgoAddressCountAggregateOutputType | null
    _min: NgoAddressMinAggregateOutputType | null
    _max: NgoAddressMaxAggregateOutputType | null
  }

  export type NgoAddressMinAggregateOutputType = {
    id: string | null
    id_ngo: string | null
    id_address: string | null
  }

  export type NgoAddressMaxAggregateOutputType = {
    id: string | null
    id_ngo: string | null
    id_address: string | null
  }

  export type NgoAddressCountAggregateOutputType = {
    id: number
    id_ngo: number
    id_address: number
    _all: number
  }


  export type NgoAddressMinAggregateInputType = {
    id?: true
    id_ngo?: true
    id_address?: true
  }

  export type NgoAddressMaxAggregateInputType = {
    id?: true
    id_ngo?: true
    id_address?: true
  }

  export type NgoAddressCountAggregateInputType = {
    id?: true
    id_ngo?: true
    id_address?: true
    _all?: true
  }

  export type NgoAddressAggregateArgs = {
    /**
     * Filter which NgoAddress to aggregate.
     */
    where?: NgoAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoAddresses to fetch.
     */
    orderBy?: Enumerable<NgoAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NgoAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NgoAddresses
    **/
    _count?: true | NgoAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NgoAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NgoAddressMaxAggregateInputType
  }

  export type GetNgoAddressAggregateType<T extends NgoAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateNgoAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNgoAddress[P]>
      : GetScalarType<T[P], AggregateNgoAddress[P]>
  }




  export type NgoAddressGroupByArgs = {
    where?: NgoAddressWhereInput
    orderBy?: Enumerable<NgoAddressOrderByWithAggregationInput>
    by: NgoAddressScalarFieldEnum[]
    having?: NgoAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NgoAddressCountAggregateInputType | true
    _min?: NgoAddressMinAggregateInputType
    _max?: NgoAddressMaxAggregateInputType
  }


  export type NgoAddressGroupByOutputType = {
    id: string
    id_ngo: string
    id_address: string
    _count: NgoAddressCountAggregateOutputType | null
    _min: NgoAddressMinAggregateOutputType | null
    _max: NgoAddressMaxAggregateOutputType | null
  }

  type GetNgoAddressGroupByPayload<T extends NgoAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NgoAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NgoAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NgoAddressGroupByOutputType[P]>
            : GetScalarType<T[P], NgoAddressGroupByOutputType[P]>
        }
      >
    >


  export type NgoAddressSelect = {
    id?: boolean
    id_ngo?: boolean
    id_address?: boolean
    address?: boolean | AddressArgs
    ngo?: boolean | NGOArgs
  }


  export type NgoAddressInclude = {
    address?: boolean | AddressArgs
    ngo?: boolean | NGOArgs
  }

  export type NgoAddressGetPayload<S extends boolean | null | undefined | NgoAddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NgoAddress :
    S extends undefined ? never :
    S extends { include: any } & (NgoAddressArgs | NgoAddressFindManyArgs)
    ? NgoAddress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'address' ? AddressGetPayload<S['include'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NgoAddressArgs | NgoAddressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :  P extends keyof NgoAddress ? NgoAddress[P] : never
  } 
      : NgoAddress


  type NgoAddressCountArgs = 
    Omit<NgoAddressFindManyArgs, 'select' | 'include'> & {
      select?: NgoAddressCountAggregateInputType | true
    }

  export interface NgoAddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NgoAddress that matches the filter.
     * @param {NgoAddressFindUniqueArgs} args - Arguments to find a NgoAddress
     * @example
     * // Get one NgoAddress
     * const ngoAddress = await prisma.ngoAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NgoAddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NgoAddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NgoAddress'> extends True ? Prisma__NgoAddressClient<NgoAddressGetPayload<T>> : Prisma__NgoAddressClient<NgoAddressGetPayload<T> | null, null>

    /**
     * Find one NgoAddress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NgoAddressFindUniqueOrThrowArgs} args - Arguments to find a NgoAddress
     * @example
     * // Get one NgoAddress
     * const ngoAddress = await prisma.ngoAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NgoAddressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NgoAddressFindUniqueOrThrowArgs>
    ): Prisma__NgoAddressClient<NgoAddressGetPayload<T>>

    /**
     * Find the first NgoAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressFindFirstArgs} args - Arguments to find a NgoAddress
     * @example
     * // Get one NgoAddress
     * const ngoAddress = await prisma.ngoAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NgoAddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NgoAddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NgoAddress'> extends True ? Prisma__NgoAddressClient<NgoAddressGetPayload<T>> : Prisma__NgoAddressClient<NgoAddressGetPayload<T> | null, null>

    /**
     * Find the first NgoAddress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressFindFirstOrThrowArgs} args - Arguments to find a NgoAddress
     * @example
     * // Get one NgoAddress
     * const ngoAddress = await prisma.ngoAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NgoAddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NgoAddressFindFirstOrThrowArgs>
    ): Prisma__NgoAddressClient<NgoAddressGetPayload<T>>

    /**
     * Find zero or more NgoAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NgoAddresses
     * const ngoAddresses = await prisma.ngoAddress.findMany()
     * 
     * // Get first 10 NgoAddresses
     * const ngoAddresses = await prisma.ngoAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ngoAddressWithIdOnly = await prisma.ngoAddress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NgoAddressFindManyArgs>(
      args?: SelectSubset<T, NgoAddressFindManyArgs>
    ): Prisma.PrismaPromise<Array<NgoAddressGetPayload<T>>>

    /**
     * Create a NgoAddress.
     * @param {NgoAddressCreateArgs} args - Arguments to create a NgoAddress.
     * @example
     * // Create one NgoAddress
     * const NgoAddress = await prisma.ngoAddress.create({
     *   data: {
     *     // ... data to create a NgoAddress
     *   }
     * })
     * 
    **/
    create<T extends NgoAddressCreateArgs>(
      args: SelectSubset<T, NgoAddressCreateArgs>
    ): Prisma__NgoAddressClient<NgoAddressGetPayload<T>>

    /**
     * Create many NgoAddresses.
     *     @param {NgoAddressCreateManyArgs} args - Arguments to create many NgoAddresses.
     *     @example
     *     // Create many NgoAddresses
     *     const ngoAddress = await prisma.ngoAddress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NgoAddressCreateManyArgs>(
      args?: SelectSubset<T, NgoAddressCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NgoAddress.
     * @param {NgoAddressDeleteArgs} args - Arguments to delete one NgoAddress.
     * @example
     * // Delete one NgoAddress
     * const NgoAddress = await prisma.ngoAddress.delete({
     *   where: {
     *     // ... filter to delete one NgoAddress
     *   }
     * })
     * 
    **/
    delete<T extends NgoAddressDeleteArgs>(
      args: SelectSubset<T, NgoAddressDeleteArgs>
    ): Prisma__NgoAddressClient<NgoAddressGetPayload<T>>

    /**
     * Update one NgoAddress.
     * @param {NgoAddressUpdateArgs} args - Arguments to update one NgoAddress.
     * @example
     * // Update one NgoAddress
     * const ngoAddress = await prisma.ngoAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NgoAddressUpdateArgs>(
      args: SelectSubset<T, NgoAddressUpdateArgs>
    ): Prisma__NgoAddressClient<NgoAddressGetPayload<T>>

    /**
     * Delete zero or more NgoAddresses.
     * @param {NgoAddressDeleteManyArgs} args - Arguments to filter NgoAddresses to delete.
     * @example
     * // Delete a few NgoAddresses
     * const { count } = await prisma.ngoAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NgoAddressDeleteManyArgs>(
      args?: SelectSubset<T, NgoAddressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NgoAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NgoAddresses
     * const ngoAddress = await prisma.ngoAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NgoAddressUpdateManyArgs>(
      args: SelectSubset<T, NgoAddressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NgoAddress.
     * @param {NgoAddressUpsertArgs} args - Arguments to update or create a NgoAddress.
     * @example
     * // Update or create a NgoAddress
     * const ngoAddress = await prisma.ngoAddress.upsert({
     *   create: {
     *     // ... data to create a NgoAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NgoAddress we want to update
     *   }
     * })
    **/
    upsert<T extends NgoAddressUpsertArgs>(
      args: SelectSubset<T, NgoAddressUpsertArgs>
    ): Prisma__NgoAddressClient<NgoAddressGetPayload<T>>

    /**
     * Count the number of NgoAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressCountArgs} args - Arguments to filter NgoAddresses to count.
     * @example
     * // Count the number of NgoAddresses
     * const count = await prisma.ngoAddress.count({
     *   where: {
     *     // ... the filter for the NgoAddresses we want to count
     *   }
     * })
    **/
    count<T extends NgoAddressCountArgs>(
      args?: Subset<T, NgoAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NgoAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NgoAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NgoAddressAggregateArgs>(args: Subset<T, NgoAddressAggregateArgs>): Prisma.PrismaPromise<GetNgoAddressAggregateType<T>>

    /**
     * Group by NgoAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NgoAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NgoAddressGroupByArgs['orderBy'] }
        : { orderBy?: NgoAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NgoAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNgoAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NgoAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NgoAddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NgoAddress base type for findUnique actions
   */
  export type NgoAddressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * Filter, which NgoAddress to fetch.
     */
    where: NgoAddressWhereUniqueInput
  }

  /**
   * NgoAddress findUnique
   */
  export interface NgoAddressFindUniqueArgs extends NgoAddressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NgoAddress findUniqueOrThrow
   */
  export type NgoAddressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * Filter, which NgoAddress to fetch.
     */
    where: NgoAddressWhereUniqueInput
  }


  /**
   * NgoAddress base type for findFirst actions
   */
  export type NgoAddressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * Filter, which NgoAddress to fetch.
     */
    where?: NgoAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoAddresses to fetch.
     */
    orderBy?: Enumerable<NgoAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NgoAddresses.
     */
    cursor?: NgoAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NgoAddresses.
     */
    distinct?: Enumerable<NgoAddressScalarFieldEnum>
  }

  /**
   * NgoAddress findFirst
   */
  export interface NgoAddressFindFirstArgs extends NgoAddressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NgoAddress findFirstOrThrow
   */
  export type NgoAddressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * Filter, which NgoAddress to fetch.
     */
    where?: NgoAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoAddresses to fetch.
     */
    orderBy?: Enumerable<NgoAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NgoAddresses.
     */
    cursor?: NgoAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NgoAddresses.
     */
    distinct?: Enumerable<NgoAddressScalarFieldEnum>
  }


  /**
   * NgoAddress findMany
   */
  export type NgoAddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * Filter, which NgoAddresses to fetch.
     */
    where?: NgoAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoAddresses to fetch.
     */
    orderBy?: Enumerable<NgoAddressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NgoAddresses.
     */
    cursor?: NgoAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoAddresses.
     */
    skip?: number
    distinct?: Enumerable<NgoAddressScalarFieldEnum>
  }


  /**
   * NgoAddress create
   */
  export type NgoAddressCreateArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * The data needed to create a NgoAddress.
     */
    data: XOR<NgoAddressCreateInput, NgoAddressUncheckedCreateInput>
  }


  /**
   * NgoAddress createMany
   */
  export type NgoAddressCreateManyArgs = {
    /**
     * The data used to create many NgoAddresses.
     */
    data: Enumerable<NgoAddressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NgoAddress update
   */
  export type NgoAddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * The data needed to update a NgoAddress.
     */
    data: XOR<NgoAddressUpdateInput, NgoAddressUncheckedUpdateInput>
    /**
     * Choose, which NgoAddress to update.
     */
    where: NgoAddressWhereUniqueInput
  }


  /**
   * NgoAddress updateMany
   */
  export type NgoAddressUpdateManyArgs = {
    /**
     * The data used to update NgoAddresses.
     */
    data: XOR<NgoAddressUpdateManyMutationInput, NgoAddressUncheckedUpdateManyInput>
    /**
     * Filter which NgoAddresses to update
     */
    where?: NgoAddressWhereInput
  }


  /**
   * NgoAddress upsert
   */
  export type NgoAddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * The filter to search for the NgoAddress to update in case it exists.
     */
    where: NgoAddressWhereUniqueInput
    /**
     * In case the NgoAddress found by the `where` argument doesn't exist, create a new NgoAddress with this data.
     */
    create: XOR<NgoAddressCreateInput, NgoAddressUncheckedCreateInput>
    /**
     * In case the NgoAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NgoAddressUpdateInput, NgoAddressUncheckedUpdateInput>
  }


  /**
   * NgoAddress delete
   */
  export type NgoAddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
    /**
     * Filter which NgoAddress to delete.
     */
    where: NgoAddressWhereUniqueInput
  }


  /**
   * NgoAddress deleteMany
   */
  export type NgoAddressDeleteManyArgs = {
    /**
     * Filter which NgoAddresses to delete
     */
    where?: NgoAddressWhereInput
  }


  /**
   * NgoAddress without action
   */
  export type NgoAddressArgs = {
    /**
     * Select specific fields to fetch from the NgoAddress
     */
    select?: NgoAddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoAddressInclude | null
  }



  /**
   * Model NgoCauses
   */


  export type AggregateNgoCauses = {
    _count: NgoCausesCountAggregateOutputType | null
    _min: NgoCausesMinAggregateOutputType | null
    _max: NgoCausesMaxAggregateOutputType | null
  }

  export type NgoCausesMinAggregateOutputType = {
    id: string | null
    id_causes: string | null
    id_ngo: string | null
  }

  export type NgoCausesMaxAggregateOutputType = {
    id: string | null
    id_causes: string | null
    id_ngo: string | null
  }

  export type NgoCausesCountAggregateOutputType = {
    id: number
    id_causes: number
    id_ngo: number
    _all: number
  }


  export type NgoCausesMinAggregateInputType = {
    id?: true
    id_causes?: true
    id_ngo?: true
  }

  export type NgoCausesMaxAggregateInputType = {
    id?: true
    id_causes?: true
    id_ngo?: true
  }

  export type NgoCausesCountAggregateInputType = {
    id?: true
    id_causes?: true
    id_ngo?: true
    _all?: true
  }

  export type NgoCausesAggregateArgs = {
    /**
     * Filter which NgoCauses to aggregate.
     */
    where?: NgoCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoCauses to fetch.
     */
    orderBy?: Enumerable<NgoCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NgoCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoCauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NgoCauses
    **/
    _count?: true | NgoCausesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NgoCausesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NgoCausesMaxAggregateInputType
  }

  export type GetNgoCausesAggregateType<T extends NgoCausesAggregateArgs> = {
        [P in keyof T & keyof AggregateNgoCauses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNgoCauses[P]>
      : GetScalarType<T[P], AggregateNgoCauses[P]>
  }




  export type NgoCausesGroupByArgs = {
    where?: NgoCausesWhereInput
    orderBy?: Enumerable<NgoCausesOrderByWithAggregationInput>
    by: NgoCausesScalarFieldEnum[]
    having?: NgoCausesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NgoCausesCountAggregateInputType | true
    _min?: NgoCausesMinAggregateInputType
    _max?: NgoCausesMaxAggregateInputType
  }


  export type NgoCausesGroupByOutputType = {
    id: string
    id_causes: string
    id_ngo: string
    _count: NgoCausesCountAggregateOutputType | null
    _min: NgoCausesMinAggregateOutputType | null
    _max: NgoCausesMaxAggregateOutputType | null
  }

  type GetNgoCausesGroupByPayload<T extends NgoCausesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NgoCausesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NgoCausesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NgoCausesGroupByOutputType[P]>
            : GetScalarType<T[P], NgoCausesGroupByOutputType[P]>
        }
      >
    >


  export type NgoCausesSelect = {
    id?: boolean
    id_causes?: boolean
    id_ngo?: boolean
    causes?: boolean | CausesArgs
    ngo?: boolean | NGOArgs
  }


  export type NgoCausesInclude = {
    causes?: boolean | CausesArgs
    ngo?: boolean | NGOArgs
  }

  export type NgoCausesGetPayload<S extends boolean | null | undefined | NgoCausesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NgoCauses :
    S extends undefined ? never :
    S extends { include: any } & (NgoCausesArgs | NgoCausesFindManyArgs)
    ? NgoCauses  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'causes' ? CausesGetPayload<S['include'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NgoCausesArgs | NgoCausesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'causes' ? CausesGetPayload<S['select'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :  P extends keyof NgoCauses ? NgoCauses[P] : never
  } 
      : NgoCauses


  type NgoCausesCountArgs = 
    Omit<NgoCausesFindManyArgs, 'select' | 'include'> & {
      select?: NgoCausesCountAggregateInputType | true
    }

  export interface NgoCausesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NgoCauses that matches the filter.
     * @param {NgoCausesFindUniqueArgs} args - Arguments to find a NgoCauses
     * @example
     * // Get one NgoCauses
     * const ngoCauses = await prisma.ngoCauses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NgoCausesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NgoCausesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NgoCauses'> extends True ? Prisma__NgoCausesClient<NgoCausesGetPayload<T>> : Prisma__NgoCausesClient<NgoCausesGetPayload<T> | null, null>

    /**
     * Find one NgoCauses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NgoCausesFindUniqueOrThrowArgs} args - Arguments to find a NgoCauses
     * @example
     * // Get one NgoCauses
     * const ngoCauses = await prisma.ngoCauses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NgoCausesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NgoCausesFindUniqueOrThrowArgs>
    ): Prisma__NgoCausesClient<NgoCausesGetPayload<T>>

    /**
     * Find the first NgoCauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesFindFirstArgs} args - Arguments to find a NgoCauses
     * @example
     * // Get one NgoCauses
     * const ngoCauses = await prisma.ngoCauses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NgoCausesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NgoCausesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NgoCauses'> extends True ? Prisma__NgoCausesClient<NgoCausesGetPayload<T>> : Prisma__NgoCausesClient<NgoCausesGetPayload<T> | null, null>

    /**
     * Find the first NgoCauses that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesFindFirstOrThrowArgs} args - Arguments to find a NgoCauses
     * @example
     * // Get one NgoCauses
     * const ngoCauses = await prisma.ngoCauses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NgoCausesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NgoCausesFindFirstOrThrowArgs>
    ): Prisma__NgoCausesClient<NgoCausesGetPayload<T>>

    /**
     * Find zero or more NgoCauses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NgoCauses
     * const ngoCauses = await prisma.ngoCauses.findMany()
     * 
     * // Get first 10 NgoCauses
     * const ngoCauses = await prisma.ngoCauses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ngoCausesWithIdOnly = await prisma.ngoCauses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NgoCausesFindManyArgs>(
      args?: SelectSubset<T, NgoCausesFindManyArgs>
    ): Prisma.PrismaPromise<Array<NgoCausesGetPayload<T>>>

    /**
     * Create a NgoCauses.
     * @param {NgoCausesCreateArgs} args - Arguments to create a NgoCauses.
     * @example
     * // Create one NgoCauses
     * const NgoCauses = await prisma.ngoCauses.create({
     *   data: {
     *     // ... data to create a NgoCauses
     *   }
     * })
     * 
    **/
    create<T extends NgoCausesCreateArgs>(
      args: SelectSubset<T, NgoCausesCreateArgs>
    ): Prisma__NgoCausesClient<NgoCausesGetPayload<T>>

    /**
     * Create many NgoCauses.
     *     @param {NgoCausesCreateManyArgs} args - Arguments to create many NgoCauses.
     *     @example
     *     // Create many NgoCauses
     *     const ngoCauses = await prisma.ngoCauses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NgoCausesCreateManyArgs>(
      args?: SelectSubset<T, NgoCausesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NgoCauses.
     * @param {NgoCausesDeleteArgs} args - Arguments to delete one NgoCauses.
     * @example
     * // Delete one NgoCauses
     * const NgoCauses = await prisma.ngoCauses.delete({
     *   where: {
     *     // ... filter to delete one NgoCauses
     *   }
     * })
     * 
    **/
    delete<T extends NgoCausesDeleteArgs>(
      args: SelectSubset<T, NgoCausesDeleteArgs>
    ): Prisma__NgoCausesClient<NgoCausesGetPayload<T>>

    /**
     * Update one NgoCauses.
     * @param {NgoCausesUpdateArgs} args - Arguments to update one NgoCauses.
     * @example
     * // Update one NgoCauses
     * const ngoCauses = await prisma.ngoCauses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NgoCausesUpdateArgs>(
      args: SelectSubset<T, NgoCausesUpdateArgs>
    ): Prisma__NgoCausesClient<NgoCausesGetPayload<T>>

    /**
     * Delete zero or more NgoCauses.
     * @param {NgoCausesDeleteManyArgs} args - Arguments to filter NgoCauses to delete.
     * @example
     * // Delete a few NgoCauses
     * const { count } = await prisma.ngoCauses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NgoCausesDeleteManyArgs>(
      args?: SelectSubset<T, NgoCausesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NgoCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NgoCauses
     * const ngoCauses = await prisma.ngoCauses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NgoCausesUpdateManyArgs>(
      args: SelectSubset<T, NgoCausesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NgoCauses.
     * @param {NgoCausesUpsertArgs} args - Arguments to update or create a NgoCauses.
     * @example
     * // Update or create a NgoCauses
     * const ngoCauses = await prisma.ngoCauses.upsert({
     *   create: {
     *     // ... data to create a NgoCauses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NgoCauses we want to update
     *   }
     * })
    **/
    upsert<T extends NgoCausesUpsertArgs>(
      args: SelectSubset<T, NgoCausesUpsertArgs>
    ): Prisma__NgoCausesClient<NgoCausesGetPayload<T>>

    /**
     * Count the number of NgoCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesCountArgs} args - Arguments to filter NgoCauses to count.
     * @example
     * // Count the number of NgoCauses
     * const count = await prisma.ngoCauses.count({
     *   where: {
     *     // ... the filter for the NgoCauses we want to count
     *   }
     * })
    **/
    count<T extends NgoCausesCountArgs>(
      args?: Subset<T, NgoCausesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NgoCausesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NgoCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NgoCausesAggregateArgs>(args: Subset<T, NgoCausesAggregateArgs>): Prisma.PrismaPromise<GetNgoCausesAggregateType<T>>

    /**
     * Group by NgoCauses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoCausesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NgoCausesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NgoCausesGroupByArgs['orderBy'] }
        : { orderBy?: NgoCausesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NgoCausesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNgoCausesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NgoCauses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NgoCausesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    causes<T extends CausesArgs= {}>(args?: Subset<T, CausesArgs>): Prisma__CausesClient<CausesGetPayload<T> | Null>;

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NgoCauses base type for findUnique actions
   */
  export type NgoCausesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * Filter, which NgoCauses to fetch.
     */
    where: NgoCausesWhereUniqueInput
  }

  /**
   * NgoCauses findUnique
   */
  export interface NgoCausesFindUniqueArgs extends NgoCausesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NgoCauses findUniqueOrThrow
   */
  export type NgoCausesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * Filter, which NgoCauses to fetch.
     */
    where: NgoCausesWhereUniqueInput
  }


  /**
   * NgoCauses base type for findFirst actions
   */
  export type NgoCausesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * Filter, which NgoCauses to fetch.
     */
    where?: NgoCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoCauses to fetch.
     */
    orderBy?: Enumerable<NgoCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NgoCauses.
     */
    cursor?: NgoCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoCauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NgoCauses.
     */
    distinct?: Enumerable<NgoCausesScalarFieldEnum>
  }

  /**
   * NgoCauses findFirst
   */
  export interface NgoCausesFindFirstArgs extends NgoCausesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NgoCauses findFirstOrThrow
   */
  export type NgoCausesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * Filter, which NgoCauses to fetch.
     */
    where?: NgoCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoCauses to fetch.
     */
    orderBy?: Enumerable<NgoCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NgoCauses.
     */
    cursor?: NgoCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoCauses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NgoCauses.
     */
    distinct?: Enumerable<NgoCausesScalarFieldEnum>
  }


  /**
   * NgoCauses findMany
   */
  export type NgoCausesFindManyArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * Filter, which NgoCauses to fetch.
     */
    where?: NgoCausesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoCauses to fetch.
     */
    orderBy?: Enumerable<NgoCausesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NgoCauses.
     */
    cursor?: NgoCausesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoCauses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoCauses.
     */
    skip?: number
    distinct?: Enumerable<NgoCausesScalarFieldEnum>
  }


  /**
   * NgoCauses create
   */
  export type NgoCausesCreateArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * The data needed to create a NgoCauses.
     */
    data: XOR<NgoCausesCreateInput, NgoCausesUncheckedCreateInput>
  }


  /**
   * NgoCauses createMany
   */
  export type NgoCausesCreateManyArgs = {
    /**
     * The data used to create many NgoCauses.
     */
    data: Enumerable<NgoCausesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NgoCauses update
   */
  export type NgoCausesUpdateArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * The data needed to update a NgoCauses.
     */
    data: XOR<NgoCausesUpdateInput, NgoCausesUncheckedUpdateInput>
    /**
     * Choose, which NgoCauses to update.
     */
    where: NgoCausesWhereUniqueInput
  }


  /**
   * NgoCauses updateMany
   */
  export type NgoCausesUpdateManyArgs = {
    /**
     * The data used to update NgoCauses.
     */
    data: XOR<NgoCausesUpdateManyMutationInput, NgoCausesUncheckedUpdateManyInput>
    /**
     * Filter which NgoCauses to update
     */
    where?: NgoCausesWhereInput
  }


  /**
   * NgoCauses upsert
   */
  export type NgoCausesUpsertArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * The filter to search for the NgoCauses to update in case it exists.
     */
    where: NgoCausesWhereUniqueInput
    /**
     * In case the NgoCauses found by the `where` argument doesn't exist, create a new NgoCauses with this data.
     */
    create: XOR<NgoCausesCreateInput, NgoCausesUncheckedCreateInput>
    /**
     * In case the NgoCauses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NgoCausesUpdateInput, NgoCausesUncheckedUpdateInput>
  }


  /**
   * NgoCauses delete
   */
  export type NgoCausesDeleteArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
    /**
     * Filter which NgoCauses to delete.
     */
    where: NgoCausesWhereUniqueInput
  }


  /**
   * NgoCauses deleteMany
   */
  export type NgoCausesDeleteManyArgs = {
    /**
     * Filter which NgoCauses to delete
     */
    where?: NgoCausesWhereInput
  }


  /**
   * NgoCauses without action
   */
  export type NgoCausesArgs = {
    /**
     * Select specific fields to fetch from the NgoCauses
     */
    select?: NgoCausesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoCausesInclude | null
  }



  /**
   * Model NgoPhone
   */


  export type AggregateNgoPhone = {
    _count: NgoPhoneCountAggregateOutputType | null
    _min: NgoPhoneMinAggregateOutputType | null
    _max: NgoPhoneMaxAggregateOutputType | null
  }

  export type NgoPhoneMinAggregateOutputType = {
    id: string | null
    id_ngo: string | null
    id_phone: string | null
  }

  export type NgoPhoneMaxAggregateOutputType = {
    id: string | null
    id_ngo: string | null
    id_phone: string | null
  }

  export type NgoPhoneCountAggregateOutputType = {
    id: number
    id_ngo: number
    id_phone: number
    _all: number
  }


  export type NgoPhoneMinAggregateInputType = {
    id?: true
    id_ngo?: true
    id_phone?: true
  }

  export type NgoPhoneMaxAggregateInputType = {
    id?: true
    id_ngo?: true
    id_phone?: true
  }

  export type NgoPhoneCountAggregateInputType = {
    id?: true
    id_ngo?: true
    id_phone?: true
    _all?: true
  }

  export type NgoPhoneAggregateArgs = {
    /**
     * Filter which NgoPhone to aggregate.
     */
    where?: NgoPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoPhones to fetch.
     */
    orderBy?: Enumerable<NgoPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NgoPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NgoPhones
    **/
    _count?: true | NgoPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NgoPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NgoPhoneMaxAggregateInputType
  }

  export type GetNgoPhoneAggregateType<T extends NgoPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateNgoPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNgoPhone[P]>
      : GetScalarType<T[P], AggregateNgoPhone[P]>
  }




  export type NgoPhoneGroupByArgs = {
    where?: NgoPhoneWhereInput
    orderBy?: Enumerable<NgoPhoneOrderByWithAggregationInput>
    by: NgoPhoneScalarFieldEnum[]
    having?: NgoPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NgoPhoneCountAggregateInputType | true
    _min?: NgoPhoneMinAggregateInputType
    _max?: NgoPhoneMaxAggregateInputType
  }


  export type NgoPhoneGroupByOutputType = {
    id: string
    id_ngo: string
    id_phone: string
    _count: NgoPhoneCountAggregateOutputType | null
    _min: NgoPhoneMinAggregateOutputType | null
    _max: NgoPhoneMaxAggregateOutputType | null
  }

  type GetNgoPhoneGroupByPayload<T extends NgoPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NgoPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NgoPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NgoPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], NgoPhoneGroupByOutputType[P]>
        }
      >
    >


  export type NgoPhoneSelect = {
    id?: boolean
    id_ngo?: boolean
    id_phone?: boolean
    ngo?: boolean | NGOArgs
    phone?: boolean | PhoneArgs
  }


  export type NgoPhoneInclude = {
    ngo?: boolean | NGOArgs
    phone?: boolean | PhoneArgs
  }

  export type NgoPhoneGetPayload<S extends boolean | null | undefined | NgoPhoneArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? NgoPhone :
    S extends undefined ? never :
    S extends { include: any } & (NgoPhoneArgs | NgoPhoneFindManyArgs)
    ? NgoPhone  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :
        P extends 'phone' ? PhoneGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (NgoPhoneArgs | NgoPhoneFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :
        P extends 'phone' ? PhoneGetPayload<S['select'][P]> :  P extends keyof NgoPhone ? NgoPhone[P] : never
  } 
      : NgoPhone


  type NgoPhoneCountArgs = 
    Omit<NgoPhoneFindManyArgs, 'select' | 'include'> & {
      select?: NgoPhoneCountAggregateInputType | true
    }

  export interface NgoPhoneDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one NgoPhone that matches the filter.
     * @param {NgoPhoneFindUniqueArgs} args - Arguments to find a NgoPhone
     * @example
     * // Get one NgoPhone
     * const ngoPhone = await prisma.ngoPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NgoPhoneFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NgoPhoneFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NgoPhone'> extends True ? Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>> : Prisma__NgoPhoneClient<NgoPhoneGetPayload<T> | null, null>

    /**
     * Find one NgoPhone that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NgoPhoneFindUniqueOrThrowArgs} args - Arguments to find a NgoPhone
     * @example
     * // Get one NgoPhone
     * const ngoPhone = await prisma.ngoPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NgoPhoneFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NgoPhoneFindUniqueOrThrowArgs>
    ): Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>>

    /**
     * Find the first NgoPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneFindFirstArgs} args - Arguments to find a NgoPhone
     * @example
     * // Get one NgoPhone
     * const ngoPhone = await prisma.ngoPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NgoPhoneFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NgoPhoneFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NgoPhone'> extends True ? Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>> : Prisma__NgoPhoneClient<NgoPhoneGetPayload<T> | null, null>

    /**
     * Find the first NgoPhone that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneFindFirstOrThrowArgs} args - Arguments to find a NgoPhone
     * @example
     * // Get one NgoPhone
     * const ngoPhone = await prisma.ngoPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NgoPhoneFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NgoPhoneFindFirstOrThrowArgs>
    ): Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>>

    /**
     * Find zero or more NgoPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NgoPhones
     * const ngoPhones = await prisma.ngoPhone.findMany()
     * 
     * // Get first 10 NgoPhones
     * const ngoPhones = await prisma.ngoPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ngoPhoneWithIdOnly = await prisma.ngoPhone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NgoPhoneFindManyArgs>(
      args?: SelectSubset<T, NgoPhoneFindManyArgs>
    ): Prisma.PrismaPromise<Array<NgoPhoneGetPayload<T>>>

    /**
     * Create a NgoPhone.
     * @param {NgoPhoneCreateArgs} args - Arguments to create a NgoPhone.
     * @example
     * // Create one NgoPhone
     * const NgoPhone = await prisma.ngoPhone.create({
     *   data: {
     *     // ... data to create a NgoPhone
     *   }
     * })
     * 
    **/
    create<T extends NgoPhoneCreateArgs>(
      args: SelectSubset<T, NgoPhoneCreateArgs>
    ): Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>>

    /**
     * Create many NgoPhones.
     *     @param {NgoPhoneCreateManyArgs} args - Arguments to create many NgoPhones.
     *     @example
     *     // Create many NgoPhones
     *     const ngoPhone = await prisma.ngoPhone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NgoPhoneCreateManyArgs>(
      args?: SelectSubset<T, NgoPhoneCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NgoPhone.
     * @param {NgoPhoneDeleteArgs} args - Arguments to delete one NgoPhone.
     * @example
     * // Delete one NgoPhone
     * const NgoPhone = await prisma.ngoPhone.delete({
     *   where: {
     *     // ... filter to delete one NgoPhone
     *   }
     * })
     * 
    **/
    delete<T extends NgoPhoneDeleteArgs>(
      args: SelectSubset<T, NgoPhoneDeleteArgs>
    ): Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>>

    /**
     * Update one NgoPhone.
     * @param {NgoPhoneUpdateArgs} args - Arguments to update one NgoPhone.
     * @example
     * // Update one NgoPhone
     * const ngoPhone = await prisma.ngoPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NgoPhoneUpdateArgs>(
      args: SelectSubset<T, NgoPhoneUpdateArgs>
    ): Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>>

    /**
     * Delete zero or more NgoPhones.
     * @param {NgoPhoneDeleteManyArgs} args - Arguments to filter NgoPhones to delete.
     * @example
     * // Delete a few NgoPhones
     * const { count } = await prisma.ngoPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NgoPhoneDeleteManyArgs>(
      args?: SelectSubset<T, NgoPhoneDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NgoPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NgoPhones
     * const ngoPhone = await prisma.ngoPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NgoPhoneUpdateManyArgs>(
      args: SelectSubset<T, NgoPhoneUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NgoPhone.
     * @param {NgoPhoneUpsertArgs} args - Arguments to update or create a NgoPhone.
     * @example
     * // Update or create a NgoPhone
     * const ngoPhone = await prisma.ngoPhone.upsert({
     *   create: {
     *     // ... data to create a NgoPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NgoPhone we want to update
     *   }
     * })
    **/
    upsert<T extends NgoPhoneUpsertArgs>(
      args: SelectSubset<T, NgoPhoneUpsertArgs>
    ): Prisma__NgoPhoneClient<NgoPhoneGetPayload<T>>

    /**
     * Count the number of NgoPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneCountArgs} args - Arguments to filter NgoPhones to count.
     * @example
     * // Count the number of NgoPhones
     * const count = await prisma.ngoPhone.count({
     *   where: {
     *     // ... the filter for the NgoPhones we want to count
     *   }
     * })
    **/
    count<T extends NgoPhoneCountArgs>(
      args?: Subset<T, NgoPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NgoPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NgoPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NgoPhoneAggregateArgs>(args: Subset<T, NgoPhoneAggregateArgs>): Prisma.PrismaPromise<GetNgoPhoneAggregateType<T>>

    /**
     * Group by NgoPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NgoPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NgoPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NgoPhoneGroupByArgs['orderBy'] }
        : { orderBy?: NgoPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NgoPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNgoPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for NgoPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NgoPhoneClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    phone<T extends PhoneArgs= {}>(args?: Subset<T, PhoneArgs>): Prisma__PhoneClient<PhoneGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * NgoPhone base type for findUnique actions
   */
  export type NgoPhoneFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * Filter, which NgoPhone to fetch.
     */
    where: NgoPhoneWhereUniqueInput
  }

  /**
   * NgoPhone findUnique
   */
  export interface NgoPhoneFindUniqueArgs extends NgoPhoneFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NgoPhone findUniqueOrThrow
   */
  export type NgoPhoneFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * Filter, which NgoPhone to fetch.
     */
    where: NgoPhoneWhereUniqueInput
  }


  /**
   * NgoPhone base type for findFirst actions
   */
  export type NgoPhoneFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * Filter, which NgoPhone to fetch.
     */
    where?: NgoPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoPhones to fetch.
     */
    orderBy?: Enumerable<NgoPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NgoPhones.
     */
    cursor?: NgoPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NgoPhones.
     */
    distinct?: Enumerable<NgoPhoneScalarFieldEnum>
  }

  /**
   * NgoPhone findFirst
   */
  export interface NgoPhoneFindFirstArgs extends NgoPhoneFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * NgoPhone findFirstOrThrow
   */
  export type NgoPhoneFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * Filter, which NgoPhone to fetch.
     */
    where?: NgoPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoPhones to fetch.
     */
    orderBy?: Enumerable<NgoPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NgoPhones.
     */
    cursor?: NgoPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NgoPhones.
     */
    distinct?: Enumerable<NgoPhoneScalarFieldEnum>
  }


  /**
   * NgoPhone findMany
   */
  export type NgoPhoneFindManyArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * Filter, which NgoPhones to fetch.
     */
    where?: NgoPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NgoPhones to fetch.
     */
    orderBy?: Enumerable<NgoPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NgoPhones.
     */
    cursor?: NgoPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NgoPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NgoPhones.
     */
    skip?: number
    distinct?: Enumerable<NgoPhoneScalarFieldEnum>
  }


  /**
   * NgoPhone create
   */
  export type NgoPhoneCreateArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * The data needed to create a NgoPhone.
     */
    data: XOR<NgoPhoneCreateInput, NgoPhoneUncheckedCreateInput>
  }


  /**
   * NgoPhone createMany
   */
  export type NgoPhoneCreateManyArgs = {
    /**
     * The data used to create many NgoPhones.
     */
    data: Enumerable<NgoPhoneCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NgoPhone update
   */
  export type NgoPhoneUpdateArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * The data needed to update a NgoPhone.
     */
    data: XOR<NgoPhoneUpdateInput, NgoPhoneUncheckedUpdateInput>
    /**
     * Choose, which NgoPhone to update.
     */
    where: NgoPhoneWhereUniqueInput
  }


  /**
   * NgoPhone updateMany
   */
  export type NgoPhoneUpdateManyArgs = {
    /**
     * The data used to update NgoPhones.
     */
    data: XOR<NgoPhoneUpdateManyMutationInput, NgoPhoneUncheckedUpdateManyInput>
    /**
     * Filter which NgoPhones to update
     */
    where?: NgoPhoneWhereInput
  }


  /**
   * NgoPhone upsert
   */
  export type NgoPhoneUpsertArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * The filter to search for the NgoPhone to update in case it exists.
     */
    where: NgoPhoneWhereUniqueInput
    /**
     * In case the NgoPhone found by the `where` argument doesn't exist, create a new NgoPhone with this data.
     */
    create: XOR<NgoPhoneCreateInput, NgoPhoneUncheckedCreateInput>
    /**
     * In case the NgoPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NgoPhoneUpdateInput, NgoPhoneUncheckedUpdateInput>
  }


  /**
   * NgoPhone delete
   */
  export type NgoPhoneDeleteArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
    /**
     * Filter which NgoPhone to delete.
     */
    where: NgoPhoneWhereUniqueInput
  }


  /**
   * NgoPhone deleteMany
   */
  export type NgoPhoneDeleteManyArgs = {
    /**
     * Filter which NgoPhones to delete
     */
    where?: NgoPhoneWhereInput
  }


  /**
   * NgoPhone without action
   */
  export type NgoPhoneArgs = {
    /**
     * Select specific fields to fetch from the NgoPhone
     */
    select?: NgoPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NgoPhoneInclude | null
  }



  /**
   * Model UserPhone
   */


  export type AggregateUserPhone = {
    _count: UserPhoneCountAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  export type UserPhoneMinAggregateOutputType = {
    id: string | null
    id_phone: string | null
    id_user: string | null
  }

  export type UserPhoneMaxAggregateOutputType = {
    id: string | null
    id_phone: string | null
    id_user: string | null
  }

  export type UserPhoneCountAggregateOutputType = {
    id: number
    id_phone: number
    id_user: number
    _all: number
  }


  export type UserPhoneMinAggregateInputType = {
    id?: true
    id_phone?: true
    id_user?: true
  }

  export type UserPhoneMaxAggregateInputType = {
    id?: true
    id_phone?: true
    id_user?: true
  }

  export type UserPhoneCountAggregateInputType = {
    id?: true
    id_phone?: true
    id_user?: true
    _all?: true
  }

  export type UserPhoneAggregateArgs = {
    /**
     * Filter which UserPhone to aggregate.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: Enumerable<UserPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPhones
    **/
    _count?: true | UserPhoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPhoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPhoneMaxAggregateInputType
  }

  export type GetUserPhoneAggregateType<T extends UserPhoneAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPhone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPhone[P]>
      : GetScalarType<T[P], AggregateUserPhone[P]>
  }




  export type UserPhoneGroupByArgs = {
    where?: UserPhoneWhereInput
    orderBy?: Enumerable<UserPhoneOrderByWithAggregationInput>
    by: UserPhoneScalarFieldEnum[]
    having?: UserPhoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPhoneCountAggregateInputType | true
    _min?: UserPhoneMinAggregateInputType
    _max?: UserPhoneMaxAggregateInputType
  }


  export type UserPhoneGroupByOutputType = {
    id: string
    id_phone: string
    id_user: string
    _count: UserPhoneCountAggregateOutputType | null
    _min: UserPhoneMinAggregateOutputType | null
    _max: UserPhoneMaxAggregateOutputType | null
  }

  type GetUserPhoneGroupByPayload<T extends UserPhoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserPhoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPhoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
            : GetScalarType<T[P], UserPhoneGroupByOutputType[P]>
        }
      >
    >


  export type UserPhoneSelect = {
    id?: boolean
    id_phone?: boolean
    id_user?: boolean
    phone?: boolean | PhoneArgs
    user?: boolean | UserArgs
  }


  export type UserPhoneInclude = {
    phone?: boolean | PhoneArgs
    user?: boolean | UserArgs
  }

  export type UserPhoneGetPayload<S extends boolean | null | undefined | UserPhoneArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserPhone :
    S extends undefined ? never :
    S extends { include: any } & (UserPhoneArgs | UserPhoneFindManyArgs)
    ? UserPhone  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'phone' ? PhoneGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserPhoneArgs | UserPhoneFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'phone' ? PhoneGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof UserPhone ? UserPhone[P] : never
  } 
      : UserPhone


  type UserPhoneCountArgs = 
    Omit<UserPhoneFindManyArgs, 'select' | 'include'> & {
      select?: UserPhoneCountAggregateInputType | true
    }

  export interface UserPhoneDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one UserPhone that matches the filter.
     * @param {UserPhoneFindUniqueArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPhoneFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserPhoneFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserPhone'> extends True ? Prisma__UserPhoneClient<UserPhoneGetPayload<T>> : Prisma__UserPhoneClient<UserPhoneGetPayload<T> | null, null>

    /**
     * Find one UserPhone that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPhoneFindUniqueOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPhoneFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserPhoneFindUniqueOrThrowArgs>
    ): Prisma__UserPhoneClient<UserPhoneGetPayload<T>>

    /**
     * Find the first UserPhone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPhoneFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserPhoneFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserPhone'> extends True ? Prisma__UserPhoneClient<UserPhoneGetPayload<T>> : Prisma__UserPhoneClient<UserPhoneGetPayload<T> | null, null>

    /**
     * Find the first UserPhone that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindFirstOrThrowArgs} args - Arguments to find a UserPhone
     * @example
     * // Get one UserPhone
     * const userPhone = await prisma.userPhone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPhoneFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserPhoneFindFirstOrThrowArgs>
    ): Prisma__UserPhoneClient<UserPhoneGetPayload<T>>

    /**
     * Find zero or more UserPhones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPhones
     * const userPhones = await prisma.userPhone.findMany()
     * 
     * // Get first 10 UserPhones
     * const userPhones = await prisma.userPhone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPhoneWithIdOnly = await prisma.userPhone.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPhoneFindManyArgs>(
      args?: SelectSubset<T, UserPhoneFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserPhoneGetPayload<T>>>

    /**
     * Create a UserPhone.
     * @param {UserPhoneCreateArgs} args - Arguments to create a UserPhone.
     * @example
     * // Create one UserPhone
     * const UserPhone = await prisma.userPhone.create({
     *   data: {
     *     // ... data to create a UserPhone
     *   }
     * })
     * 
    **/
    create<T extends UserPhoneCreateArgs>(
      args: SelectSubset<T, UserPhoneCreateArgs>
    ): Prisma__UserPhoneClient<UserPhoneGetPayload<T>>

    /**
     * Create many UserPhones.
     *     @param {UserPhoneCreateManyArgs} args - Arguments to create many UserPhones.
     *     @example
     *     // Create many UserPhones
     *     const userPhone = await prisma.userPhone.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPhoneCreateManyArgs>(
      args?: SelectSubset<T, UserPhoneCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPhone.
     * @param {UserPhoneDeleteArgs} args - Arguments to delete one UserPhone.
     * @example
     * // Delete one UserPhone
     * const UserPhone = await prisma.userPhone.delete({
     *   where: {
     *     // ... filter to delete one UserPhone
     *   }
     * })
     * 
    **/
    delete<T extends UserPhoneDeleteArgs>(
      args: SelectSubset<T, UserPhoneDeleteArgs>
    ): Prisma__UserPhoneClient<UserPhoneGetPayload<T>>

    /**
     * Update one UserPhone.
     * @param {UserPhoneUpdateArgs} args - Arguments to update one UserPhone.
     * @example
     * // Update one UserPhone
     * const userPhone = await prisma.userPhone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPhoneUpdateArgs>(
      args: SelectSubset<T, UserPhoneUpdateArgs>
    ): Prisma__UserPhoneClient<UserPhoneGetPayload<T>>

    /**
     * Delete zero or more UserPhones.
     * @param {UserPhoneDeleteManyArgs} args - Arguments to filter UserPhones to delete.
     * @example
     * // Delete a few UserPhones
     * const { count } = await prisma.userPhone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPhoneDeleteManyArgs>(
      args?: SelectSubset<T, UserPhoneDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPhones
     * const userPhone = await prisma.userPhone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPhoneUpdateManyArgs>(
      args: SelectSubset<T, UserPhoneUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPhone.
     * @param {UserPhoneUpsertArgs} args - Arguments to update or create a UserPhone.
     * @example
     * // Update or create a UserPhone
     * const userPhone = await prisma.userPhone.upsert({
     *   create: {
     *     // ... data to create a UserPhone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPhone we want to update
     *   }
     * })
    **/
    upsert<T extends UserPhoneUpsertArgs>(
      args: SelectSubset<T, UserPhoneUpsertArgs>
    ): Prisma__UserPhoneClient<UserPhoneGetPayload<T>>

    /**
     * Count the number of UserPhones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneCountArgs} args - Arguments to filter UserPhones to count.
     * @example
     * // Count the number of UserPhones
     * const count = await prisma.userPhone.count({
     *   where: {
     *     // ... the filter for the UserPhones we want to count
     *   }
     * })
    **/
    count<T extends UserPhoneCountArgs>(
      args?: Subset<T, UserPhoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPhoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPhoneAggregateArgs>(args: Subset<T, UserPhoneAggregateArgs>): Prisma.PrismaPromise<GetUserPhoneAggregateType<T>>

    /**
     * Group by UserPhone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPhoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPhoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPhoneGroupByArgs['orderBy'] }
        : { orderBy?: UserPhoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPhoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPhoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPhoneClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    phone<T extends PhoneArgs= {}>(args?: Subset<T, PhoneArgs>): Prisma__PhoneClient<PhoneGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserPhone base type for findUnique actions
   */
  export type UserPhoneFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }

  /**
   * UserPhone findUnique
   */
  export interface UserPhoneFindUniqueArgs extends UserPhoneFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserPhone findUniqueOrThrow
   */
  export type UserPhoneFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where: UserPhoneWhereUniqueInput
  }


  /**
   * UserPhone base type for findFirst actions
   */
  export type UserPhoneFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: Enumerable<UserPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: Enumerable<UserPhoneScalarFieldEnum>
  }

  /**
   * UserPhone findFirst
   */
  export interface UserPhoneFindFirstArgs extends UserPhoneFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserPhone findFirstOrThrow
   */
  export type UserPhoneFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * Filter, which UserPhone to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: Enumerable<UserPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPhones.
     */
    distinct?: Enumerable<UserPhoneScalarFieldEnum>
  }


  /**
   * UserPhone findMany
   */
  export type UserPhoneFindManyArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * Filter, which UserPhones to fetch.
     */
    where?: UserPhoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPhones to fetch.
     */
    orderBy?: Enumerable<UserPhoneOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPhones.
     */
    cursor?: UserPhoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPhones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPhones.
     */
    skip?: number
    distinct?: Enumerable<UserPhoneScalarFieldEnum>
  }


  /**
   * UserPhone create
   */
  export type UserPhoneCreateArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * The data needed to create a UserPhone.
     */
    data: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
  }


  /**
   * UserPhone createMany
   */
  export type UserPhoneCreateManyArgs = {
    /**
     * The data used to create many UserPhones.
     */
    data: Enumerable<UserPhoneCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserPhone update
   */
  export type UserPhoneUpdateArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * The data needed to update a UserPhone.
     */
    data: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
    /**
     * Choose, which UserPhone to update.
     */
    where: UserPhoneWhereUniqueInput
  }


  /**
   * UserPhone updateMany
   */
  export type UserPhoneUpdateManyArgs = {
    /**
     * The data used to update UserPhones.
     */
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyInput>
    /**
     * Filter which UserPhones to update
     */
    where?: UserPhoneWhereInput
  }


  /**
   * UserPhone upsert
   */
  export type UserPhoneUpsertArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * The filter to search for the UserPhone to update in case it exists.
     */
    where: UserPhoneWhereUniqueInput
    /**
     * In case the UserPhone found by the `where` argument doesn't exist, create a new UserPhone with this data.
     */
    create: XOR<UserPhoneCreateInput, UserPhoneUncheckedCreateInput>
    /**
     * In case the UserPhone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPhoneUpdateInput, UserPhoneUncheckedUpdateInput>
  }


  /**
   * UserPhone delete
   */
  export type UserPhoneDeleteArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
    /**
     * Filter which UserPhone to delete.
     */
    where: UserPhoneWhereUniqueInput
  }


  /**
   * UserPhone deleteMany
   */
  export type UserPhoneDeleteManyArgs = {
    /**
     * Filter which UserPhones to delete
     */
    where?: UserPhoneWhereInput
  }


  /**
   * UserPhone without action
   */
  export type UserPhoneArgs = {
    /**
     * Select specific fields to fetch from the UserPhone
     */
    select?: UserPhoneSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPhoneInclude | null
  }



  /**
   * Model Type
   */


  export type AggregateType = {
    _count: TypeCountAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  export type TypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TypeAggregateArgs = {
    /**
     * Filter which Type to aggregate.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: Enumerable<TypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Types
    **/
    _count?: true | TypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeMaxAggregateInputType
  }

  export type GetTypeAggregateType<T extends TypeAggregateArgs> = {
        [P in keyof T & keyof AggregateType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType[P]>
      : GetScalarType<T[P], AggregateType[P]>
  }




  export type TypeGroupByArgs = {
    where?: TypeWhereInput
    orderBy?: Enumerable<TypeOrderByWithAggregationInput>
    by: TypeScalarFieldEnum[]
    having?: TypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCountAggregateInputType | true
    _min?: TypeMinAggregateInputType
    _max?: TypeMaxAggregateInputType
  }


  export type TypeGroupByOutputType = {
    id: string
    name: string
    _count: TypeCountAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  type GetTypeGroupByPayload<T extends TypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeGroupByOutputType[P]>
            : GetScalarType<T[P], TypeGroupByOutputType[P]>
        }
      >
    >


  export type TypeSelect = {
    id?: boolean
    name?: boolean
    ngo?: boolean | Type$ngoArgs
    user?: boolean | Type$userArgs
    _count?: boolean | TypeCountOutputTypeArgs
  }


  export type TypeInclude = {
    ngo?: boolean | Type$ngoArgs
    user?: boolean | Type$userArgs
    _count?: boolean | TypeCountOutputTypeArgs
  }

  export type TypeGetPayload<S extends boolean | null | undefined | TypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Type :
    S extends undefined ? never :
    S extends { include: any } & (TypeArgs | TypeFindManyArgs)
    ? Type  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo' ? Array < NGOGetPayload<S['include'][P]>>  :
        P extends 'user' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends '_count' ? TypeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TypeArgs | TypeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo' ? Array < NGOGetPayload<S['select'][P]>>  :
        P extends 'user' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends '_count' ? TypeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Type ? Type[P] : never
  } 
      : Type


  type TypeCountArgs = 
    Omit<TypeFindManyArgs, 'select' | 'include'> & {
      select?: TypeCountAggregateInputType | true
    }

  export interface TypeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Type that matches the filter.
     * @param {TypeFindUniqueArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Type'> extends True ? Prisma__TypeClient<TypeGetPayload<T>> : Prisma__TypeClient<TypeGetPayload<T> | null, null>

    /**
     * Find one Type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypeFindUniqueOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TypeFindUniqueOrThrowArgs>
    ): Prisma__TypeClient<TypeGetPayload<T>>

    /**
     * Find the first Type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Type'> extends True ? Prisma__TypeClient<TypeGetPayload<T>> : Prisma__TypeClient<TypeGetPayload<T> | null, null>

    /**
     * Find the first Type that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TypeFindFirstOrThrowArgs>
    ): Prisma__TypeClient<TypeGetPayload<T>>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.type.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeWithIdOnly = await prisma.type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypeFindManyArgs>(
      args?: SelectSubset<T, TypeFindManyArgs>
    ): Prisma.PrismaPromise<Array<TypeGetPayload<T>>>

    /**
     * Create a Type.
     * @param {TypeCreateArgs} args - Arguments to create a Type.
     * @example
     * // Create one Type
     * const Type = await prisma.type.create({
     *   data: {
     *     // ... data to create a Type
     *   }
     * })
     * 
    **/
    create<T extends TypeCreateArgs>(
      args: SelectSubset<T, TypeCreateArgs>
    ): Prisma__TypeClient<TypeGetPayload<T>>

    /**
     * Create many Types.
     *     @param {TypeCreateManyArgs} args - Arguments to create many Types.
     *     @example
     *     // Create many Types
     *     const type = await prisma.type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeCreateManyArgs>(
      args?: SelectSubset<T, TypeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Type.
     * @param {TypeDeleteArgs} args - Arguments to delete one Type.
     * @example
     * // Delete one Type
     * const Type = await prisma.type.delete({
     *   where: {
     *     // ... filter to delete one Type
     *   }
     * })
     * 
    **/
    delete<T extends TypeDeleteArgs>(
      args: SelectSubset<T, TypeDeleteArgs>
    ): Prisma__TypeClient<TypeGetPayload<T>>

    /**
     * Update one Type.
     * @param {TypeUpdateArgs} args - Arguments to update one Type.
     * @example
     * // Update one Type
     * const type = await prisma.type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeUpdateArgs>(
      args: SelectSubset<T, TypeUpdateArgs>
    ): Prisma__TypeClient<TypeGetPayload<T>>

    /**
     * Delete zero or more Types.
     * @param {TypeDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeDeleteManyArgs>(
      args?: SelectSubset<T, TypeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeUpdateManyArgs>(
      args: SelectSubset<T, TypeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Type.
     * @param {TypeUpsertArgs} args - Arguments to update or create a Type.
     * @example
     * // Update or create a Type
     * const type = await prisma.type.upsert({
     *   create: {
     *     // ... data to create a Type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type we want to update
     *   }
     * })
    **/
    upsert<T extends TypeUpsertArgs>(
      args: SelectSubset<T, TypeUpsertArgs>
    ): Prisma__TypeClient<TypeGetPayload<T>>

    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.type.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends TypeCountArgs>(
      args?: Subset<T, TypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeAggregateArgs>(args: Subset<T, TypeAggregateArgs>): Prisma.PrismaPromise<GetTypeAggregateType<T>>

    /**
     * Group by Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeGroupByArgs['orderBy'] }
        : { orderBy?: TypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo<T extends Type$ngoArgs= {}>(args?: Subset<T, Type$ngoArgs>): Prisma.PrismaPromise<Array<NGOGetPayload<T>>| Null>;

    user<T extends Type$userArgs= {}>(args?: Subset<T, Type$userArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Type base type for findUnique actions
   */
  export type TypeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findUnique
   */
  export interface TypeFindUniqueArgs extends TypeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Type findUniqueOrThrow
   */
  export type TypeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }


  /**
   * Type base type for findFirst actions
   */
  export type TypeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: Enumerable<TypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: Enumerable<TypeScalarFieldEnum>
  }

  /**
   * Type findFirst
   */
  export interface TypeFindFirstArgs extends TypeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Type findFirstOrThrow
   */
  export type TypeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: Enumerable<TypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: Enumerable<TypeScalarFieldEnum>
  }


  /**
   * Type findMany
   */
  export type TypeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * Filter, which Types to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: Enumerable<TypeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    distinct?: Enumerable<TypeScalarFieldEnum>
  }


  /**
   * Type create
   */
  export type TypeCreateArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * The data needed to create a Type.
     */
    data: XOR<TypeCreateInput, TypeUncheckedCreateInput>
  }


  /**
   * Type createMany
   */
  export type TypeCreateManyArgs = {
    /**
     * The data used to create many Types.
     */
    data: Enumerable<TypeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Type update
   */
  export type TypeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * The data needed to update a Type.
     */
    data: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
    /**
     * Choose, which Type to update.
     */
    where: TypeWhereUniqueInput
  }


  /**
   * Type updateMany
   */
  export type TypeUpdateManyArgs = {
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
  }


  /**
   * Type upsert
   */
  export type TypeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * The filter to search for the Type to update in case it exists.
     */
    where: TypeWhereUniqueInput
    /**
     * In case the Type found by the `where` argument doesn't exist, create a new Type with this data.
     */
    create: XOR<TypeCreateInput, TypeUncheckedCreateInput>
    /**
     * In case the Type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
  }


  /**
   * Type delete
   */
  export type TypeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
    /**
     * Filter which Type to delete.
     */
    where: TypeWhereUniqueInput
  }


  /**
   * Type deleteMany
   */
  export type TypeDeleteManyArgs = {
    /**
     * Filter which Types to delete
     */
    where?: TypeWhereInput
  }


  /**
   * Type.ngo
   */
  export type Type$ngoArgs = {
    /**
     * Select specific fields to fetch from the NGO
     */
    select?: NGOSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NGOInclude | null
    where?: NGOWhereInput
    orderBy?: Enumerable<NGOOrderByWithRelationInput>
    cursor?: NGOWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NGOScalarFieldEnum>
  }


  /**
   * Type.user
   */
  export type Type$userArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Type without action
   */
  export type TypeArgs = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TypeInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    content: string | null
    created_at: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    content: string | null
    created_at: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    content: number
    created_at: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: PostScalarFieldEnum[]
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: string
    content: string | null
    created_at: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    content?: boolean
    created_at?: boolean
    comment?: boolean | Post$commentArgs
    post_ngo?: boolean | Post$post_ngoArgs
    post_photo?: boolean | Post$post_photoArgs
    post_user?: boolean | Post$post_userArgs
    post_likes?: boolean | Post$post_likesArgs
    _count?: boolean | PostCountOutputTypeArgs
  }


  export type PostInclude = {
    comment?: boolean | Post$commentArgs
    post_ngo?: boolean | Post$post_ngoArgs
    post_photo?: boolean | Post$post_photoArgs
    post_user?: boolean | Post$post_userArgs
    post_likes?: boolean | Post$post_likesArgs
    _count?: boolean | PostCountOutputTypeArgs
  }

  export type PostGetPayload<S extends boolean | null | undefined | PostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Post :
    S extends undefined ? never :
    S extends { include: any } & (PostArgs | PostFindManyArgs)
    ? Post  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'comment' ? Array < CommentGetPayload<S['include'][P]>>  :
        P extends 'post_ngo' ? Array < PostNgoGetPayload<S['include'][P]>>  :
        P extends 'post_photo' ? Array < PostPhotoGetPayload<S['include'][P]>>  :
        P extends 'post_user' ? Array < PostUserGetPayload<S['include'][P]>>  :
        P extends 'post_likes' ? Array < PostLikesGetPayload<S['include'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostArgs | PostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'comment' ? Array < CommentGetPayload<S['select'][P]>>  :
        P extends 'post_ngo' ? Array < PostNgoGetPayload<S['select'][P]>>  :
        P extends 'post_photo' ? Array < PostPhotoGetPayload<S['select'][P]>>  :
        P extends 'post_user' ? Array < PostUserGetPayload<S['select'][P]>>  :
        P extends 'post_likes' ? Array < PostLikesGetPayload<S['select'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Post ? Post[P] : never
  } 
      : Post


  type PostCountArgs = 
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostGetPayload<T>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comment<T extends Post$commentArgs= {}>(args?: Subset<T, Post$commentArgs>): Prisma.PrismaPromise<Array<CommentGetPayload<T>>| Null>;

    post_ngo<T extends Post$post_ngoArgs= {}>(args?: Subset<T, Post$post_ngoArgs>): Prisma.PrismaPromise<Array<PostNgoGetPayload<T>>| Null>;

    post_photo<T extends Post$post_photoArgs= {}>(args?: Subset<T, Post$post_photoArgs>): Prisma.PrismaPromise<Array<PostPhotoGetPayload<T>>| Null>;

    post_user<T extends Post$post_userArgs= {}>(args?: Subset<T, Post$post_userArgs>): Prisma.PrismaPromise<Array<PostUserGetPayload<T>>| Null>;

    post_likes<T extends Post$post_likesArgs= {}>(args?: Subset<T, Post$post_likesArgs>): Prisma.PrismaPromise<Array<PostLikesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUnique
   */
  export interface PostFindUniqueArgs extends PostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post findFirst
   */
  export interface PostFindFirstArgs extends PostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     */
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
  }


  /**
   * Post.comment
   */
  export type Post$commentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Post.post_ngo
   */
  export type Post$post_ngoArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    where?: PostNgoWhereInput
    orderBy?: Enumerable<PostNgoOrderByWithRelationInput>
    cursor?: PostNgoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostNgoScalarFieldEnum>
  }


  /**
   * Post.post_photo
   */
  export type Post$post_photoArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    where?: PostPhotoWhereInput
    orderBy?: Enumerable<PostPhotoOrderByWithRelationInput>
    cursor?: PostPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostPhotoScalarFieldEnum>
  }


  /**
   * Post.post_user
   */
  export type Post$post_userArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    where?: PostUserWhereInput
    orderBy?: Enumerable<PostUserOrderByWithRelationInput>
    cursor?: PostUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostUserScalarFieldEnum>
  }


  /**
   * Post.post_likes
   */
  export type Post$post_likesArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    where?: PostLikesWhereInput
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    cursor?: PostLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PostLikesScalarFieldEnum>
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostInclude | null
  }



  /**
   * Model PostPhoto
   */


  export type AggregatePostPhoto = {
    _count: PostPhotoCountAggregateOutputType | null
    _min: PostPhotoMinAggregateOutputType | null
    _max: PostPhotoMaxAggregateOutputType | null
  }

  export type PostPhotoMinAggregateOutputType = {
    id: string | null
    id_post: string | null
    photo_url: string | null
  }

  export type PostPhotoMaxAggregateOutputType = {
    id: string | null
    id_post: string | null
    photo_url: string | null
  }

  export type PostPhotoCountAggregateOutputType = {
    id: number
    id_post: number
    photo_url: number
    _all: number
  }


  export type PostPhotoMinAggregateInputType = {
    id?: true
    id_post?: true
    photo_url?: true
  }

  export type PostPhotoMaxAggregateInputType = {
    id?: true
    id_post?: true
    photo_url?: true
  }

  export type PostPhotoCountAggregateInputType = {
    id?: true
    id_post?: true
    photo_url?: true
    _all?: true
  }

  export type PostPhotoAggregateArgs = {
    /**
     * Filter which PostPhoto to aggregate.
     */
    where?: PostPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostPhotos to fetch.
     */
    orderBy?: Enumerable<PostPhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostPhotos
    **/
    _count?: true | PostPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostPhotoMaxAggregateInputType
  }

  export type GetPostPhotoAggregateType<T extends PostPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePostPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostPhoto[P]>
      : GetScalarType<T[P], AggregatePostPhoto[P]>
  }




  export type PostPhotoGroupByArgs = {
    where?: PostPhotoWhereInput
    orderBy?: Enumerable<PostPhotoOrderByWithAggregationInput>
    by: PostPhotoScalarFieldEnum[]
    having?: PostPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostPhotoCountAggregateInputType | true
    _min?: PostPhotoMinAggregateInputType
    _max?: PostPhotoMaxAggregateInputType
  }


  export type PostPhotoGroupByOutputType = {
    id: string
    id_post: string
    photo_url: string
    _count: PostPhotoCountAggregateOutputType | null
    _min: PostPhotoMinAggregateOutputType | null
    _max: PostPhotoMaxAggregateOutputType | null
  }

  type GetPostPhotoGroupByPayload<T extends PostPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PostPhotoGroupByOutputType[P]>
        }
      >
    >


  export type PostPhotoSelect = {
    id?: boolean
    id_post?: boolean
    photo_url?: boolean
    post?: boolean | PostArgs
  }


  export type PostPhotoInclude = {
    post?: boolean | PostArgs
  }

  export type PostPhotoGetPayload<S extends boolean | null | undefined | PostPhotoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostPhoto :
    S extends undefined ? never :
    S extends { include: any } & (PostPhotoArgs | PostPhotoFindManyArgs)
    ? PostPhoto  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? PostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostPhotoArgs | PostPhotoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? PostGetPayload<S['select'][P]> :  P extends keyof PostPhoto ? PostPhoto[P] : never
  } 
      : PostPhoto


  type PostPhotoCountArgs = 
    Omit<PostPhotoFindManyArgs, 'select' | 'include'> & {
      select?: PostPhotoCountAggregateInputType | true
    }

  export interface PostPhotoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PostPhoto that matches the filter.
     * @param {PostPhotoFindUniqueArgs} args - Arguments to find a PostPhoto
     * @example
     * // Get one PostPhoto
     * const postPhoto = await prisma.postPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostPhotoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostPhotoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostPhoto'> extends True ? Prisma__PostPhotoClient<PostPhotoGetPayload<T>> : Prisma__PostPhotoClient<PostPhotoGetPayload<T> | null, null>

    /**
     * Find one PostPhoto that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostPhotoFindUniqueOrThrowArgs} args - Arguments to find a PostPhoto
     * @example
     * // Get one PostPhoto
     * const postPhoto = await prisma.postPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostPhotoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostPhotoFindUniqueOrThrowArgs>
    ): Prisma__PostPhotoClient<PostPhotoGetPayload<T>>

    /**
     * Find the first PostPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoFindFirstArgs} args - Arguments to find a PostPhoto
     * @example
     * // Get one PostPhoto
     * const postPhoto = await prisma.postPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostPhotoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostPhotoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostPhoto'> extends True ? Prisma__PostPhotoClient<PostPhotoGetPayload<T>> : Prisma__PostPhotoClient<PostPhotoGetPayload<T> | null, null>

    /**
     * Find the first PostPhoto that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoFindFirstOrThrowArgs} args - Arguments to find a PostPhoto
     * @example
     * // Get one PostPhoto
     * const postPhoto = await prisma.postPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostPhotoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostPhotoFindFirstOrThrowArgs>
    ): Prisma__PostPhotoClient<PostPhotoGetPayload<T>>

    /**
     * Find zero or more PostPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostPhotos
     * const postPhotos = await prisma.postPhoto.findMany()
     * 
     * // Get first 10 PostPhotos
     * const postPhotos = await prisma.postPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postPhotoWithIdOnly = await prisma.postPhoto.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostPhotoFindManyArgs>(
      args?: SelectSubset<T, PostPhotoFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostPhotoGetPayload<T>>>

    /**
     * Create a PostPhoto.
     * @param {PostPhotoCreateArgs} args - Arguments to create a PostPhoto.
     * @example
     * // Create one PostPhoto
     * const PostPhoto = await prisma.postPhoto.create({
     *   data: {
     *     // ... data to create a PostPhoto
     *   }
     * })
     * 
    **/
    create<T extends PostPhotoCreateArgs>(
      args: SelectSubset<T, PostPhotoCreateArgs>
    ): Prisma__PostPhotoClient<PostPhotoGetPayload<T>>

    /**
     * Create many PostPhotos.
     *     @param {PostPhotoCreateManyArgs} args - Arguments to create many PostPhotos.
     *     @example
     *     // Create many PostPhotos
     *     const postPhoto = await prisma.postPhoto.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostPhotoCreateManyArgs>(
      args?: SelectSubset<T, PostPhotoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostPhoto.
     * @param {PostPhotoDeleteArgs} args - Arguments to delete one PostPhoto.
     * @example
     * // Delete one PostPhoto
     * const PostPhoto = await prisma.postPhoto.delete({
     *   where: {
     *     // ... filter to delete one PostPhoto
     *   }
     * })
     * 
    **/
    delete<T extends PostPhotoDeleteArgs>(
      args: SelectSubset<T, PostPhotoDeleteArgs>
    ): Prisma__PostPhotoClient<PostPhotoGetPayload<T>>

    /**
     * Update one PostPhoto.
     * @param {PostPhotoUpdateArgs} args - Arguments to update one PostPhoto.
     * @example
     * // Update one PostPhoto
     * const postPhoto = await prisma.postPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostPhotoUpdateArgs>(
      args: SelectSubset<T, PostPhotoUpdateArgs>
    ): Prisma__PostPhotoClient<PostPhotoGetPayload<T>>

    /**
     * Delete zero or more PostPhotos.
     * @param {PostPhotoDeleteManyArgs} args - Arguments to filter PostPhotos to delete.
     * @example
     * // Delete a few PostPhotos
     * const { count } = await prisma.postPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostPhotoDeleteManyArgs>(
      args?: SelectSubset<T, PostPhotoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostPhotos
     * const postPhoto = await prisma.postPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostPhotoUpdateManyArgs>(
      args: SelectSubset<T, PostPhotoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostPhoto.
     * @param {PostPhotoUpsertArgs} args - Arguments to update or create a PostPhoto.
     * @example
     * // Update or create a PostPhoto
     * const postPhoto = await prisma.postPhoto.upsert({
     *   create: {
     *     // ... data to create a PostPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostPhoto we want to update
     *   }
     * })
    **/
    upsert<T extends PostPhotoUpsertArgs>(
      args: SelectSubset<T, PostPhotoUpsertArgs>
    ): Prisma__PostPhotoClient<PostPhotoGetPayload<T>>

    /**
     * Count the number of PostPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoCountArgs} args - Arguments to filter PostPhotos to count.
     * @example
     * // Count the number of PostPhotos
     * const count = await prisma.postPhoto.count({
     *   where: {
     *     // ... the filter for the PostPhotos we want to count
     *   }
     * })
    **/
    count<T extends PostPhotoCountArgs>(
      args?: Subset<T, PostPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostPhotoAggregateArgs>(args: Subset<T, PostPhotoAggregateArgs>): Prisma.PrismaPromise<GetPostPhotoAggregateType<T>>

    /**
     * Group by PostPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostPhotoGroupByArgs['orderBy'] }
        : { orderBy?: PostPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostPhotoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostPhoto base type for findUnique actions
   */
  export type PostPhotoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * Filter, which PostPhoto to fetch.
     */
    where: PostPhotoWhereUniqueInput
  }

  /**
   * PostPhoto findUnique
   */
  export interface PostPhotoFindUniqueArgs extends PostPhotoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostPhoto findUniqueOrThrow
   */
  export type PostPhotoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * Filter, which PostPhoto to fetch.
     */
    where: PostPhotoWhereUniqueInput
  }


  /**
   * PostPhoto base type for findFirst actions
   */
  export type PostPhotoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * Filter, which PostPhoto to fetch.
     */
    where?: PostPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostPhotos to fetch.
     */
    orderBy?: Enumerable<PostPhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostPhotos.
     */
    cursor?: PostPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostPhotos.
     */
    distinct?: Enumerable<PostPhotoScalarFieldEnum>
  }

  /**
   * PostPhoto findFirst
   */
  export interface PostPhotoFindFirstArgs extends PostPhotoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostPhoto findFirstOrThrow
   */
  export type PostPhotoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * Filter, which PostPhoto to fetch.
     */
    where?: PostPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostPhotos to fetch.
     */
    orderBy?: Enumerable<PostPhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostPhotos.
     */
    cursor?: PostPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostPhotos.
     */
    distinct?: Enumerable<PostPhotoScalarFieldEnum>
  }


  /**
   * PostPhoto findMany
   */
  export type PostPhotoFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * Filter, which PostPhotos to fetch.
     */
    where?: PostPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostPhotos to fetch.
     */
    orderBy?: Enumerable<PostPhotoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostPhotos.
     */
    cursor?: PostPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostPhotos.
     */
    skip?: number
    distinct?: Enumerable<PostPhotoScalarFieldEnum>
  }


  /**
   * PostPhoto create
   */
  export type PostPhotoCreateArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * The data needed to create a PostPhoto.
     */
    data: XOR<PostPhotoCreateInput, PostPhotoUncheckedCreateInput>
  }


  /**
   * PostPhoto createMany
   */
  export type PostPhotoCreateManyArgs = {
    /**
     * The data used to create many PostPhotos.
     */
    data: Enumerable<PostPhotoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostPhoto update
   */
  export type PostPhotoUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * The data needed to update a PostPhoto.
     */
    data: XOR<PostPhotoUpdateInput, PostPhotoUncheckedUpdateInput>
    /**
     * Choose, which PostPhoto to update.
     */
    where: PostPhotoWhereUniqueInput
  }


  /**
   * PostPhoto updateMany
   */
  export type PostPhotoUpdateManyArgs = {
    /**
     * The data used to update PostPhotos.
     */
    data: XOR<PostPhotoUpdateManyMutationInput, PostPhotoUncheckedUpdateManyInput>
    /**
     * Filter which PostPhotos to update
     */
    where?: PostPhotoWhereInput
  }


  /**
   * PostPhoto upsert
   */
  export type PostPhotoUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * The filter to search for the PostPhoto to update in case it exists.
     */
    where: PostPhotoWhereUniqueInput
    /**
     * In case the PostPhoto found by the `where` argument doesn't exist, create a new PostPhoto with this data.
     */
    create: XOR<PostPhotoCreateInput, PostPhotoUncheckedCreateInput>
    /**
     * In case the PostPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostPhotoUpdateInput, PostPhotoUncheckedUpdateInput>
  }


  /**
   * PostPhoto delete
   */
  export type PostPhotoDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
    /**
     * Filter which PostPhoto to delete.
     */
    where: PostPhotoWhereUniqueInput
  }


  /**
   * PostPhoto deleteMany
   */
  export type PostPhotoDeleteManyArgs = {
    /**
     * Filter which PostPhotos to delete
     */
    where?: PostPhotoWhereInput
  }


  /**
   * PostPhoto without action
   */
  export type PostPhotoArgs = {
    /**
     * Select specific fields to fetch from the PostPhoto
     */
    select?: PostPhotoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostPhotoInclude | null
  }



  /**
   * Model PostNgo
   */


  export type AggregatePostNgo = {
    _count: PostNgoCountAggregateOutputType | null
    _min: PostNgoMinAggregateOutputType | null
    _max: PostNgoMaxAggregateOutputType | null
  }

  export type PostNgoMinAggregateOutputType = {
    id: string | null
    id_post: string | null
    id_ngo: string | null
  }

  export type PostNgoMaxAggregateOutputType = {
    id: string | null
    id_post: string | null
    id_ngo: string | null
  }

  export type PostNgoCountAggregateOutputType = {
    id: number
    id_post: number
    id_ngo: number
    _all: number
  }


  export type PostNgoMinAggregateInputType = {
    id?: true
    id_post?: true
    id_ngo?: true
  }

  export type PostNgoMaxAggregateInputType = {
    id?: true
    id_post?: true
    id_ngo?: true
  }

  export type PostNgoCountAggregateInputType = {
    id?: true
    id_post?: true
    id_ngo?: true
    _all?: true
  }

  export type PostNgoAggregateArgs = {
    /**
     * Filter which PostNgo to aggregate.
     */
    where?: PostNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNgos to fetch.
     */
    orderBy?: Enumerable<PostNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostNgos
    **/
    _count?: true | PostNgoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostNgoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostNgoMaxAggregateInputType
  }

  export type GetPostNgoAggregateType<T extends PostNgoAggregateArgs> = {
        [P in keyof T & keyof AggregatePostNgo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostNgo[P]>
      : GetScalarType<T[P], AggregatePostNgo[P]>
  }




  export type PostNgoGroupByArgs = {
    where?: PostNgoWhereInput
    orderBy?: Enumerable<PostNgoOrderByWithAggregationInput>
    by: PostNgoScalarFieldEnum[]
    having?: PostNgoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostNgoCountAggregateInputType | true
    _min?: PostNgoMinAggregateInputType
    _max?: PostNgoMaxAggregateInputType
  }


  export type PostNgoGroupByOutputType = {
    id: string
    id_post: string
    id_ngo: string
    _count: PostNgoCountAggregateOutputType | null
    _min: PostNgoMinAggregateOutputType | null
    _max: PostNgoMaxAggregateOutputType | null
  }

  type GetPostNgoGroupByPayload<T extends PostNgoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostNgoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostNgoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostNgoGroupByOutputType[P]>
            : GetScalarType<T[P], PostNgoGroupByOutputType[P]>
        }
      >
    >


  export type PostNgoSelect = {
    id?: boolean
    id_post?: boolean
    id_ngo?: boolean
    ngo?: boolean | NGOArgs
    post?: boolean | PostArgs
  }


  export type PostNgoInclude = {
    ngo?: boolean | NGOArgs
    post?: boolean | PostArgs
  }

  export type PostNgoGetPayload<S extends boolean | null | undefined | PostNgoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostNgo :
    S extends undefined ? never :
    S extends { include: any } & (PostNgoArgs | PostNgoFindManyArgs)
    ? PostNgo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :
        P extends 'post' ? PostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostNgoArgs | PostNgoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :
        P extends 'post' ? PostGetPayload<S['select'][P]> :  P extends keyof PostNgo ? PostNgo[P] : never
  } 
      : PostNgo


  type PostNgoCountArgs = 
    Omit<PostNgoFindManyArgs, 'select' | 'include'> & {
      select?: PostNgoCountAggregateInputType | true
    }

  export interface PostNgoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PostNgo that matches the filter.
     * @param {PostNgoFindUniqueArgs} args - Arguments to find a PostNgo
     * @example
     * // Get one PostNgo
     * const postNgo = await prisma.postNgo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostNgoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostNgoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostNgo'> extends True ? Prisma__PostNgoClient<PostNgoGetPayload<T>> : Prisma__PostNgoClient<PostNgoGetPayload<T> | null, null>

    /**
     * Find one PostNgo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostNgoFindUniqueOrThrowArgs} args - Arguments to find a PostNgo
     * @example
     * // Get one PostNgo
     * const postNgo = await prisma.postNgo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostNgoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostNgoFindUniqueOrThrowArgs>
    ): Prisma__PostNgoClient<PostNgoGetPayload<T>>

    /**
     * Find the first PostNgo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoFindFirstArgs} args - Arguments to find a PostNgo
     * @example
     * // Get one PostNgo
     * const postNgo = await prisma.postNgo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostNgoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostNgoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostNgo'> extends True ? Prisma__PostNgoClient<PostNgoGetPayload<T>> : Prisma__PostNgoClient<PostNgoGetPayload<T> | null, null>

    /**
     * Find the first PostNgo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoFindFirstOrThrowArgs} args - Arguments to find a PostNgo
     * @example
     * // Get one PostNgo
     * const postNgo = await prisma.postNgo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostNgoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostNgoFindFirstOrThrowArgs>
    ): Prisma__PostNgoClient<PostNgoGetPayload<T>>

    /**
     * Find zero or more PostNgos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostNgos
     * const postNgos = await prisma.postNgo.findMany()
     * 
     * // Get first 10 PostNgos
     * const postNgos = await prisma.postNgo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postNgoWithIdOnly = await prisma.postNgo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostNgoFindManyArgs>(
      args?: SelectSubset<T, PostNgoFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostNgoGetPayload<T>>>

    /**
     * Create a PostNgo.
     * @param {PostNgoCreateArgs} args - Arguments to create a PostNgo.
     * @example
     * // Create one PostNgo
     * const PostNgo = await prisma.postNgo.create({
     *   data: {
     *     // ... data to create a PostNgo
     *   }
     * })
     * 
    **/
    create<T extends PostNgoCreateArgs>(
      args: SelectSubset<T, PostNgoCreateArgs>
    ): Prisma__PostNgoClient<PostNgoGetPayload<T>>

    /**
     * Create many PostNgos.
     *     @param {PostNgoCreateManyArgs} args - Arguments to create many PostNgos.
     *     @example
     *     // Create many PostNgos
     *     const postNgo = await prisma.postNgo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostNgoCreateManyArgs>(
      args?: SelectSubset<T, PostNgoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostNgo.
     * @param {PostNgoDeleteArgs} args - Arguments to delete one PostNgo.
     * @example
     * // Delete one PostNgo
     * const PostNgo = await prisma.postNgo.delete({
     *   where: {
     *     // ... filter to delete one PostNgo
     *   }
     * })
     * 
    **/
    delete<T extends PostNgoDeleteArgs>(
      args: SelectSubset<T, PostNgoDeleteArgs>
    ): Prisma__PostNgoClient<PostNgoGetPayload<T>>

    /**
     * Update one PostNgo.
     * @param {PostNgoUpdateArgs} args - Arguments to update one PostNgo.
     * @example
     * // Update one PostNgo
     * const postNgo = await prisma.postNgo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostNgoUpdateArgs>(
      args: SelectSubset<T, PostNgoUpdateArgs>
    ): Prisma__PostNgoClient<PostNgoGetPayload<T>>

    /**
     * Delete zero or more PostNgos.
     * @param {PostNgoDeleteManyArgs} args - Arguments to filter PostNgos to delete.
     * @example
     * // Delete a few PostNgos
     * const { count } = await prisma.postNgo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostNgoDeleteManyArgs>(
      args?: SelectSubset<T, PostNgoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostNgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostNgos
     * const postNgo = await prisma.postNgo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostNgoUpdateManyArgs>(
      args: SelectSubset<T, PostNgoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostNgo.
     * @param {PostNgoUpsertArgs} args - Arguments to update or create a PostNgo.
     * @example
     * // Update or create a PostNgo
     * const postNgo = await prisma.postNgo.upsert({
     *   create: {
     *     // ... data to create a PostNgo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostNgo we want to update
     *   }
     * })
    **/
    upsert<T extends PostNgoUpsertArgs>(
      args: SelectSubset<T, PostNgoUpsertArgs>
    ): Prisma__PostNgoClient<PostNgoGetPayload<T>>

    /**
     * Count the number of PostNgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoCountArgs} args - Arguments to filter PostNgos to count.
     * @example
     * // Count the number of PostNgos
     * const count = await prisma.postNgo.count({
     *   where: {
     *     // ... the filter for the PostNgos we want to count
     *   }
     * })
    **/
    count<T extends PostNgoCountArgs>(
      args?: Subset<T, PostNgoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostNgoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostNgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostNgoAggregateArgs>(args: Subset<T, PostNgoAggregateArgs>): Prisma.PrismaPromise<GetPostNgoAggregateType<T>>

    /**
     * Group by PostNgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostNgoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostNgoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostNgoGroupByArgs['orderBy'] }
        : { orderBy?: PostNgoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostNgoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostNgoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostNgo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostNgoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostNgo base type for findUnique actions
   */
  export type PostNgoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * Filter, which PostNgo to fetch.
     */
    where: PostNgoWhereUniqueInput
  }

  /**
   * PostNgo findUnique
   */
  export interface PostNgoFindUniqueArgs extends PostNgoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostNgo findUniqueOrThrow
   */
  export type PostNgoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * Filter, which PostNgo to fetch.
     */
    where: PostNgoWhereUniqueInput
  }


  /**
   * PostNgo base type for findFirst actions
   */
  export type PostNgoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * Filter, which PostNgo to fetch.
     */
    where?: PostNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNgos to fetch.
     */
    orderBy?: Enumerable<PostNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostNgos.
     */
    cursor?: PostNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostNgos.
     */
    distinct?: Enumerable<PostNgoScalarFieldEnum>
  }

  /**
   * PostNgo findFirst
   */
  export interface PostNgoFindFirstArgs extends PostNgoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostNgo findFirstOrThrow
   */
  export type PostNgoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * Filter, which PostNgo to fetch.
     */
    where?: PostNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNgos to fetch.
     */
    orderBy?: Enumerable<PostNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostNgos.
     */
    cursor?: PostNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostNgos.
     */
    distinct?: Enumerable<PostNgoScalarFieldEnum>
  }


  /**
   * PostNgo findMany
   */
  export type PostNgoFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * Filter, which PostNgos to fetch.
     */
    where?: PostNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostNgos to fetch.
     */
    orderBy?: Enumerable<PostNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostNgos.
     */
    cursor?: PostNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostNgos.
     */
    skip?: number
    distinct?: Enumerable<PostNgoScalarFieldEnum>
  }


  /**
   * PostNgo create
   */
  export type PostNgoCreateArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * The data needed to create a PostNgo.
     */
    data: XOR<PostNgoCreateInput, PostNgoUncheckedCreateInput>
  }


  /**
   * PostNgo createMany
   */
  export type PostNgoCreateManyArgs = {
    /**
     * The data used to create many PostNgos.
     */
    data: Enumerable<PostNgoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostNgo update
   */
  export type PostNgoUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * The data needed to update a PostNgo.
     */
    data: XOR<PostNgoUpdateInput, PostNgoUncheckedUpdateInput>
    /**
     * Choose, which PostNgo to update.
     */
    where: PostNgoWhereUniqueInput
  }


  /**
   * PostNgo updateMany
   */
  export type PostNgoUpdateManyArgs = {
    /**
     * The data used to update PostNgos.
     */
    data: XOR<PostNgoUpdateManyMutationInput, PostNgoUncheckedUpdateManyInput>
    /**
     * Filter which PostNgos to update
     */
    where?: PostNgoWhereInput
  }


  /**
   * PostNgo upsert
   */
  export type PostNgoUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * The filter to search for the PostNgo to update in case it exists.
     */
    where: PostNgoWhereUniqueInput
    /**
     * In case the PostNgo found by the `where` argument doesn't exist, create a new PostNgo with this data.
     */
    create: XOR<PostNgoCreateInput, PostNgoUncheckedCreateInput>
    /**
     * In case the PostNgo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostNgoUpdateInput, PostNgoUncheckedUpdateInput>
  }


  /**
   * PostNgo delete
   */
  export type PostNgoDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
    /**
     * Filter which PostNgo to delete.
     */
    where: PostNgoWhereUniqueInput
  }


  /**
   * PostNgo deleteMany
   */
  export type PostNgoDeleteManyArgs = {
    /**
     * Filter which PostNgos to delete
     */
    where?: PostNgoWhereInput
  }


  /**
   * PostNgo without action
   */
  export type PostNgoArgs = {
    /**
     * Select specific fields to fetch from the PostNgo
     */
    select?: PostNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostNgoInclude | null
  }



  /**
   * Model PostUser
   */


  export type AggregatePostUser = {
    _count: PostUserCountAggregateOutputType | null
    _min: PostUserMinAggregateOutputType | null
    _max: PostUserMaxAggregateOutputType | null
  }

  export type PostUserMinAggregateOutputType = {
    id: string | null
    id_post: string | null
    id_user: string | null
  }

  export type PostUserMaxAggregateOutputType = {
    id: string | null
    id_post: string | null
    id_user: string | null
  }

  export type PostUserCountAggregateOutputType = {
    id: number
    id_post: number
    id_user: number
    _all: number
  }


  export type PostUserMinAggregateInputType = {
    id?: true
    id_post?: true
    id_user?: true
  }

  export type PostUserMaxAggregateInputType = {
    id?: true
    id_post?: true
    id_user?: true
  }

  export type PostUserCountAggregateInputType = {
    id?: true
    id_post?: true
    id_user?: true
    _all?: true
  }

  export type PostUserAggregateArgs = {
    /**
     * Filter which PostUser to aggregate.
     */
    where?: PostUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUsers to fetch.
     */
    orderBy?: Enumerable<PostUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostUsers
    **/
    _count?: true | PostUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostUserMaxAggregateInputType
  }

  export type GetPostUserAggregateType<T extends PostUserAggregateArgs> = {
        [P in keyof T & keyof AggregatePostUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostUser[P]>
      : GetScalarType<T[P], AggregatePostUser[P]>
  }




  export type PostUserGroupByArgs = {
    where?: PostUserWhereInput
    orderBy?: Enumerable<PostUserOrderByWithAggregationInput>
    by: PostUserScalarFieldEnum[]
    having?: PostUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostUserCountAggregateInputType | true
    _min?: PostUserMinAggregateInputType
    _max?: PostUserMaxAggregateInputType
  }


  export type PostUserGroupByOutputType = {
    id: string
    id_post: string
    id_user: string
    _count: PostUserCountAggregateOutputType | null
    _min: PostUserMinAggregateOutputType | null
    _max: PostUserMaxAggregateOutputType | null
  }

  type GetPostUserGroupByPayload<T extends PostUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostUserGroupByOutputType[P]>
            : GetScalarType<T[P], PostUserGroupByOutputType[P]>
        }
      >
    >


  export type PostUserSelect = {
    id?: boolean
    id_post?: boolean
    id_user?: boolean
    post?: boolean | PostArgs
    user?: boolean | UserArgs
  }


  export type PostUserInclude = {
    post?: boolean | PostArgs
    user?: boolean | UserArgs
  }

  export type PostUserGetPayload<S extends boolean | null | undefined | PostUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostUser :
    S extends undefined ? never :
    S extends { include: any } & (PostUserArgs | PostUserFindManyArgs)
    ? PostUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? PostGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostUserArgs | PostUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? PostGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof PostUser ? PostUser[P] : never
  } 
      : PostUser


  type PostUserCountArgs = 
    Omit<PostUserFindManyArgs, 'select' | 'include'> & {
      select?: PostUserCountAggregateInputType | true
    }

  export interface PostUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PostUser that matches the filter.
     * @param {PostUserFindUniqueArgs} args - Arguments to find a PostUser
     * @example
     * // Get one PostUser
     * const postUser = await prisma.postUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostUser'> extends True ? Prisma__PostUserClient<PostUserGetPayload<T>> : Prisma__PostUserClient<PostUserGetPayload<T> | null, null>

    /**
     * Find one PostUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostUserFindUniqueOrThrowArgs} args - Arguments to find a PostUser
     * @example
     * // Get one PostUser
     * const postUser = await prisma.postUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostUserFindUniqueOrThrowArgs>
    ): Prisma__PostUserClient<PostUserGetPayload<T>>

    /**
     * Find the first PostUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserFindFirstArgs} args - Arguments to find a PostUser
     * @example
     * // Get one PostUser
     * const postUser = await prisma.postUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostUser'> extends True ? Prisma__PostUserClient<PostUserGetPayload<T>> : Prisma__PostUserClient<PostUserGetPayload<T> | null, null>

    /**
     * Find the first PostUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserFindFirstOrThrowArgs} args - Arguments to find a PostUser
     * @example
     * // Get one PostUser
     * const postUser = await prisma.postUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostUserFindFirstOrThrowArgs>
    ): Prisma__PostUserClient<PostUserGetPayload<T>>

    /**
     * Find zero or more PostUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostUsers
     * const postUsers = await prisma.postUser.findMany()
     * 
     * // Get first 10 PostUsers
     * const postUsers = await prisma.postUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postUserWithIdOnly = await prisma.postUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostUserFindManyArgs>(
      args?: SelectSubset<T, PostUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostUserGetPayload<T>>>

    /**
     * Create a PostUser.
     * @param {PostUserCreateArgs} args - Arguments to create a PostUser.
     * @example
     * // Create one PostUser
     * const PostUser = await prisma.postUser.create({
     *   data: {
     *     // ... data to create a PostUser
     *   }
     * })
     * 
    **/
    create<T extends PostUserCreateArgs>(
      args: SelectSubset<T, PostUserCreateArgs>
    ): Prisma__PostUserClient<PostUserGetPayload<T>>

    /**
     * Create many PostUsers.
     *     @param {PostUserCreateManyArgs} args - Arguments to create many PostUsers.
     *     @example
     *     // Create many PostUsers
     *     const postUser = await prisma.postUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostUserCreateManyArgs>(
      args?: SelectSubset<T, PostUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostUser.
     * @param {PostUserDeleteArgs} args - Arguments to delete one PostUser.
     * @example
     * // Delete one PostUser
     * const PostUser = await prisma.postUser.delete({
     *   where: {
     *     // ... filter to delete one PostUser
     *   }
     * })
     * 
    **/
    delete<T extends PostUserDeleteArgs>(
      args: SelectSubset<T, PostUserDeleteArgs>
    ): Prisma__PostUserClient<PostUserGetPayload<T>>

    /**
     * Update one PostUser.
     * @param {PostUserUpdateArgs} args - Arguments to update one PostUser.
     * @example
     * // Update one PostUser
     * const postUser = await prisma.postUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUserUpdateArgs>(
      args: SelectSubset<T, PostUserUpdateArgs>
    ): Prisma__PostUserClient<PostUserGetPayload<T>>

    /**
     * Delete zero or more PostUsers.
     * @param {PostUserDeleteManyArgs} args - Arguments to filter PostUsers to delete.
     * @example
     * // Delete a few PostUsers
     * const { count } = await prisma.postUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostUserDeleteManyArgs>(
      args?: SelectSubset<T, PostUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostUsers
     * const postUser = await prisma.postUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUserUpdateManyArgs>(
      args: SelectSubset<T, PostUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostUser.
     * @param {PostUserUpsertArgs} args - Arguments to update or create a PostUser.
     * @example
     * // Update or create a PostUser
     * const postUser = await prisma.postUser.upsert({
     *   create: {
     *     // ... data to create a PostUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostUser we want to update
     *   }
     * })
    **/
    upsert<T extends PostUserUpsertArgs>(
      args: SelectSubset<T, PostUserUpsertArgs>
    ): Prisma__PostUserClient<PostUserGetPayload<T>>

    /**
     * Count the number of PostUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserCountArgs} args - Arguments to filter PostUsers to count.
     * @example
     * // Count the number of PostUsers
     * const count = await prisma.postUser.count({
     *   where: {
     *     // ... the filter for the PostUsers we want to count
     *   }
     * })
    **/
    count<T extends PostUserCountArgs>(
      args?: Subset<T, PostUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostUserAggregateArgs>(args: Subset<T, PostUserAggregateArgs>): Prisma.PrismaPromise<GetPostUserAggregateType<T>>

    /**
     * Group by PostUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostUserGroupByArgs['orderBy'] }
        : { orderBy?: PostUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostUser base type for findUnique actions
   */
  export type PostUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * Filter, which PostUser to fetch.
     */
    where: PostUserWhereUniqueInput
  }

  /**
   * PostUser findUnique
   */
  export interface PostUserFindUniqueArgs extends PostUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostUser findUniqueOrThrow
   */
  export type PostUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * Filter, which PostUser to fetch.
     */
    where: PostUserWhereUniqueInput
  }


  /**
   * PostUser base type for findFirst actions
   */
  export type PostUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * Filter, which PostUser to fetch.
     */
    where?: PostUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUsers to fetch.
     */
    orderBy?: Enumerable<PostUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostUsers.
     */
    cursor?: PostUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostUsers.
     */
    distinct?: Enumerable<PostUserScalarFieldEnum>
  }

  /**
   * PostUser findFirst
   */
  export interface PostUserFindFirstArgs extends PostUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostUser findFirstOrThrow
   */
  export type PostUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * Filter, which PostUser to fetch.
     */
    where?: PostUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUsers to fetch.
     */
    orderBy?: Enumerable<PostUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostUsers.
     */
    cursor?: PostUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostUsers.
     */
    distinct?: Enumerable<PostUserScalarFieldEnum>
  }


  /**
   * PostUser findMany
   */
  export type PostUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * Filter, which PostUsers to fetch.
     */
    where?: PostUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUsers to fetch.
     */
    orderBy?: Enumerable<PostUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostUsers.
     */
    cursor?: PostUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUsers.
     */
    skip?: number
    distinct?: Enumerable<PostUserScalarFieldEnum>
  }


  /**
   * PostUser create
   */
  export type PostUserCreateArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * The data needed to create a PostUser.
     */
    data: XOR<PostUserCreateInput, PostUserUncheckedCreateInput>
  }


  /**
   * PostUser createMany
   */
  export type PostUserCreateManyArgs = {
    /**
     * The data used to create many PostUsers.
     */
    data: Enumerable<PostUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostUser update
   */
  export type PostUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * The data needed to update a PostUser.
     */
    data: XOR<PostUserUpdateInput, PostUserUncheckedUpdateInput>
    /**
     * Choose, which PostUser to update.
     */
    where: PostUserWhereUniqueInput
  }


  /**
   * PostUser updateMany
   */
  export type PostUserUpdateManyArgs = {
    /**
     * The data used to update PostUsers.
     */
    data: XOR<PostUserUpdateManyMutationInput, PostUserUncheckedUpdateManyInput>
    /**
     * Filter which PostUsers to update
     */
    where?: PostUserWhereInput
  }


  /**
   * PostUser upsert
   */
  export type PostUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * The filter to search for the PostUser to update in case it exists.
     */
    where: PostUserWhereUniqueInput
    /**
     * In case the PostUser found by the `where` argument doesn't exist, create a new PostUser with this data.
     */
    create: XOR<PostUserCreateInput, PostUserUncheckedCreateInput>
    /**
     * In case the PostUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUserUpdateInput, PostUserUncheckedUpdateInput>
  }


  /**
   * PostUser delete
   */
  export type PostUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
    /**
     * Filter which PostUser to delete.
     */
    where: PostUserWhereUniqueInput
  }


  /**
   * PostUser deleteMany
   */
  export type PostUserDeleteManyArgs = {
    /**
     * Filter which PostUsers to delete
     */
    where?: PostUserWhereInput
  }


  /**
   * PostUser without action
   */
  export type PostUserArgs = {
    /**
     * Select specific fields to fetch from the PostUser
     */
    select?: PostUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostUserInclude | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    created_at: Date | null
    id_post: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    created_at: Date | null
    id_post: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    created_at: number
    id_post: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    id_post?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    id_post?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    created_at?: true
    id_post?: true
    _all?: true
  }

  export type CommentAggregateArgs = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    id: string
    content: string
    created_at: Date
    id_post: string
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect = {
    id?: boolean
    content?: boolean
    created_at?: boolean
    id_post?: boolean
    post?: boolean | PostArgs
    comment_ngo?: boolean | Comment$comment_ngoArgs
    comment_user?: boolean | Comment$comment_userArgs
    comment_likes?: boolean | Comment$comment_likesArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }


  export type CommentInclude = {
    post?: boolean | PostArgs
    comment_ngo?: boolean | Comment$comment_ngoArgs
    comment_user?: boolean | Comment$comment_userArgs
    comment_likes?: boolean | Comment$comment_likesArgs
    _count?: boolean | CommentCountOutputTypeArgs
  }

  export type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Comment :
    S extends undefined ? never :
    S extends { include: any } & (CommentArgs | CommentFindManyArgs)
    ? Comment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'post' ? PostGetPayload<S['include'][P]> :
        P extends 'comment_ngo' ? Array < CommentNgoGetPayload<S['include'][P]>>  :
        P extends 'comment_user' ? Array < CommentUserGetPayload<S['include'][P]>>  :
        P extends 'comment_likes' ? Array < CommentLikesGetPayload<S['include'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentArgs | CommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'post' ? PostGetPayload<S['select'][P]> :
        P extends 'comment_ngo' ? Array < CommentNgoGetPayload<S['select'][P]>>  :
        P extends 'comment_user' ? Array < CommentUserGetPayload<S['select'][P]>>  :
        P extends 'comment_likes' ? Array < CommentLikesGetPayload<S['select'][P]>>  :
        P extends '_count' ? CommentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Comment ? Comment[P] : never
  } 
      : Comment


  type CommentCountArgs = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<CommentGetPayload<T>> : Prisma__CommentClient<CommentGetPayload<T> | null, null>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs>(
      args?: SelectSubset<T, CommentFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentGetPayload<T>>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs>(
      args: SelectSubset<T, CommentCreateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs>(
      args?: SelectSubset<T, CommentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs>(
      args: SelectSubset<T, CommentDeleteArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs>(
      args: SelectSubset<T, CommentUpdateArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs>(
      args?: SelectSubset<T, CommentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs>(
      args: SelectSubset<T, CommentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs>(
      args: SelectSubset<T, CommentUpsertArgs>
    ): Prisma__CommentClient<CommentGetPayload<T>>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    comment_ngo<T extends Comment$comment_ngoArgs= {}>(args?: Subset<T, Comment$comment_ngoArgs>): Prisma.PrismaPromise<Array<CommentNgoGetPayload<T>>| Null>;

    comment_user<T extends Comment$comment_userArgs= {}>(args?: Subset<T, Comment$comment_userArgs>): Prisma.PrismaPromise<Array<CommentUserGetPayload<T>>| Null>;

    comment_likes<T extends Comment$comment_likesArgs= {}>(args?: Subset<T, Comment$comment_likesArgs>): Prisma.PrismaPromise<Array<CommentLikesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs extends CommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs extends CommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.comment_ngo
   */
  export type Comment$comment_ngoArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    where?: CommentNgoWhereInput
    orderBy?: Enumerable<CommentNgoOrderByWithRelationInput>
    cursor?: CommentNgoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentNgoScalarFieldEnum>
  }


  /**
   * Comment.comment_user
   */
  export type Comment$comment_userArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    where?: CommentUserWhereInput
    orderBy?: Enumerable<CommentUserOrderByWithRelationInput>
    cursor?: CommentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentUserScalarFieldEnum>
  }


  /**
   * Comment.comment_likes
   */
  export type Comment$comment_likesArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    where?: CommentLikesWhereInput
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    cursor?: CommentLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentLikesScalarFieldEnum>
  }


  /**
   * Comment without action
   */
  export type CommentArgs = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude | null
  }



  /**
   * Model CommentUser
   */


  export type AggregateCommentUser = {
    _count: CommentUserCountAggregateOutputType | null
    _min: CommentUserMinAggregateOutputType | null
    _max: CommentUserMaxAggregateOutputType | null
  }

  export type CommentUserMinAggregateOutputType = {
    id: string | null
    id_comment: string | null
    id_user: string | null
  }

  export type CommentUserMaxAggregateOutputType = {
    id: string | null
    id_comment: string | null
    id_user: string | null
  }

  export type CommentUserCountAggregateOutputType = {
    id: number
    id_comment: number
    id_user: number
    _all: number
  }


  export type CommentUserMinAggregateInputType = {
    id?: true
    id_comment?: true
    id_user?: true
  }

  export type CommentUserMaxAggregateInputType = {
    id?: true
    id_comment?: true
    id_user?: true
  }

  export type CommentUserCountAggregateInputType = {
    id?: true
    id_comment?: true
    id_user?: true
    _all?: true
  }

  export type CommentUserAggregateArgs = {
    /**
     * Filter which CommentUser to aggregate.
     */
    where?: CommentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUsers to fetch.
     */
    orderBy?: Enumerable<CommentUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentUsers
    **/
    _count?: true | CommentUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentUserMaxAggregateInputType
  }

  export type GetCommentUserAggregateType<T extends CommentUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentUser[P]>
      : GetScalarType<T[P], AggregateCommentUser[P]>
  }




  export type CommentUserGroupByArgs = {
    where?: CommentUserWhereInput
    orderBy?: Enumerable<CommentUserOrderByWithAggregationInput>
    by: CommentUserScalarFieldEnum[]
    having?: CommentUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentUserCountAggregateInputType | true
    _min?: CommentUserMinAggregateInputType
    _max?: CommentUserMaxAggregateInputType
  }


  export type CommentUserGroupByOutputType = {
    id: string
    id_comment: string
    id_user: string
    _count: CommentUserCountAggregateOutputType | null
    _min: CommentUserMinAggregateOutputType | null
    _max: CommentUserMaxAggregateOutputType | null
  }

  type GetCommentUserGroupByPayload<T extends CommentUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentUserGroupByOutputType[P]>
            : GetScalarType<T[P], CommentUserGroupByOutputType[P]>
        }
      >
    >


  export type CommentUserSelect = {
    id?: boolean
    id_comment?: boolean
    id_user?: boolean
    comment?: boolean | CommentArgs
    user?: boolean | UserArgs
  }


  export type CommentUserInclude = {
    comment?: boolean | CommentArgs
    user?: boolean | UserArgs
  }

  export type CommentUserGetPayload<S extends boolean | null | undefined | CommentUserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentUser :
    S extends undefined ? never :
    S extends { include: any } & (CommentUserArgs | CommentUserFindManyArgs)
    ? CommentUser  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'comment' ? CommentGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentUserArgs | CommentUserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'comment' ? CommentGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof CommentUser ? CommentUser[P] : never
  } 
      : CommentUser


  type CommentUserCountArgs = 
    Omit<CommentUserFindManyArgs, 'select' | 'include'> & {
      select?: CommentUserCountAggregateInputType | true
    }

  export interface CommentUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CommentUser that matches the filter.
     * @param {CommentUserFindUniqueArgs} args - Arguments to find a CommentUser
     * @example
     * // Get one CommentUser
     * const commentUser = await prisma.commentUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentUserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentUserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommentUser'> extends True ? Prisma__CommentUserClient<CommentUserGetPayload<T>> : Prisma__CommentUserClient<CommentUserGetPayload<T> | null, null>

    /**
     * Find one CommentUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentUserFindUniqueOrThrowArgs} args - Arguments to find a CommentUser
     * @example
     * // Get one CommentUser
     * const commentUser = await prisma.commentUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentUserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentUserFindUniqueOrThrowArgs>
    ): Prisma__CommentUserClient<CommentUserGetPayload<T>>

    /**
     * Find the first CommentUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserFindFirstArgs} args - Arguments to find a CommentUser
     * @example
     * // Get one CommentUser
     * const commentUser = await prisma.commentUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentUserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentUserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommentUser'> extends True ? Prisma__CommentUserClient<CommentUserGetPayload<T>> : Prisma__CommentUserClient<CommentUserGetPayload<T> | null, null>

    /**
     * Find the first CommentUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserFindFirstOrThrowArgs} args - Arguments to find a CommentUser
     * @example
     * // Get one CommentUser
     * const commentUser = await prisma.commentUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentUserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentUserFindFirstOrThrowArgs>
    ): Prisma__CommentUserClient<CommentUserGetPayload<T>>

    /**
     * Find zero or more CommentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentUsers
     * const commentUsers = await prisma.commentUser.findMany()
     * 
     * // Get first 10 CommentUsers
     * const commentUsers = await prisma.commentUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentUserWithIdOnly = await prisma.commentUser.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentUserFindManyArgs>(
      args?: SelectSubset<T, CommentUserFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentUserGetPayload<T>>>

    /**
     * Create a CommentUser.
     * @param {CommentUserCreateArgs} args - Arguments to create a CommentUser.
     * @example
     * // Create one CommentUser
     * const CommentUser = await prisma.commentUser.create({
     *   data: {
     *     // ... data to create a CommentUser
     *   }
     * })
     * 
    **/
    create<T extends CommentUserCreateArgs>(
      args: SelectSubset<T, CommentUserCreateArgs>
    ): Prisma__CommentUserClient<CommentUserGetPayload<T>>

    /**
     * Create many CommentUsers.
     *     @param {CommentUserCreateManyArgs} args - Arguments to create many CommentUsers.
     *     @example
     *     // Create many CommentUsers
     *     const commentUser = await prisma.commentUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentUserCreateManyArgs>(
      args?: SelectSubset<T, CommentUserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommentUser.
     * @param {CommentUserDeleteArgs} args - Arguments to delete one CommentUser.
     * @example
     * // Delete one CommentUser
     * const CommentUser = await prisma.commentUser.delete({
     *   where: {
     *     // ... filter to delete one CommentUser
     *   }
     * })
     * 
    **/
    delete<T extends CommentUserDeleteArgs>(
      args: SelectSubset<T, CommentUserDeleteArgs>
    ): Prisma__CommentUserClient<CommentUserGetPayload<T>>

    /**
     * Update one CommentUser.
     * @param {CommentUserUpdateArgs} args - Arguments to update one CommentUser.
     * @example
     * // Update one CommentUser
     * const commentUser = await prisma.commentUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUserUpdateArgs>(
      args: SelectSubset<T, CommentUserUpdateArgs>
    ): Prisma__CommentUserClient<CommentUserGetPayload<T>>

    /**
     * Delete zero or more CommentUsers.
     * @param {CommentUserDeleteManyArgs} args - Arguments to filter CommentUsers to delete.
     * @example
     * // Delete a few CommentUsers
     * const { count } = await prisma.commentUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentUserDeleteManyArgs>(
      args?: SelectSubset<T, CommentUserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentUsers
     * const commentUser = await prisma.commentUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUserUpdateManyArgs>(
      args: SelectSubset<T, CommentUserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentUser.
     * @param {CommentUserUpsertArgs} args - Arguments to update or create a CommentUser.
     * @example
     * // Update or create a CommentUser
     * const commentUser = await prisma.commentUser.upsert({
     *   create: {
     *     // ... data to create a CommentUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentUser we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUserUpsertArgs>(
      args: SelectSubset<T, CommentUserUpsertArgs>
    ): Prisma__CommentUserClient<CommentUserGetPayload<T>>

    /**
     * Count the number of CommentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserCountArgs} args - Arguments to filter CommentUsers to count.
     * @example
     * // Count the number of CommentUsers
     * const count = await prisma.commentUser.count({
     *   where: {
     *     // ... the filter for the CommentUsers we want to count
     *   }
     * })
    **/
    count<T extends CommentUserCountArgs>(
      args?: Subset<T, CommentUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentUserAggregateArgs>(args: Subset<T, CommentUserAggregateArgs>): Prisma.PrismaPromise<GetCommentUserAggregateType<T>>

    /**
     * Group by CommentUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentUserGroupByArgs['orderBy'] }
        : { orderBy?: CommentUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentUserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CommentUser base type for findUnique actions
   */
  export type CommentUserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * Filter, which CommentUser to fetch.
     */
    where: CommentUserWhereUniqueInput
  }

  /**
   * CommentUser findUnique
   */
  export interface CommentUserFindUniqueArgs extends CommentUserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommentUser findUniqueOrThrow
   */
  export type CommentUserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * Filter, which CommentUser to fetch.
     */
    where: CommentUserWhereUniqueInput
  }


  /**
   * CommentUser base type for findFirst actions
   */
  export type CommentUserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * Filter, which CommentUser to fetch.
     */
    where?: CommentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUsers to fetch.
     */
    orderBy?: Enumerable<CommentUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentUsers.
     */
    cursor?: CommentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentUsers.
     */
    distinct?: Enumerable<CommentUserScalarFieldEnum>
  }

  /**
   * CommentUser findFirst
   */
  export interface CommentUserFindFirstArgs extends CommentUserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommentUser findFirstOrThrow
   */
  export type CommentUserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * Filter, which CommentUser to fetch.
     */
    where?: CommentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUsers to fetch.
     */
    orderBy?: Enumerable<CommentUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentUsers.
     */
    cursor?: CommentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentUsers.
     */
    distinct?: Enumerable<CommentUserScalarFieldEnum>
  }


  /**
   * CommentUser findMany
   */
  export type CommentUserFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * Filter, which CommentUsers to fetch.
     */
    where?: CommentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUsers to fetch.
     */
    orderBy?: Enumerable<CommentUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentUsers.
     */
    cursor?: CommentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUsers.
     */
    skip?: number
    distinct?: Enumerable<CommentUserScalarFieldEnum>
  }


  /**
   * CommentUser create
   */
  export type CommentUserCreateArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * The data needed to create a CommentUser.
     */
    data: XOR<CommentUserCreateInput, CommentUserUncheckedCreateInput>
  }


  /**
   * CommentUser createMany
   */
  export type CommentUserCreateManyArgs = {
    /**
     * The data used to create many CommentUsers.
     */
    data: Enumerable<CommentUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommentUser update
   */
  export type CommentUserUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * The data needed to update a CommentUser.
     */
    data: XOR<CommentUserUpdateInput, CommentUserUncheckedUpdateInput>
    /**
     * Choose, which CommentUser to update.
     */
    where: CommentUserWhereUniqueInput
  }


  /**
   * CommentUser updateMany
   */
  export type CommentUserUpdateManyArgs = {
    /**
     * The data used to update CommentUsers.
     */
    data: XOR<CommentUserUpdateManyMutationInput, CommentUserUncheckedUpdateManyInput>
    /**
     * Filter which CommentUsers to update
     */
    where?: CommentUserWhereInput
  }


  /**
   * CommentUser upsert
   */
  export type CommentUserUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * The filter to search for the CommentUser to update in case it exists.
     */
    where: CommentUserWhereUniqueInput
    /**
     * In case the CommentUser found by the `where` argument doesn't exist, create a new CommentUser with this data.
     */
    create: XOR<CommentUserCreateInput, CommentUserUncheckedCreateInput>
    /**
     * In case the CommentUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUserUpdateInput, CommentUserUncheckedUpdateInput>
  }


  /**
   * CommentUser delete
   */
  export type CommentUserDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
    /**
     * Filter which CommentUser to delete.
     */
    where: CommentUserWhereUniqueInput
  }


  /**
   * CommentUser deleteMany
   */
  export type CommentUserDeleteManyArgs = {
    /**
     * Filter which CommentUsers to delete
     */
    where?: CommentUserWhereInput
  }


  /**
   * CommentUser without action
   */
  export type CommentUserArgs = {
    /**
     * Select specific fields to fetch from the CommentUser
     */
    select?: CommentUserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentUserInclude | null
  }



  /**
   * Model CommentNgo
   */


  export type AggregateCommentNgo = {
    _count: CommentNgoCountAggregateOutputType | null
    _min: CommentNgoMinAggregateOutputType | null
    _max: CommentNgoMaxAggregateOutputType | null
  }

  export type CommentNgoMinAggregateOutputType = {
    id: string | null
    id_comment: string | null
    id_ngo: string | null
  }

  export type CommentNgoMaxAggregateOutputType = {
    id: string | null
    id_comment: string | null
    id_ngo: string | null
  }

  export type CommentNgoCountAggregateOutputType = {
    id: number
    id_comment: number
    id_ngo: number
    _all: number
  }


  export type CommentNgoMinAggregateInputType = {
    id?: true
    id_comment?: true
    id_ngo?: true
  }

  export type CommentNgoMaxAggregateInputType = {
    id?: true
    id_comment?: true
    id_ngo?: true
  }

  export type CommentNgoCountAggregateInputType = {
    id?: true
    id_comment?: true
    id_ngo?: true
    _all?: true
  }

  export type CommentNgoAggregateArgs = {
    /**
     * Filter which CommentNgo to aggregate.
     */
    where?: CommentNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNgos to fetch.
     */
    orderBy?: Enumerable<CommentNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentNgos
    **/
    _count?: true | CommentNgoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentNgoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentNgoMaxAggregateInputType
  }

  export type GetCommentNgoAggregateType<T extends CommentNgoAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentNgo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentNgo[P]>
      : GetScalarType<T[P], AggregateCommentNgo[P]>
  }




  export type CommentNgoGroupByArgs = {
    where?: CommentNgoWhereInput
    orderBy?: Enumerable<CommentNgoOrderByWithAggregationInput>
    by: CommentNgoScalarFieldEnum[]
    having?: CommentNgoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentNgoCountAggregateInputType | true
    _min?: CommentNgoMinAggregateInputType
    _max?: CommentNgoMaxAggregateInputType
  }


  export type CommentNgoGroupByOutputType = {
    id: string
    id_comment: string
    id_ngo: string
    _count: CommentNgoCountAggregateOutputType | null
    _min: CommentNgoMinAggregateOutputType | null
    _max: CommentNgoMaxAggregateOutputType | null
  }

  type GetCommentNgoGroupByPayload<T extends CommentNgoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentNgoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentNgoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentNgoGroupByOutputType[P]>
            : GetScalarType<T[P], CommentNgoGroupByOutputType[P]>
        }
      >
    >


  export type CommentNgoSelect = {
    id?: boolean
    id_comment?: boolean
    id_ngo?: boolean
    comment?: boolean | CommentArgs
    ngo?: boolean | NGOArgs
  }


  export type CommentNgoInclude = {
    comment?: boolean | CommentArgs
    ngo?: boolean | NGOArgs
  }

  export type CommentNgoGetPayload<S extends boolean | null | undefined | CommentNgoArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentNgo :
    S extends undefined ? never :
    S extends { include: any } & (CommentNgoArgs | CommentNgoFindManyArgs)
    ? CommentNgo  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'comment' ? CommentGetPayload<S['include'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentNgoArgs | CommentNgoFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'comment' ? CommentGetPayload<S['select'][P]> :
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> :  P extends keyof CommentNgo ? CommentNgo[P] : never
  } 
      : CommentNgo


  type CommentNgoCountArgs = 
    Omit<CommentNgoFindManyArgs, 'select' | 'include'> & {
      select?: CommentNgoCountAggregateInputType | true
    }

  export interface CommentNgoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CommentNgo that matches the filter.
     * @param {CommentNgoFindUniqueArgs} args - Arguments to find a CommentNgo
     * @example
     * // Get one CommentNgo
     * const commentNgo = await prisma.commentNgo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentNgoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentNgoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommentNgo'> extends True ? Prisma__CommentNgoClient<CommentNgoGetPayload<T>> : Prisma__CommentNgoClient<CommentNgoGetPayload<T> | null, null>

    /**
     * Find one CommentNgo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentNgoFindUniqueOrThrowArgs} args - Arguments to find a CommentNgo
     * @example
     * // Get one CommentNgo
     * const commentNgo = await prisma.commentNgo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentNgoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentNgoFindUniqueOrThrowArgs>
    ): Prisma__CommentNgoClient<CommentNgoGetPayload<T>>

    /**
     * Find the first CommentNgo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoFindFirstArgs} args - Arguments to find a CommentNgo
     * @example
     * // Get one CommentNgo
     * const commentNgo = await prisma.commentNgo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentNgoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentNgoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommentNgo'> extends True ? Prisma__CommentNgoClient<CommentNgoGetPayload<T>> : Prisma__CommentNgoClient<CommentNgoGetPayload<T> | null, null>

    /**
     * Find the first CommentNgo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoFindFirstOrThrowArgs} args - Arguments to find a CommentNgo
     * @example
     * // Get one CommentNgo
     * const commentNgo = await prisma.commentNgo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentNgoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentNgoFindFirstOrThrowArgs>
    ): Prisma__CommentNgoClient<CommentNgoGetPayload<T>>

    /**
     * Find zero or more CommentNgos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentNgos
     * const commentNgos = await prisma.commentNgo.findMany()
     * 
     * // Get first 10 CommentNgos
     * const commentNgos = await prisma.commentNgo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentNgoWithIdOnly = await prisma.commentNgo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentNgoFindManyArgs>(
      args?: SelectSubset<T, CommentNgoFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentNgoGetPayload<T>>>

    /**
     * Create a CommentNgo.
     * @param {CommentNgoCreateArgs} args - Arguments to create a CommentNgo.
     * @example
     * // Create one CommentNgo
     * const CommentNgo = await prisma.commentNgo.create({
     *   data: {
     *     // ... data to create a CommentNgo
     *   }
     * })
     * 
    **/
    create<T extends CommentNgoCreateArgs>(
      args: SelectSubset<T, CommentNgoCreateArgs>
    ): Prisma__CommentNgoClient<CommentNgoGetPayload<T>>

    /**
     * Create many CommentNgos.
     *     @param {CommentNgoCreateManyArgs} args - Arguments to create many CommentNgos.
     *     @example
     *     // Create many CommentNgos
     *     const commentNgo = await prisma.commentNgo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentNgoCreateManyArgs>(
      args?: SelectSubset<T, CommentNgoCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommentNgo.
     * @param {CommentNgoDeleteArgs} args - Arguments to delete one CommentNgo.
     * @example
     * // Delete one CommentNgo
     * const CommentNgo = await prisma.commentNgo.delete({
     *   where: {
     *     // ... filter to delete one CommentNgo
     *   }
     * })
     * 
    **/
    delete<T extends CommentNgoDeleteArgs>(
      args: SelectSubset<T, CommentNgoDeleteArgs>
    ): Prisma__CommentNgoClient<CommentNgoGetPayload<T>>

    /**
     * Update one CommentNgo.
     * @param {CommentNgoUpdateArgs} args - Arguments to update one CommentNgo.
     * @example
     * // Update one CommentNgo
     * const commentNgo = await prisma.commentNgo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentNgoUpdateArgs>(
      args: SelectSubset<T, CommentNgoUpdateArgs>
    ): Prisma__CommentNgoClient<CommentNgoGetPayload<T>>

    /**
     * Delete zero or more CommentNgos.
     * @param {CommentNgoDeleteManyArgs} args - Arguments to filter CommentNgos to delete.
     * @example
     * // Delete a few CommentNgos
     * const { count } = await prisma.commentNgo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentNgoDeleteManyArgs>(
      args?: SelectSubset<T, CommentNgoDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentNgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentNgos
     * const commentNgo = await prisma.commentNgo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentNgoUpdateManyArgs>(
      args: SelectSubset<T, CommentNgoUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentNgo.
     * @param {CommentNgoUpsertArgs} args - Arguments to update or create a CommentNgo.
     * @example
     * // Update or create a CommentNgo
     * const commentNgo = await prisma.commentNgo.upsert({
     *   create: {
     *     // ... data to create a CommentNgo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentNgo we want to update
     *   }
     * })
    **/
    upsert<T extends CommentNgoUpsertArgs>(
      args: SelectSubset<T, CommentNgoUpsertArgs>
    ): Prisma__CommentNgoClient<CommentNgoGetPayload<T>>

    /**
     * Count the number of CommentNgos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoCountArgs} args - Arguments to filter CommentNgos to count.
     * @example
     * // Count the number of CommentNgos
     * const count = await prisma.commentNgo.count({
     *   where: {
     *     // ... the filter for the CommentNgos we want to count
     *   }
     * })
    **/
    count<T extends CommentNgoCountArgs>(
      args?: Subset<T, CommentNgoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentNgoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentNgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentNgoAggregateArgs>(args: Subset<T, CommentNgoAggregateArgs>): Prisma.PrismaPromise<GetCommentNgoAggregateType<T>>

    /**
     * Group by CommentNgo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentNgoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentNgoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentNgoGroupByArgs['orderBy'] }
        : { orderBy?: CommentNgoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentNgoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentNgoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentNgo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentNgoClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CommentNgo base type for findUnique actions
   */
  export type CommentNgoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * Filter, which CommentNgo to fetch.
     */
    where: CommentNgoWhereUniqueInput
  }

  /**
   * CommentNgo findUnique
   */
  export interface CommentNgoFindUniqueArgs extends CommentNgoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommentNgo findUniqueOrThrow
   */
  export type CommentNgoFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * Filter, which CommentNgo to fetch.
     */
    where: CommentNgoWhereUniqueInput
  }


  /**
   * CommentNgo base type for findFirst actions
   */
  export type CommentNgoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * Filter, which CommentNgo to fetch.
     */
    where?: CommentNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNgos to fetch.
     */
    orderBy?: Enumerable<CommentNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentNgos.
     */
    cursor?: CommentNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentNgos.
     */
    distinct?: Enumerable<CommentNgoScalarFieldEnum>
  }

  /**
   * CommentNgo findFirst
   */
  export interface CommentNgoFindFirstArgs extends CommentNgoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommentNgo findFirstOrThrow
   */
  export type CommentNgoFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * Filter, which CommentNgo to fetch.
     */
    where?: CommentNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNgos to fetch.
     */
    orderBy?: Enumerable<CommentNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentNgos.
     */
    cursor?: CommentNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNgos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentNgos.
     */
    distinct?: Enumerable<CommentNgoScalarFieldEnum>
  }


  /**
   * CommentNgo findMany
   */
  export type CommentNgoFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * Filter, which CommentNgos to fetch.
     */
    where?: CommentNgoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentNgos to fetch.
     */
    orderBy?: Enumerable<CommentNgoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentNgos.
     */
    cursor?: CommentNgoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentNgos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentNgos.
     */
    skip?: number
    distinct?: Enumerable<CommentNgoScalarFieldEnum>
  }


  /**
   * CommentNgo create
   */
  export type CommentNgoCreateArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * The data needed to create a CommentNgo.
     */
    data: XOR<CommentNgoCreateInput, CommentNgoUncheckedCreateInput>
  }


  /**
   * CommentNgo createMany
   */
  export type CommentNgoCreateManyArgs = {
    /**
     * The data used to create many CommentNgos.
     */
    data: Enumerable<CommentNgoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommentNgo update
   */
  export type CommentNgoUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * The data needed to update a CommentNgo.
     */
    data: XOR<CommentNgoUpdateInput, CommentNgoUncheckedUpdateInput>
    /**
     * Choose, which CommentNgo to update.
     */
    where: CommentNgoWhereUniqueInput
  }


  /**
   * CommentNgo updateMany
   */
  export type CommentNgoUpdateManyArgs = {
    /**
     * The data used to update CommentNgos.
     */
    data: XOR<CommentNgoUpdateManyMutationInput, CommentNgoUncheckedUpdateManyInput>
    /**
     * Filter which CommentNgos to update
     */
    where?: CommentNgoWhereInput
  }


  /**
   * CommentNgo upsert
   */
  export type CommentNgoUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * The filter to search for the CommentNgo to update in case it exists.
     */
    where: CommentNgoWhereUniqueInput
    /**
     * In case the CommentNgo found by the `where` argument doesn't exist, create a new CommentNgo with this data.
     */
    create: XOR<CommentNgoCreateInput, CommentNgoUncheckedCreateInput>
    /**
     * In case the CommentNgo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentNgoUpdateInput, CommentNgoUncheckedUpdateInput>
  }


  /**
   * CommentNgo delete
   */
  export type CommentNgoDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
    /**
     * Filter which CommentNgo to delete.
     */
    where: CommentNgoWhereUniqueInput
  }


  /**
   * CommentNgo deleteMany
   */
  export type CommentNgoDeleteManyArgs = {
    /**
     * Filter which CommentNgos to delete
     */
    where?: CommentNgoWhereInput
  }


  /**
   * CommentNgo without action
   */
  export type CommentNgoArgs = {
    /**
     * Select specific fields to fetch from the CommentNgo
     */
    select?: CommentNgoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentNgoInclude | null
  }



  /**
   * Model CommentLikes
   */


  export type AggregateCommentLikes = {
    _count: CommentLikesCountAggregateOutputType | null
    _min: CommentLikesMinAggregateOutputType | null
    _max: CommentLikesMaxAggregateOutputType | null
  }

  export type CommentLikesMinAggregateOutputType = {
    id: string | null
    id_comment: string | null
    id_user: string | null
    id_ngo: string | null
  }

  export type CommentLikesMaxAggregateOutputType = {
    id: string | null
    id_comment: string | null
    id_user: string | null
    id_ngo: string | null
  }

  export type CommentLikesCountAggregateOutputType = {
    id: number
    id_comment: number
    id_user: number
    id_ngo: number
    _all: number
  }


  export type CommentLikesMinAggregateInputType = {
    id?: true
    id_comment?: true
    id_user?: true
    id_ngo?: true
  }

  export type CommentLikesMaxAggregateInputType = {
    id?: true
    id_comment?: true
    id_user?: true
    id_ngo?: true
  }

  export type CommentLikesCountAggregateInputType = {
    id?: true
    id_comment?: true
    id_user?: true
    id_ngo?: true
    _all?: true
  }

  export type CommentLikesAggregateArgs = {
    /**
     * Filter which CommentLikes to aggregate.
     */
    where?: CommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentLikes
    **/
    _count?: true | CommentLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentLikesMaxAggregateInputType
  }

  export type GetCommentLikesAggregateType<T extends CommentLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentLikes[P]>
      : GetScalarType<T[P], AggregateCommentLikes[P]>
  }




  export type CommentLikesGroupByArgs = {
    where?: CommentLikesWhereInput
    orderBy?: Enumerable<CommentLikesOrderByWithAggregationInput>
    by: CommentLikesScalarFieldEnum[]
    having?: CommentLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentLikesCountAggregateInputType | true
    _min?: CommentLikesMinAggregateInputType
    _max?: CommentLikesMaxAggregateInputType
  }


  export type CommentLikesGroupByOutputType = {
    id: string
    id_comment: string
    id_user: string | null
    id_ngo: string | null
    _count: CommentLikesCountAggregateOutputType | null
    _min: CommentLikesMinAggregateOutputType | null
    _max: CommentLikesMaxAggregateOutputType | null
  }

  type GetCommentLikesGroupByPayload<T extends CommentLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentLikesGroupByOutputType[P]>
            : GetScalarType<T[P], CommentLikesGroupByOutputType[P]>
        }
      >
    >


  export type CommentLikesSelect = {
    id?: boolean
    id_comment?: boolean
    id_user?: boolean
    id_ngo?: boolean
    ngo?: boolean | NGOArgs
    user?: boolean | UserArgs
    comment?: boolean | CommentArgs
  }


  export type CommentLikesInclude = {
    ngo?: boolean | NGOArgs
    user?: boolean | UserArgs
    comment?: boolean | CommentArgs
  }

  export type CommentLikesGetPayload<S extends boolean | null | undefined | CommentLikesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CommentLikes :
    S extends undefined ? never :
    S extends { include: any } & (CommentLikesArgs | CommentLikesFindManyArgs)
    ? CommentLikes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> | null :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'comment' ? CommentGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CommentLikesArgs | CommentLikesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> | null :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'comment' ? CommentGetPayload<S['select'][P]> :  P extends keyof CommentLikes ? CommentLikes[P] : never
  } 
      : CommentLikes


  type CommentLikesCountArgs = 
    Omit<CommentLikesFindManyArgs, 'select' | 'include'> & {
      select?: CommentLikesCountAggregateInputType | true
    }

  export interface CommentLikesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CommentLikes that matches the filter.
     * @param {CommentLikesFindUniqueArgs} args - Arguments to find a CommentLikes
     * @example
     * // Get one CommentLikes
     * const commentLikes = await prisma.commentLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentLikesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentLikesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CommentLikes'> extends True ? Prisma__CommentLikesClient<CommentLikesGetPayload<T>> : Prisma__CommentLikesClient<CommentLikesGetPayload<T> | null, null>

    /**
     * Find one CommentLikes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentLikesFindUniqueOrThrowArgs} args - Arguments to find a CommentLikes
     * @example
     * // Get one CommentLikes
     * const commentLikes = await prisma.commentLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentLikesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CommentLikesFindUniqueOrThrowArgs>
    ): Prisma__CommentLikesClient<CommentLikesGetPayload<T>>

    /**
     * Find the first CommentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesFindFirstArgs} args - Arguments to find a CommentLikes
     * @example
     * // Get one CommentLikes
     * const commentLikes = await prisma.commentLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentLikesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentLikesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CommentLikes'> extends True ? Prisma__CommentLikesClient<CommentLikesGetPayload<T>> : Prisma__CommentLikesClient<CommentLikesGetPayload<T> | null, null>

    /**
     * Find the first CommentLikes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesFindFirstOrThrowArgs} args - Arguments to find a CommentLikes
     * @example
     * // Get one CommentLikes
     * const commentLikes = await prisma.commentLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentLikesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommentLikesFindFirstOrThrowArgs>
    ): Prisma__CommentLikesClient<CommentLikesGetPayload<T>>

    /**
     * Find zero or more CommentLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentLikes
     * const commentLikes = await prisma.commentLikes.findMany()
     * 
     * // Get first 10 CommentLikes
     * const commentLikes = await prisma.commentLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentLikesWithIdOnly = await prisma.commentLikes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentLikesFindManyArgs>(
      args?: SelectSubset<T, CommentLikesFindManyArgs>
    ): Prisma.PrismaPromise<Array<CommentLikesGetPayload<T>>>

    /**
     * Create a CommentLikes.
     * @param {CommentLikesCreateArgs} args - Arguments to create a CommentLikes.
     * @example
     * // Create one CommentLikes
     * const CommentLikes = await prisma.commentLikes.create({
     *   data: {
     *     // ... data to create a CommentLikes
     *   }
     * })
     * 
    **/
    create<T extends CommentLikesCreateArgs>(
      args: SelectSubset<T, CommentLikesCreateArgs>
    ): Prisma__CommentLikesClient<CommentLikesGetPayload<T>>

    /**
     * Create many CommentLikes.
     *     @param {CommentLikesCreateManyArgs} args - Arguments to create many CommentLikes.
     *     @example
     *     // Create many CommentLikes
     *     const commentLikes = await prisma.commentLikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentLikesCreateManyArgs>(
      args?: SelectSubset<T, CommentLikesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommentLikes.
     * @param {CommentLikesDeleteArgs} args - Arguments to delete one CommentLikes.
     * @example
     * // Delete one CommentLikes
     * const CommentLikes = await prisma.commentLikes.delete({
     *   where: {
     *     // ... filter to delete one CommentLikes
     *   }
     * })
     * 
    **/
    delete<T extends CommentLikesDeleteArgs>(
      args: SelectSubset<T, CommentLikesDeleteArgs>
    ): Prisma__CommentLikesClient<CommentLikesGetPayload<T>>

    /**
     * Update one CommentLikes.
     * @param {CommentLikesUpdateArgs} args - Arguments to update one CommentLikes.
     * @example
     * // Update one CommentLikes
     * const commentLikes = await prisma.commentLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentLikesUpdateArgs>(
      args: SelectSubset<T, CommentLikesUpdateArgs>
    ): Prisma__CommentLikesClient<CommentLikesGetPayload<T>>

    /**
     * Delete zero or more CommentLikes.
     * @param {CommentLikesDeleteManyArgs} args - Arguments to filter CommentLikes to delete.
     * @example
     * // Delete a few CommentLikes
     * const { count } = await prisma.commentLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentLikesDeleteManyArgs>(
      args?: SelectSubset<T, CommentLikesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentLikes
     * const commentLikes = await prisma.commentLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentLikesUpdateManyArgs>(
      args: SelectSubset<T, CommentLikesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentLikes.
     * @param {CommentLikesUpsertArgs} args - Arguments to update or create a CommentLikes.
     * @example
     * // Update or create a CommentLikes
     * const commentLikes = await prisma.commentLikes.upsert({
     *   create: {
     *     // ... data to create a CommentLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentLikes we want to update
     *   }
     * })
    **/
    upsert<T extends CommentLikesUpsertArgs>(
      args: SelectSubset<T, CommentLikesUpsertArgs>
    ): Prisma__CommentLikesClient<CommentLikesGetPayload<T>>

    /**
     * Count the number of CommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesCountArgs} args - Arguments to filter CommentLikes to count.
     * @example
     * // Count the number of CommentLikes
     * const count = await prisma.commentLikes.count({
     *   where: {
     *     // ... the filter for the CommentLikes we want to count
     *   }
     * })
    **/
    count<T extends CommentLikesCountArgs>(
      args?: Subset<T, CommentLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentLikesAggregateArgs>(args: Subset<T, CommentLikesAggregateArgs>): Prisma.PrismaPromise<GetCommentLikesAggregateType<T>>

    /**
     * Group by CommentLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentLikesGroupByArgs['orderBy'] }
        : { orderBy?: CommentLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentLikesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    comment<T extends CommentArgs= {}>(args?: Subset<T, CommentArgs>): Prisma__CommentClient<CommentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CommentLikes base type for findUnique actions
   */
  export type CommentLikesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * Filter, which CommentLikes to fetch.
     */
    where: CommentLikesWhereUniqueInput
  }

  /**
   * CommentLikes findUnique
   */
  export interface CommentLikesFindUniqueArgs extends CommentLikesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommentLikes findUniqueOrThrow
   */
  export type CommentLikesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * Filter, which CommentLikes to fetch.
     */
    where: CommentLikesWhereUniqueInput
  }


  /**
   * CommentLikes base type for findFirst actions
   */
  export type CommentLikesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * Filter, which CommentLikes to fetch.
     */
    where?: CommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentLikes.
     */
    cursor?: CommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentLikes.
     */
    distinct?: Enumerable<CommentLikesScalarFieldEnum>
  }

  /**
   * CommentLikes findFirst
   */
  export interface CommentLikesFindFirstArgs extends CommentLikesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CommentLikes findFirstOrThrow
   */
  export type CommentLikesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * Filter, which CommentLikes to fetch.
     */
    where?: CommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentLikes.
     */
    cursor?: CommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentLikes.
     */
    distinct?: Enumerable<CommentLikesScalarFieldEnum>
  }


  /**
   * CommentLikes findMany
   */
  export type CommentLikesFindManyArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * Filter, which CommentLikes to fetch.
     */
    where?: CommentLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentLikes to fetch.
     */
    orderBy?: Enumerable<CommentLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentLikes.
     */
    cursor?: CommentLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentLikes.
     */
    skip?: number
    distinct?: Enumerable<CommentLikesScalarFieldEnum>
  }


  /**
   * CommentLikes create
   */
  export type CommentLikesCreateArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * The data needed to create a CommentLikes.
     */
    data: XOR<CommentLikesCreateInput, CommentLikesUncheckedCreateInput>
  }


  /**
   * CommentLikes createMany
   */
  export type CommentLikesCreateManyArgs = {
    /**
     * The data used to create many CommentLikes.
     */
    data: Enumerable<CommentLikesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CommentLikes update
   */
  export type CommentLikesUpdateArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * The data needed to update a CommentLikes.
     */
    data: XOR<CommentLikesUpdateInput, CommentLikesUncheckedUpdateInput>
    /**
     * Choose, which CommentLikes to update.
     */
    where: CommentLikesWhereUniqueInput
  }


  /**
   * CommentLikes updateMany
   */
  export type CommentLikesUpdateManyArgs = {
    /**
     * The data used to update CommentLikes.
     */
    data: XOR<CommentLikesUpdateManyMutationInput, CommentLikesUncheckedUpdateManyInput>
    /**
     * Filter which CommentLikes to update
     */
    where?: CommentLikesWhereInput
  }


  /**
   * CommentLikes upsert
   */
  export type CommentLikesUpsertArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * The filter to search for the CommentLikes to update in case it exists.
     */
    where: CommentLikesWhereUniqueInput
    /**
     * In case the CommentLikes found by the `where` argument doesn't exist, create a new CommentLikes with this data.
     */
    create: XOR<CommentLikesCreateInput, CommentLikesUncheckedCreateInput>
    /**
     * In case the CommentLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentLikesUpdateInput, CommentLikesUncheckedUpdateInput>
  }


  /**
   * CommentLikes delete
   */
  export type CommentLikesDeleteArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
    /**
     * Filter which CommentLikes to delete.
     */
    where: CommentLikesWhereUniqueInput
  }


  /**
   * CommentLikes deleteMany
   */
  export type CommentLikesDeleteManyArgs = {
    /**
     * Filter which CommentLikes to delete
     */
    where?: CommentLikesWhereInput
  }


  /**
   * CommentLikes without action
   */
  export type CommentLikesArgs = {
    /**
     * Select specific fields to fetch from the CommentLikes
     */
    select?: CommentLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentLikesInclude | null
  }



  /**
   * Model PostLikes
   */


  export type AggregatePostLikes = {
    _count: PostLikesCountAggregateOutputType | null
    _min: PostLikesMinAggregateOutputType | null
    _max: PostLikesMaxAggregateOutputType | null
  }

  export type PostLikesMinAggregateOutputType = {
    id: string | null
    id_user: string | null
    id_ngo: string | null
    id_post: string | null
  }

  export type PostLikesMaxAggregateOutputType = {
    id: string | null
    id_user: string | null
    id_ngo: string | null
    id_post: string | null
  }

  export type PostLikesCountAggregateOutputType = {
    id: number
    id_user: number
    id_ngo: number
    id_post: number
    _all: number
  }


  export type PostLikesMinAggregateInputType = {
    id?: true
    id_user?: true
    id_ngo?: true
    id_post?: true
  }

  export type PostLikesMaxAggregateInputType = {
    id?: true
    id_user?: true
    id_ngo?: true
    id_post?: true
  }

  export type PostLikesCountAggregateInputType = {
    id?: true
    id_user?: true
    id_ngo?: true
    id_post?: true
    _all?: true
  }

  export type PostLikesAggregateArgs = {
    /**
     * Filter which PostLikes to aggregate.
     */
    where?: PostLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostLikes
    **/
    _count?: true | PostLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostLikesMaxAggregateInputType
  }

  export type GetPostLikesAggregateType<T extends PostLikesAggregateArgs> = {
        [P in keyof T & keyof AggregatePostLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostLikes[P]>
      : GetScalarType<T[P], AggregatePostLikes[P]>
  }




  export type PostLikesGroupByArgs = {
    where?: PostLikesWhereInput
    orderBy?: Enumerable<PostLikesOrderByWithAggregationInput>
    by: PostLikesScalarFieldEnum[]
    having?: PostLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostLikesCountAggregateInputType | true
    _min?: PostLikesMinAggregateInputType
    _max?: PostLikesMaxAggregateInputType
  }


  export type PostLikesGroupByOutputType = {
    id: string
    id_user: string | null
    id_ngo: string | null
    id_post: string
    _count: PostLikesCountAggregateOutputType | null
    _min: PostLikesMinAggregateOutputType | null
    _max: PostLikesMaxAggregateOutputType | null
  }

  type GetPostLikesGroupByPayload<T extends PostLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PostLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostLikesGroupByOutputType[P]>
            : GetScalarType<T[P], PostLikesGroupByOutputType[P]>
        }
      >
    >


  export type PostLikesSelect = {
    id?: boolean
    id_user?: boolean
    id_ngo?: boolean
    id_post?: boolean
    ngo?: boolean | NGOArgs
    user?: boolean | UserArgs
    post?: boolean | PostArgs
  }


  export type PostLikesInclude = {
    ngo?: boolean | NGOArgs
    user?: boolean | UserArgs
    post?: boolean | PostArgs
  }

  export type PostLikesGetPayload<S extends boolean | null | undefined | PostLikesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostLikes :
    S extends undefined ? never :
    S extends { include: any } & (PostLikesArgs | PostLikesFindManyArgs)
    ? PostLikes  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> | null :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'post' ? PostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostLikesArgs | PostLikesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> | null :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'post' ? PostGetPayload<S['select'][P]> :  P extends keyof PostLikes ? PostLikes[P] : never
  } 
      : PostLikes


  type PostLikesCountArgs = 
    Omit<PostLikesFindManyArgs, 'select' | 'include'> & {
      select?: PostLikesCountAggregateInputType | true
    }

  export interface PostLikesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one PostLikes that matches the filter.
     * @param {PostLikesFindUniqueArgs} args - Arguments to find a PostLikes
     * @example
     * // Get one PostLikes
     * const postLikes = await prisma.postLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostLikesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostLikesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostLikes'> extends True ? Prisma__PostLikesClient<PostLikesGetPayload<T>> : Prisma__PostLikesClient<PostLikesGetPayload<T> | null, null>

    /**
     * Find one PostLikes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostLikesFindUniqueOrThrowArgs} args - Arguments to find a PostLikes
     * @example
     * // Get one PostLikes
     * const postLikes = await prisma.postLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostLikesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostLikesFindUniqueOrThrowArgs>
    ): Prisma__PostLikesClient<PostLikesGetPayload<T>>

    /**
     * Find the first PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesFindFirstArgs} args - Arguments to find a PostLikes
     * @example
     * // Get one PostLikes
     * const postLikes = await prisma.postLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostLikesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostLikesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostLikes'> extends True ? Prisma__PostLikesClient<PostLikesGetPayload<T>> : Prisma__PostLikesClient<PostLikesGetPayload<T> | null, null>

    /**
     * Find the first PostLikes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesFindFirstOrThrowArgs} args - Arguments to find a PostLikes
     * @example
     * // Get one PostLikes
     * const postLikes = await prisma.postLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostLikesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostLikesFindFirstOrThrowArgs>
    ): Prisma__PostLikesClient<PostLikesGetPayload<T>>

    /**
     * Find zero or more PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostLikes
     * const postLikes = await prisma.postLikes.findMany()
     * 
     * // Get first 10 PostLikes
     * const postLikes = await prisma.postLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postLikesWithIdOnly = await prisma.postLikes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostLikesFindManyArgs>(
      args?: SelectSubset<T, PostLikesFindManyArgs>
    ): Prisma.PrismaPromise<Array<PostLikesGetPayload<T>>>

    /**
     * Create a PostLikes.
     * @param {PostLikesCreateArgs} args - Arguments to create a PostLikes.
     * @example
     * // Create one PostLikes
     * const PostLikes = await prisma.postLikes.create({
     *   data: {
     *     // ... data to create a PostLikes
     *   }
     * })
     * 
    **/
    create<T extends PostLikesCreateArgs>(
      args: SelectSubset<T, PostLikesCreateArgs>
    ): Prisma__PostLikesClient<PostLikesGetPayload<T>>

    /**
     * Create many PostLikes.
     *     @param {PostLikesCreateManyArgs} args - Arguments to create many PostLikes.
     *     @example
     *     // Create many PostLikes
     *     const postLikes = await prisma.postLikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostLikesCreateManyArgs>(
      args?: SelectSubset<T, PostLikesCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PostLikes.
     * @param {PostLikesDeleteArgs} args - Arguments to delete one PostLikes.
     * @example
     * // Delete one PostLikes
     * const PostLikes = await prisma.postLikes.delete({
     *   where: {
     *     // ... filter to delete one PostLikes
     *   }
     * })
     * 
    **/
    delete<T extends PostLikesDeleteArgs>(
      args: SelectSubset<T, PostLikesDeleteArgs>
    ): Prisma__PostLikesClient<PostLikesGetPayload<T>>

    /**
     * Update one PostLikes.
     * @param {PostLikesUpdateArgs} args - Arguments to update one PostLikes.
     * @example
     * // Update one PostLikes
     * const postLikes = await prisma.postLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostLikesUpdateArgs>(
      args: SelectSubset<T, PostLikesUpdateArgs>
    ): Prisma__PostLikesClient<PostLikesGetPayload<T>>

    /**
     * Delete zero or more PostLikes.
     * @param {PostLikesDeleteManyArgs} args - Arguments to filter PostLikes to delete.
     * @example
     * // Delete a few PostLikes
     * const { count } = await prisma.postLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostLikesDeleteManyArgs>(
      args?: SelectSubset<T, PostLikesDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostLikes
     * const postLikes = await prisma.postLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostLikesUpdateManyArgs>(
      args: SelectSubset<T, PostLikesUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostLikes.
     * @param {PostLikesUpsertArgs} args - Arguments to update or create a PostLikes.
     * @example
     * // Update or create a PostLikes
     * const postLikes = await prisma.postLikes.upsert({
     *   create: {
     *     // ... data to create a PostLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostLikes we want to update
     *   }
     * })
    **/
    upsert<T extends PostLikesUpsertArgs>(
      args: SelectSubset<T, PostLikesUpsertArgs>
    ): Prisma__PostLikesClient<PostLikesGetPayload<T>>

    /**
     * Count the number of PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesCountArgs} args - Arguments to filter PostLikes to count.
     * @example
     * // Count the number of PostLikes
     * const count = await prisma.postLikes.count({
     *   where: {
     *     // ... the filter for the PostLikes we want to count
     *   }
     * })
    **/
    count<T extends PostLikesCountArgs>(
      args?: Subset<T, PostLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostLikesAggregateArgs>(args: Subset<T, PostLikesAggregateArgs>): Prisma.PrismaPromise<GetPostLikesAggregateType<T>>

    /**
     * Group by PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostLikesGroupByArgs['orderBy'] }
        : { orderBy?: PostLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostLikesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostLikes base type for findUnique actions
   */
  export type PostLikesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where: PostLikesWhereUniqueInput
  }

  /**
   * PostLikes findUnique
   */
  export interface PostLikesFindUniqueArgs extends PostLikesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostLikes findUniqueOrThrow
   */
  export type PostLikesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where: PostLikesWhereUniqueInput
  }


  /**
   * PostLikes base type for findFirst actions
   */
  export type PostLikesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: Enumerable<PostLikesScalarFieldEnum>
  }

  /**
   * PostLikes findFirst
   */
  export interface PostLikesFindFirstArgs extends PostLikesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostLikes findFirstOrThrow
   */
  export type PostLikesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     */
    cursor?: PostLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     */
    distinct?: Enumerable<PostLikesScalarFieldEnum>
  }


  /**
   * PostLikes findMany
   */
  export type PostLikesFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * Filter, which PostLikes to fetch.
     */
    where?: PostLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     */
    orderBy?: Enumerable<PostLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostLikes.
     */
    cursor?: PostLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     */
    skip?: number
    distinct?: Enumerable<PostLikesScalarFieldEnum>
  }


  /**
   * PostLikes create
   */
  export type PostLikesCreateArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * The data needed to create a PostLikes.
     */
    data: XOR<PostLikesCreateInput, PostLikesUncheckedCreateInput>
  }


  /**
   * PostLikes createMany
   */
  export type PostLikesCreateManyArgs = {
    /**
     * The data used to create many PostLikes.
     */
    data: Enumerable<PostLikesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostLikes update
   */
  export type PostLikesUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * The data needed to update a PostLikes.
     */
    data: XOR<PostLikesUpdateInput, PostLikesUncheckedUpdateInput>
    /**
     * Choose, which PostLikes to update.
     */
    where: PostLikesWhereUniqueInput
  }


  /**
   * PostLikes updateMany
   */
  export type PostLikesUpdateManyArgs = {
    /**
     * The data used to update PostLikes.
     */
    data: XOR<PostLikesUpdateManyMutationInput, PostLikesUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     */
    where?: PostLikesWhereInput
  }


  /**
   * PostLikes upsert
   */
  export type PostLikesUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * The filter to search for the PostLikes to update in case it exists.
     */
    where: PostLikesWhereUniqueInput
    /**
     * In case the PostLikes found by the `where` argument doesn't exist, create a new PostLikes with this data.
     */
    create: XOR<PostLikesCreateInput, PostLikesUncheckedCreateInput>
    /**
     * In case the PostLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostLikesUpdateInput, PostLikesUncheckedUpdateInput>
  }


  /**
   * PostLikes delete
   */
  export type PostLikesDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
    /**
     * Filter which PostLikes to delete.
     */
    where: PostLikesWhereUniqueInput
  }


  /**
   * PostLikes deleteMany
   */
  export type PostLikesDeleteManyArgs = {
    /**
     * Filter which PostLikes to delete
     */
    where?: PostLikesWhereInput
  }


  /**
   * PostLikes without action
   */
  export type PostLikesArgs = {
    /**
     * Select specific fields to fetch from the PostLikes
     */
    select?: PostLikesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PostLikesInclude | null
  }



  /**
   * Model AttachedLink
   */


  export type AggregateAttachedLink = {
    _count: AttachedLinkCountAggregateOutputType | null
    _min: AttachedLinkMinAggregateOutputType | null
    _max: AttachedLinkMaxAggregateOutputType | null
  }

  export type AttachedLinkMinAggregateOutputType = {
    id: string | null
    attached_link: string | null
    id_source: string | null
    id_user: string | null
    id_ngo: string | null
  }

  export type AttachedLinkMaxAggregateOutputType = {
    id: string | null
    attached_link: string | null
    id_source: string | null
    id_user: string | null
    id_ngo: string | null
  }

  export type AttachedLinkCountAggregateOutputType = {
    id: number
    attached_link: number
    id_source: number
    id_user: number
    id_ngo: number
    _all: number
  }


  export type AttachedLinkMinAggregateInputType = {
    id?: true
    attached_link?: true
    id_source?: true
    id_user?: true
    id_ngo?: true
  }

  export type AttachedLinkMaxAggregateInputType = {
    id?: true
    attached_link?: true
    id_source?: true
    id_user?: true
    id_ngo?: true
  }

  export type AttachedLinkCountAggregateInputType = {
    id?: true
    attached_link?: true
    id_source?: true
    id_user?: true
    id_ngo?: true
    _all?: true
  }

  export type AttachedLinkAggregateArgs = {
    /**
     * Filter which AttachedLink to aggregate.
     */
    where?: AttachedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachedLinks to fetch.
     */
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttachedLinks
    **/
    _count?: true | AttachedLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachedLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachedLinkMaxAggregateInputType
  }

  export type GetAttachedLinkAggregateType<T extends AttachedLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachedLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachedLink[P]>
      : GetScalarType<T[P], AggregateAttachedLink[P]>
  }




  export type AttachedLinkGroupByArgs = {
    where?: AttachedLinkWhereInput
    orderBy?: Enumerable<AttachedLinkOrderByWithAggregationInput>
    by: AttachedLinkScalarFieldEnum[]
    having?: AttachedLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachedLinkCountAggregateInputType | true
    _min?: AttachedLinkMinAggregateInputType
    _max?: AttachedLinkMaxAggregateInputType
  }


  export type AttachedLinkGroupByOutputType = {
    id: string
    attached_link: string
    id_source: string
    id_user: string | null
    id_ngo: string | null
    _count: AttachedLinkCountAggregateOutputType | null
    _min: AttachedLinkMinAggregateOutputType | null
    _max: AttachedLinkMaxAggregateOutputType | null
  }

  type GetAttachedLinkGroupByPayload<T extends AttachedLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AttachedLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachedLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachedLinkGroupByOutputType[P]>
            : GetScalarType<T[P], AttachedLinkGroupByOutputType[P]>
        }
      >
    >


  export type AttachedLinkSelect = {
    id?: boolean
    attached_link?: boolean
    id_source?: boolean
    id_user?: boolean
    id_ngo?: boolean
    source?: boolean | SourceArgs
    user?: boolean | UserArgs
    ngo?: boolean | NGOArgs
  }


  export type AttachedLinkInclude = {
    source?: boolean | SourceArgs
    user?: boolean | UserArgs
    ngo?: boolean | NGOArgs
  }

  export type AttachedLinkGetPayload<S extends boolean | null | undefined | AttachedLinkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AttachedLink :
    S extends undefined ? never :
    S extends { include: any } & (AttachedLinkArgs | AttachedLinkFindManyArgs)
    ? AttachedLink  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'source' ? SourceGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'ngo' ? NGOGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (AttachedLinkArgs | AttachedLinkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'source' ? SourceGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'ngo' ? NGOGetPayload<S['select'][P]> | null :  P extends keyof AttachedLink ? AttachedLink[P] : never
  } 
      : AttachedLink


  type AttachedLinkCountArgs = 
    Omit<AttachedLinkFindManyArgs, 'select' | 'include'> & {
      select?: AttachedLinkCountAggregateInputType | true
    }

  export interface AttachedLinkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AttachedLink that matches the filter.
     * @param {AttachedLinkFindUniqueArgs} args - Arguments to find a AttachedLink
     * @example
     * // Get one AttachedLink
     * const attachedLink = await prisma.attachedLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttachedLinkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttachedLinkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttachedLink'> extends True ? Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>> : Prisma__AttachedLinkClient<AttachedLinkGetPayload<T> | null, null>

    /**
     * Find one AttachedLink that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AttachedLinkFindUniqueOrThrowArgs} args - Arguments to find a AttachedLink
     * @example
     * // Get one AttachedLink
     * const attachedLink = await prisma.attachedLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AttachedLinkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AttachedLinkFindUniqueOrThrowArgs>
    ): Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>>

    /**
     * Find the first AttachedLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkFindFirstArgs} args - Arguments to find a AttachedLink
     * @example
     * // Get one AttachedLink
     * const attachedLink = await prisma.attachedLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttachedLinkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttachedLinkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttachedLink'> extends True ? Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>> : Prisma__AttachedLinkClient<AttachedLinkGetPayload<T> | null, null>

    /**
     * Find the first AttachedLink that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkFindFirstOrThrowArgs} args - Arguments to find a AttachedLink
     * @example
     * // Get one AttachedLink
     * const attachedLink = await prisma.attachedLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AttachedLinkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttachedLinkFindFirstOrThrowArgs>
    ): Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>>

    /**
     * Find zero or more AttachedLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttachedLinks
     * const attachedLinks = await prisma.attachedLink.findMany()
     * 
     * // Get first 10 AttachedLinks
     * const attachedLinks = await prisma.attachedLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachedLinkWithIdOnly = await prisma.attachedLink.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttachedLinkFindManyArgs>(
      args?: SelectSubset<T, AttachedLinkFindManyArgs>
    ): Prisma.PrismaPromise<Array<AttachedLinkGetPayload<T>>>

    /**
     * Create a AttachedLink.
     * @param {AttachedLinkCreateArgs} args - Arguments to create a AttachedLink.
     * @example
     * // Create one AttachedLink
     * const AttachedLink = await prisma.attachedLink.create({
     *   data: {
     *     // ... data to create a AttachedLink
     *   }
     * })
     * 
    **/
    create<T extends AttachedLinkCreateArgs>(
      args: SelectSubset<T, AttachedLinkCreateArgs>
    ): Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>>

    /**
     * Create many AttachedLinks.
     *     @param {AttachedLinkCreateManyArgs} args - Arguments to create many AttachedLinks.
     *     @example
     *     // Create many AttachedLinks
     *     const attachedLink = await prisma.attachedLink.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttachedLinkCreateManyArgs>(
      args?: SelectSubset<T, AttachedLinkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttachedLink.
     * @param {AttachedLinkDeleteArgs} args - Arguments to delete one AttachedLink.
     * @example
     * // Delete one AttachedLink
     * const AttachedLink = await prisma.attachedLink.delete({
     *   where: {
     *     // ... filter to delete one AttachedLink
     *   }
     * })
     * 
    **/
    delete<T extends AttachedLinkDeleteArgs>(
      args: SelectSubset<T, AttachedLinkDeleteArgs>
    ): Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>>

    /**
     * Update one AttachedLink.
     * @param {AttachedLinkUpdateArgs} args - Arguments to update one AttachedLink.
     * @example
     * // Update one AttachedLink
     * const attachedLink = await prisma.attachedLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttachedLinkUpdateArgs>(
      args: SelectSubset<T, AttachedLinkUpdateArgs>
    ): Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>>

    /**
     * Delete zero or more AttachedLinks.
     * @param {AttachedLinkDeleteManyArgs} args - Arguments to filter AttachedLinks to delete.
     * @example
     * // Delete a few AttachedLinks
     * const { count } = await prisma.attachedLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttachedLinkDeleteManyArgs>(
      args?: SelectSubset<T, AttachedLinkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttachedLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttachedLinks
     * const attachedLink = await prisma.attachedLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttachedLinkUpdateManyArgs>(
      args: SelectSubset<T, AttachedLinkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttachedLink.
     * @param {AttachedLinkUpsertArgs} args - Arguments to update or create a AttachedLink.
     * @example
     * // Update or create a AttachedLink
     * const attachedLink = await prisma.attachedLink.upsert({
     *   create: {
     *     // ... data to create a AttachedLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttachedLink we want to update
     *   }
     * })
    **/
    upsert<T extends AttachedLinkUpsertArgs>(
      args: SelectSubset<T, AttachedLinkUpsertArgs>
    ): Prisma__AttachedLinkClient<AttachedLinkGetPayload<T>>

    /**
     * Count the number of AttachedLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkCountArgs} args - Arguments to filter AttachedLinks to count.
     * @example
     * // Count the number of AttachedLinks
     * const count = await prisma.attachedLink.count({
     *   where: {
     *     // ... the filter for the AttachedLinks we want to count
     *   }
     * })
    **/
    count<T extends AttachedLinkCountArgs>(
      args?: Subset<T, AttachedLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachedLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttachedLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachedLinkAggregateArgs>(args: Subset<T, AttachedLinkAggregateArgs>): Prisma.PrismaPromise<GetAttachedLinkAggregateType<T>>

    /**
     * Group by AttachedLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachedLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachedLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachedLinkGroupByArgs['orderBy'] }
        : { orderBy?: AttachedLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachedLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachedLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AttachedLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttachedLinkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    source<T extends SourceArgs= {}>(args?: Subset<T, SourceArgs>): Prisma__SourceClient<SourceGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    ngo<T extends NGOArgs= {}>(args?: Subset<T, NGOArgs>): Prisma__NGOClient<NGOGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AttachedLink base type for findUnique actions
   */
  export type AttachedLinkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * Filter, which AttachedLink to fetch.
     */
    where: AttachedLinkWhereUniqueInput
  }

  /**
   * AttachedLink findUnique
   */
  export interface AttachedLinkFindUniqueArgs extends AttachedLinkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttachedLink findUniqueOrThrow
   */
  export type AttachedLinkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * Filter, which AttachedLink to fetch.
     */
    where: AttachedLinkWhereUniqueInput
  }


  /**
   * AttachedLink base type for findFirst actions
   */
  export type AttachedLinkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * Filter, which AttachedLink to fetch.
     */
    where?: AttachedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachedLinks to fetch.
     */
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttachedLinks.
     */
    cursor?: AttachedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttachedLinks.
     */
    distinct?: Enumerable<AttachedLinkScalarFieldEnum>
  }

  /**
   * AttachedLink findFirst
   */
  export interface AttachedLinkFindFirstArgs extends AttachedLinkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttachedLink findFirstOrThrow
   */
  export type AttachedLinkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * Filter, which AttachedLink to fetch.
     */
    where?: AttachedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachedLinks to fetch.
     */
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttachedLinks.
     */
    cursor?: AttachedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachedLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttachedLinks.
     */
    distinct?: Enumerable<AttachedLinkScalarFieldEnum>
  }


  /**
   * AttachedLink findMany
   */
  export type AttachedLinkFindManyArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * Filter, which AttachedLinks to fetch.
     */
    where?: AttachedLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttachedLinks to fetch.
     */
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttachedLinks.
     */
    cursor?: AttachedLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttachedLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttachedLinks.
     */
    skip?: number
    distinct?: Enumerable<AttachedLinkScalarFieldEnum>
  }


  /**
   * AttachedLink create
   */
  export type AttachedLinkCreateArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * The data needed to create a AttachedLink.
     */
    data: XOR<AttachedLinkCreateInput, AttachedLinkUncheckedCreateInput>
  }


  /**
   * AttachedLink createMany
   */
  export type AttachedLinkCreateManyArgs = {
    /**
     * The data used to create many AttachedLinks.
     */
    data: Enumerable<AttachedLinkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AttachedLink update
   */
  export type AttachedLinkUpdateArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * The data needed to update a AttachedLink.
     */
    data: XOR<AttachedLinkUpdateInput, AttachedLinkUncheckedUpdateInput>
    /**
     * Choose, which AttachedLink to update.
     */
    where: AttachedLinkWhereUniqueInput
  }


  /**
   * AttachedLink updateMany
   */
  export type AttachedLinkUpdateManyArgs = {
    /**
     * The data used to update AttachedLinks.
     */
    data: XOR<AttachedLinkUpdateManyMutationInput, AttachedLinkUncheckedUpdateManyInput>
    /**
     * Filter which AttachedLinks to update
     */
    where?: AttachedLinkWhereInput
  }


  /**
   * AttachedLink upsert
   */
  export type AttachedLinkUpsertArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * The filter to search for the AttachedLink to update in case it exists.
     */
    where: AttachedLinkWhereUniqueInput
    /**
     * In case the AttachedLink found by the `where` argument doesn't exist, create a new AttachedLink with this data.
     */
    create: XOR<AttachedLinkCreateInput, AttachedLinkUncheckedCreateInput>
    /**
     * In case the AttachedLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachedLinkUpdateInput, AttachedLinkUncheckedUpdateInput>
  }


  /**
   * AttachedLink delete
   */
  export type AttachedLinkDeleteArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    /**
     * Filter which AttachedLink to delete.
     */
    where: AttachedLinkWhereUniqueInput
  }


  /**
   * AttachedLink deleteMany
   */
  export type AttachedLinkDeleteManyArgs = {
    /**
     * Filter which AttachedLinks to delete
     */
    where?: AttachedLinkWhereInput
  }


  /**
   * AttachedLink without action
   */
  export type AttachedLinkArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
  }



  /**
   * Model Source
   */


  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SourceMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SourceAggregateArgs = {
    /**
     * Filter which Source to aggregate.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs = {
    where?: SourceWhereInput
    orderBy?: Enumerable<SourceOrderByWithAggregationInput>
    by: SourceScalarFieldEnum[]
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }


  export type SourceGroupByOutputType = {
    id: string
    name: string
    _count: SourceCountAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect = {
    id?: boolean
    name?: boolean
    attached_link?: boolean | Source$attached_linkArgs
    _count?: boolean | SourceCountOutputTypeArgs
  }


  export type SourceInclude = {
    attached_link?: boolean | Source$attached_linkArgs
    _count?: boolean | SourceCountOutputTypeArgs
  }

  export type SourceGetPayload<S extends boolean | null | undefined | SourceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Source :
    S extends undefined ? never :
    S extends { include: any } & (SourceArgs | SourceFindManyArgs)
    ? Source  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'attached_link' ? Array < AttachedLinkGetPayload<S['include'][P]>>  :
        P extends '_count' ? SourceCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SourceArgs | SourceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'attached_link' ? Array < AttachedLinkGetPayload<S['select'][P]>>  :
        P extends '_count' ? SourceCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Source ? Source[P] : never
  } 
      : Source


  type SourceCountArgs = 
    Omit<SourceFindManyArgs, 'select' | 'include'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface SourceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SourceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SourceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Source'> extends True ? Prisma__SourceClient<SourceGetPayload<T>> : Prisma__SourceClient<SourceGetPayload<T> | null, null>

    /**
     * Find one Source that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SourceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SourceFindUniqueOrThrowArgs>
    ): Prisma__SourceClient<SourceGetPayload<T>>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SourceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SourceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Source'> extends True ? Prisma__SourceClient<SourceGetPayload<T>> : Prisma__SourceClient<SourceGetPayload<T> | null, null>

    /**
     * Find the first Source that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SourceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SourceFindFirstOrThrowArgs>
    ): Prisma__SourceClient<SourceGetPayload<T>>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SourceFindManyArgs>(
      args?: SelectSubset<T, SourceFindManyArgs>
    ): Prisma.PrismaPromise<Array<SourceGetPayload<T>>>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
    **/
    create<T extends SourceCreateArgs>(
      args: SelectSubset<T, SourceCreateArgs>
    ): Prisma__SourceClient<SourceGetPayload<T>>

    /**
     * Create many Sources.
     *     @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     *     @example
     *     // Create many Sources
     *     const source = await prisma.source.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SourceCreateManyArgs>(
      args?: SelectSubset<T, SourceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
    **/
    delete<T extends SourceDeleteArgs>(
      args: SelectSubset<T, SourceDeleteArgs>
    ): Prisma__SourceClient<SourceGetPayload<T>>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SourceUpdateArgs>(
      args: SelectSubset<T, SourceUpdateArgs>
    ): Prisma__SourceClient<SourceGetPayload<T>>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SourceDeleteManyArgs>(
      args?: SelectSubset<T, SourceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SourceUpdateManyArgs>(
      args: SelectSubset<T, SourceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
    **/
    upsert<T extends SourceUpsertArgs>(
      args: SelectSubset<T, SourceUpsertArgs>
    ): Prisma__SourceClient<SourceGetPayload<T>>

    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SourceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    attached_link<T extends Source$attached_linkArgs= {}>(args?: Subset<T, Source$attached_linkArgs>): Prisma.PrismaPromise<Array<AttachedLinkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Source base type for findUnique actions
   */
  export type SourceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findUnique
   */
  export interface SourceFindUniqueArgs extends SourceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Source findUniqueOrThrow
   */
  export type SourceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }


  /**
   * Source base type for findFirst actions
   */
  export type SourceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: Enumerable<SourceScalarFieldEnum>
  }

  /**
   * Source findFirst
   */
  export interface SourceFindFirstArgs extends SourceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Source findFirstOrThrow
   */
  export type SourceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: Enumerable<SourceScalarFieldEnum>
  }


  /**
   * Source findMany
   */
  export type SourceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: Enumerable<SourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: Enumerable<SourceScalarFieldEnum>
  }


  /**
   * Source create
   */
  export type SourceCreateArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * The data needed to create a Source.
     */
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }


  /**
   * Source createMany
   */
  export type SourceCreateManyArgs = {
    /**
     * The data used to create many Sources.
     */
    data: Enumerable<SourceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Source update
   */
  export type SourceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * The data needed to update a Source.
     */
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     */
    where: SourceWhereUniqueInput
  }


  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
  }


  /**
   * Source upsert
   */
  export type SourceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * The filter to search for the Source to update in case it exists.
     */
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     */
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }


  /**
   * Source delete
   */
  export type SourceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
    /**
     * Filter which Source to delete.
     */
    where: SourceWhereUniqueInput
  }


  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs = {
    /**
     * Filter which Sources to delete
     */
    where?: SourceWhereInput
  }


  /**
   * Source.attached_link
   */
  export type Source$attached_linkArgs = {
    /**
     * Select specific fields to fetch from the AttachedLink
     */
    select?: AttachedLinkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AttachedLinkInclude | null
    where?: AttachedLinkWhereInput
    orderBy?: Enumerable<AttachedLinkOrderByWithRelationInput>
    cursor?: AttachedLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AttachedLinkScalarFieldEnum>
  }


  /**
   * Source without action
   */
  export type SourceArgs = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SourceInclude | null
  }



  /**
   * Model Status
   */


  export type AggregateStatus = {
    _count: StatusCountAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  export type StatusMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type StatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type StatusCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type StatusMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type StatusMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type StatusCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type StatusAggregateArgs = {
    /**
     * Filter which Status to aggregate.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Statuses
    **/
    _count?: true | StatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusMaxAggregateInputType
  }

  export type GetStatusAggregateType<T extends StatusAggregateArgs> = {
        [P in keyof T & keyof AggregateStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus[P]>
      : GetScalarType<T[P], AggregateStatus[P]>
  }




  export type StatusGroupByArgs = {
    where?: StatusWhereInput
    orderBy?: Enumerable<StatusOrderByWithAggregationInput>
    by: StatusScalarFieldEnum[]
    having?: StatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusCountAggregateInputType | true
    _min?: StatusMinAggregateInputType
    _max?: StatusMaxAggregateInputType
  }


  export type StatusGroupByOutputType = {
    id: string
    name: string
    _count: StatusCountAggregateOutputType | null
    _min: StatusMinAggregateOutputType | null
    _max: StatusMaxAggregateOutputType | null
  }

  type GetStatusGroupByPayload<T extends StatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusGroupByOutputType[P]>
            : GetScalarType<T[P], StatusGroupByOutputType[P]>
        }
      >
    >


  export type StatusSelect = {
    id?: boolean
    name?: boolean
    CampaignParticipants?: boolean | Status$CampaignParticipantsArgs
    Following?: boolean | Status$FollowingArgs
    _count?: boolean | StatusCountOutputTypeArgs
  }


  export type StatusInclude = {
    CampaignParticipants?: boolean | Status$CampaignParticipantsArgs
    Following?: boolean | Status$FollowingArgs
    _count?: boolean | StatusCountOutputTypeArgs
  }

  export type StatusGetPayload<S extends boolean | null | undefined | StatusArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Status :
    S extends undefined ? never :
    S extends { include: any } & (StatusArgs | StatusFindManyArgs)
    ? Status  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'CampaignParticipants' ? Array < CampaignParticipantsGetPayload<S['include'][P]>>  :
        P extends 'Following' ? Array < FollowingGetPayload<S['include'][P]>>  :
        P extends '_count' ? StatusCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StatusArgs | StatusFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'CampaignParticipants' ? Array < CampaignParticipantsGetPayload<S['select'][P]>>  :
        P extends 'Following' ? Array < FollowingGetPayload<S['select'][P]>>  :
        P extends '_count' ? StatusCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Status ? Status[P] : never
  } 
      : Status


  type StatusCountArgs = 
    Omit<StatusFindManyArgs, 'select' | 'include'> & {
      select?: StatusCountAggregateInputType | true
    }

  export interface StatusDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Status that matches the filter.
     * @param {StatusFindUniqueArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Status'> extends True ? Prisma__StatusClient<StatusGetPayload<T>> : Prisma__StatusClient<StatusGetPayload<T> | null, null>

    /**
     * Find one Status that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StatusFindUniqueOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StatusFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StatusFindUniqueOrThrowArgs>
    ): Prisma__StatusClient<StatusGetPayload<T>>

    /**
     * Find the first Status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindFirstArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Status'> extends True ? Prisma__StatusClient<StatusGetPayload<T>> : Prisma__StatusClient<StatusGetPayload<T> | null, null>

    /**
     * Find the first Status that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindFirstOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StatusFindFirstOrThrowArgs>
    ): Prisma__StatusClient<StatusGetPayload<T>>

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.status.findMany()
     * 
     * // Get first 10 Statuses
     * const statuses = await prisma.status.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusWithIdOnly = await prisma.status.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StatusFindManyArgs>(
      args?: SelectSubset<T, StatusFindManyArgs>
    ): Prisma.PrismaPromise<Array<StatusGetPayload<T>>>

    /**
     * Create a Status.
     * @param {StatusCreateArgs} args - Arguments to create a Status.
     * @example
     * // Create one Status
     * const Status = await prisma.status.create({
     *   data: {
     *     // ... data to create a Status
     *   }
     * })
     * 
    **/
    create<T extends StatusCreateArgs>(
      args: SelectSubset<T, StatusCreateArgs>
    ): Prisma__StatusClient<StatusGetPayload<T>>

    /**
     * Create many Statuses.
     *     @param {StatusCreateManyArgs} args - Arguments to create many Statuses.
     *     @example
     *     // Create many Statuses
     *     const status = await prisma.status.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StatusCreateManyArgs>(
      args?: SelectSubset<T, StatusCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Status.
     * @param {StatusDeleteArgs} args - Arguments to delete one Status.
     * @example
     * // Delete one Status
     * const Status = await prisma.status.delete({
     *   where: {
     *     // ... filter to delete one Status
     *   }
     * })
     * 
    **/
    delete<T extends StatusDeleteArgs>(
      args: SelectSubset<T, StatusDeleteArgs>
    ): Prisma__StatusClient<StatusGetPayload<T>>

    /**
     * Update one Status.
     * @param {StatusUpdateArgs} args - Arguments to update one Status.
     * @example
     * // Update one Status
     * const status = await prisma.status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StatusUpdateArgs>(
      args: SelectSubset<T, StatusUpdateArgs>
    ): Prisma__StatusClient<StatusGetPayload<T>>

    /**
     * Delete zero or more Statuses.
     * @param {StatusDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StatusDeleteManyArgs>(
      args?: SelectSubset<T, StatusDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StatusUpdateManyArgs>(
      args: SelectSubset<T, StatusUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Status.
     * @param {StatusUpsertArgs} args - Arguments to update or create a Status.
     * @example
     * // Update or create a Status
     * const status = await prisma.status.upsert({
     *   create: {
     *     // ... data to create a Status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status we want to update
     *   }
     * })
    **/
    upsert<T extends StatusUpsertArgs>(
      args: SelectSubset<T, StatusUpsertArgs>
    ): Prisma__StatusClient<StatusGetPayload<T>>

    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.status.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
    **/
    count<T extends StatusCountArgs>(
      args?: Subset<T, StatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusAggregateArgs>(args: Subset<T, StatusAggregateArgs>): Prisma.PrismaPromise<GetStatusAggregateType<T>>

    /**
     * Group by Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusGroupByArgs['orderBy'] }
        : { orderBy?: StatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StatusClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    CampaignParticipants<T extends Status$CampaignParticipantsArgs= {}>(args?: Subset<T, Status$CampaignParticipantsArgs>): Prisma.PrismaPromise<Array<CampaignParticipantsGetPayload<T>>| Null>;

    Following<T extends Status$FollowingArgs= {}>(args?: Subset<T, Status$FollowingArgs>): Prisma.PrismaPromise<Array<FollowingGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Status base type for findUnique actions
   */
  export type StatusFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * Filter, which Status to fetch.
     */
    where: StatusWhereUniqueInput
  }

  /**
   * Status findUnique
   */
  export interface StatusFindUniqueArgs extends StatusFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Status findUniqueOrThrow
   */
  export type StatusFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * Filter, which Status to fetch.
     */
    where: StatusWhereUniqueInput
  }


  /**
   * Status base type for findFirst actions
   */
  export type StatusFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * Filter, which Status to fetch.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Statuses.
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Statuses.
     */
    distinct?: Enumerable<StatusScalarFieldEnum>
  }

  /**
   * Status findFirst
   */
  export interface StatusFindFirstArgs extends StatusFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Status findFirstOrThrow
   */
  export type StatusFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * Filter, which Status to fetch.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Statuses.
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Statuses.
     */
    distinct?: Enumerable<StatusScalarFieldEnum>
  }


  /**
   * Status findMany
   */
  export type StatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * Filter, which Statuses to fetch.
     */
    where?: StatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Statuses to fetch.
     */
    orderBy?: Enumerable<StatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Statuses.
     */
    cursor?: StatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Statuses.
     */
    skip?: number
    distinct?: Enumerable<StatusScalarFieldEnum>
  }


  /**
   * Status create
   */
  export type StatusCreateArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * The data needed to create a Status.
     */
    data: XOR<StatusCreateInput, StatusUncheckedCreateInput>
  }


  /**
   * Status createMany
   */
  export type StatusCreateManyArgs = {
    /**
     * The data used to create many Statuses.
     */
    data: Enumerable<StatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Status update
   */
  export type StatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * The data needed to update a Status.
     */
    data: XOR<StatusUpdateInput, StatusUncheckedUpdateInput>
    /**
     * Choose, which Status to update.
     */
    where: StatusWhereUniqueInput
  }


  /**
   * Status updateMany
   */
  export type StatusUpdateManyArgs = {
    /**
     * The data used to update Statuses.
     */
    data: XOR<StatusUpdateManyMutationInput, StatusUncheckedUpdateManyInput>
    /**
     * Filter which Statuses to update
     */
    where?: StatusWhereInput
  }


  /**
   * Status upsert
   */
  export type StatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * The filter to search for the Status to update in case it exists.
     */
    where: StatusWhereUniqueInput
    /**
     * In case the Status found by the `where` argument doesn't exist, create a new Status with this data.
     */
    create: XOR<StatusCreateInput, StatusUncheckedCreateInput>
    /**
     * In case the Status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusUpdateInput, StatusUncheckedUpdateInput>
  }


  /**
   * Status delete
   */
  export type StatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
    /**
     * Filter which Status to delete.
     */
    where: StatusWhereUniqueInput
  }


  /**
   * Status deleteMany
   */
  export type StatusDeleteManyArgs = {
    /**
     * Filter which Statuses to delete
     */
    where?: StatusWhereInput
  }


  /**
   * Status.CampaignParticipants
   */
  export type Status$CampaignParticipantsArgs = {
    /**
     * Select specific fields to fetch from the CampaignParticipants
     */
    select?: CampaignParticipantsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignParticipantsInclude | null
    where?: CampaignParticipantsWhereInput
    orderBy?: Enumerable<CampaignParticipantsOrderByWithRelationInput>
    cursor?: CampaignParticipantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CampaignParticipantsScalarFieldEnum>
  }


  /**
   * Status.Following
   */
  export type Status$FollowingArgs = {
    /**
     * Select specific fields to fetch from the Following
     */
    select?: FollowingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowingInclude | null
    where?: FollowingWhereInput
    orderBy?: Enumerable<FollowingOrderByWithRelationInput>
    cursor?: FollowingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FollowingScalarFieldEnum>
  }


  /**
   * Status without action
   */
  export type StatusArgs = {
    /**
     * Select specific fields to fetch from the Status
     */
    select?: StatusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StatusInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AddressScalarFieldEnum: {
    id: 'id',
    postal_code: 'postal_code',
    number: 'number',
    complement: 'complement'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const AttachedLinkScalarFieldEnum: {
    id: 'id',
    attached_link: 'attached_link',
    id_source: 'id_source',
    id_user: 'id_user',
    id_ngo: 'id_ngo'
  };

  export type AttachedLinkScalarFieldEnum = (typeof AttachedLinkScalarFieldEnum)[keyof typeof AttachedLinkScalarFieldEnum]


  export const CampaignAddressScalarFieldEnum: {
    id: 'id',
    id_campaign: 'id_campaign',
    id_address: 'id_address'
  };

  export type CampaignAddressScalarFieldEnum = (typeof CampaignAddressScalarFieldEnum)[keyof typeof CampaignAddressScalarFieldEnum]


  export const CampaignCausesScalarFieldEnum: {
    id: 'id',
    id_cause: 'id_cause',
    id_campaign: 'id_campaign'
  };

  export type CampaignCausesScalarFieldEnum = (typeof CampaignCausesScalarFieldEnum)[keyof typeof CampaignCausesScalarFieldEnum]


  export const CampaignParticipantsScalarFieldEnum: {
    id: 'id',
    id_campaign: 'id_campaign',
    id_user: 'id_user',
    id_status: 'id_status'
  };

  export type CampaignParticipantsScalarFieldEnum = (typeof CampaignParticipantsScalarFieldEnum)[keyof typeof CampaignParticipantsScalarFieldEnum]


  export const CampaignPhotosScalarFieldEnum: {
    id: 'id',
    photo_url: 'photo_url',
    id_campaign: 'id_campaign'
  };

  export type CampaignPhotosScalarFieldEnum = (typeof CampaignPhotosScalarFieldEnum)[keyof typeof CampaignPhotosScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    begin_date: 'begin_date',
    end_date: 'end_date',
    home_office: 'home_office',
    id_ngo: 'id_ngo',
    how_to_contribute: 'how_to_contribute',
    prerequisites: 'prerequisites',
    created_at: 'created_at',
    is_active: 'is_active'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CausesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description'
  };

  export type CausesScalarFieldEnum = (typeof CausesScalarFieldEnum)[keyof typeof CausesScalarFieldEnum]


  export const CommentLikesScalarFieldEnum: {
    id: 'id',
    id_comment: 'id_comment',
    id_user: 'id_user',
    id_ngo: 'id_ngo'
  };

  export type CommentLikesScalarFieldEnum = (typeof CommentLikesScalarFieldEnum)[keyof typeof CommentLikesScalarFieldEnum]


  export const CommentNgoScalarFieldEnum: {
    id: 'id',
    id_comment: 'id_comment',
    id_ngo: 'id_ngo'
  };

  export type CommentNgoScalarFieldEnum = (typeof CommentNgoScalarFieldEnum)[keyof typeof CommentNgoScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    created_at: 'created_at',
    id_post: 'id_post'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentUserScalarFieldEnum: {
    id: 'id',
    id_comment: 'id_comment',
    id_user: 'id_user'
  };

  export type CommentUserScalarFieldEnum = (typeof CommentUserScalarFieldEnum)[keyof typeof CommentUserScalarFieldEnum]


  export const FollowingScalarFieldEnum: {
    id: 'id',
    id_user: 'id_user',
    id_ngo: 'id_ngo',
    id_status: 'id_status'
  };

  export type FollowingScalarFieldEnum = (typeof FollowingScalarFieldEnum)[keyof typeof FollowingScalarFieldEnum]


  export const GenderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation'
  };

  export type GenderScalarFieldEnum = (typeof GenderScalarFieldEnum)[keyof typeof GenderScalarFieldEnum]


  export const NGOScalarFieldEnum: {
    id: 'id',
    name: 'name',
    cnpj: 'cnpj',
    foundation_date: 'foundation_date',
    description: 'description',
    email: 'email',
    password: 'password',
    id_type: 'id_type',
    photo_url: 'photo_url',
    banner_photo: 'banner_photo',
    created_at: 'created_at'
  };

  export type NGOScalarFieldEnum = (typeof NGOScalarFieldEnum)[keyof typeof NGOScalarFieldEnum]


  export const NgoAddressScalarFieldEnum: {
    id: 'id',
    id_ngo: 'id_ngo',
    id_address: 'id_address'
  };

  export type NgoAddressScalarFieldEnum = (typeof NgoAddressScalarFieldEnum)[keyof typeof NgoAddressScalarFieldEnum]


  export const NgoCausesScalarFieldEnum: {
    id: 'id',
    id_causes: 'id_causes',
    id_ngo: 'id_ngo'
  };

  export type NgoCausesScalarFieldEnum = (typeof NgoCausesScalarFieldEnum)[keyof typeof NgoCausesScalarFieldEnum]


  export const NgoPhoneScalarFieldEnum: {
    id: 'id',
    id_ngo: 'id_ngo',
    id_phone: 'id_phone'
  };

  export type NgoPhoneScalarFieldEnum = (typeof NgoPhoneScalarFieldEnum)[keyof typeof NgoPhoneScalarFieldEnum]


  export const PhoneScalarFieldEnum: {
    id: 'id',
    number: 'number'
  };

  export type PhoneScalarFieldEnum = (typeof PhoneScalarFieldEnum)[keyof typeof PhoneScalarFieldEnum]


  export const PostLikesScalarFieldEnum: {
    id: 'id',
    id_user: 'id_user',
    id_ngo: 'id_ngo',
    id_post: 'id_post'
  };

  export type PostLikesScalarFieldEnum = (typeof PostLikesScalarFieldEnum)[keyof typeof PostLikesScalarFieldEnum]


  export const PostNgoScalarFieldEnum: {
    id: 'id',
    id_post: 'id_post',
    id_ngo: 'id_ngo'
  };

  export type PostNgoScalarFieldEnum = (typeof PostNgoScalarFieldEnum)[keyof typeof PostNgoScalarFieldEnum]


  export const PostPhotoScalarFieldEnum: {
    id: 'id',
    id_post: 'id_post',
    photo_url: 'photo_url'
  };

  export type PostPhotoScalarFieldEnum = (typeof PostPhotoScalarFieldEnum)[keyof typeof PostPhotoScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    content: 'content',
    created_at: 'created_at'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostUserScalarFieldEnum: {
    id: 'id',
    id_post: 'id_post',
    id_user: 'id_user'
  };

  export type PostUserScalarFieldEnum = (typeof PostUserScalarFieldEnum)[keyof typeof PostUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SourceScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const StatusScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type StatusScalarFieldEnum = (typeof StatusScalarFieldEnum)[keyof typeof StatusScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TypeScalarFieldEnum = (typeof TypeScalarFieldEnum)[keyof typeof TypeScalarFieldEnum]


  export const UserAddressScalarFieldEnum: {
    id: 'id',
    id_address: 'id_address',
    id_user: 'id_user'
  };

  export type UserAddressScalarFieldEnum = (typeof UserAddressScalarFieldEnum)[keyof typeof UserAddressScalarFieldEnum]


  export const UserPhoneScalarFieldEnum: {
    id: 'id',
    id_phone: 'id_phone',
    id_user: 'id_user'
  };

  export type UserPhoneScalarFieldEnum = (typeof UserPhoneScalarFieldEnum)[keyof typeof UserPhoneScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    cpf: 'cpf',
    id_gender: 'id_gender',
    birthdate: 'birthdate',
    rg: 'rg',
    id_type: 'id_type',
    description: 'description',
    banner_photo: 'banner_photo',
    photo_url: 'photo_url',
    created_at: 'created_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    cpf?: StringFilter | string
    id_gender?: StringFilter | string
    birthdate?: DateTimeFilter | Date | string
    rg?: StringNullableFilter | string | null
    id_type?: StringFilter | string
    description?: StringNullableFilter | string | null
    banner_photo?: StringFilter | string
    photo_url?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    supported_campaigns?: CampaignParticipantsListRelationFilter
    comment_user?: CommentUserListRelationFilter
    following?: FollowingListRelationFilter
    post_user?: PostUserListRelationFilter
    gender?: XOR<GenderRelationFilter, GenderWhereInput>
    type?: XOR<TypeRelationFilter, TypeWhereInput>
    user_address?: XOR<UserAddressRelationFilter, UserAddressWhereInput> | null
    user_phone?: XOR<UserPhoneRelationFilter, UserPhoneWhereInput> | null
    comment_likes?: CommentLikesListRelationFilter
    post_likes?: PostLikesListRelationFilter
    attached_link?: AttachedLinkListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    id_gender?: SortOrder
    birthdate?: SortOrder
    rg?: SortOrder
    id_type?: SortOrder
    description?: SortOrder
    banner_photo?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    supported_campaigns?: CampaignParticipantsOrderByRelationAggregateInput
    comment_user?: CommentUserOrderByRelationAggregateInput
    following?: FollowingOrderByRelationAggregateInput
    post_user?: PostUserOrderByRelationAggregateInput
    gender?: GenderOrderByWithRelationInput
    type?: TypeOrderByWithRelationInput
    user_address?: UserAddressOrderByWithRelationInput
    user_phone?: UserPhoneOrderByWithRelationInput
    comment_likes?: CommentLikesOrderByRelationAggregateInput
    post_likes?: PostLikesOrderByRelationAggregateInput
    attached_link?: AttachedLinkOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    cpf?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    id_gender?: SortOrder
    birthdate?: SortOrder
    rg?: SortOrder
    id_type?: SortOrder
    description?: SortOrder
    banner_photo?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    cpf?: StringWithAggregatesFilter | string
    id_gender?: StringWithAggregatesFilter | string
    birthdate?: DateTimeWithAggregatesFilter | Date | string
    rg?: StringNullableWithAggregatesFilter | string | null
    id_type?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    banner_photo?: StringWithAggregatesFilter | string
    photo_url?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GenderWhereInput = {
    AND?: Enumerable<GenderWhereInput>
    OR?: Enumerable<GenderWhereInput>
    NOT?: Enumerable<GenderWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    abbreviation?: StringFilter | string
    user?: UserListRelationFilter
  }

  export type GenderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    user?: UserOrderByRelationAggregateInput
  }

  export type GenderWhereUniqueInput = {
    id?: string
    name?: string
    abbreviation?: string
  }

  export type GenderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    _count?: GenderCountOrderByAggregateInput
    _max?: GenderMaxOrderByAggregateInput
    _min?: GenderMinOrderByAggregateInput
  }

  export type GenderScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GenderScalarWhereWithAggregatesInput>
    OR?: Enumerable<GenderScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GenderScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    abbreviation?: StringWithAggregatesFilter | string
  }

  export type PhoneWhereInput = {
    AND?: Enumerable<PhoneWhereInput>
    OR?: Enumerable<PhoneWhereInput>
    NOT?: Enumerable<PhoneWhereInput>
    id?: StringFilter | string
    number?: StringNullableFilter | string | null
    ngo_phone?: NgoPhoneListRelationFilter
    user_phone?: UserPhoneListRelationFilter
  }

  export type PhoneOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    ngo_phone?: NgoPhoneOrderByRelationAggregateInput
    user_phone?: UserPhoneOrderByRelationAggregateInput
  }

  export type PhoneWhereUniqueInput = {
    id?: string
  }

  export type PhoneOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    _count?: PhoneCountOrderByAggregateInput
    _max?: PhoneMaxOrderByAggregateInput
    _min?: PhoneMinOrderByAggregateInput
  }

  export type PhoneScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhoneScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhoneScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhoneScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    number?: StringNullableWithAggregatesFilter | string | null
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: StringFilter | string
    postal_code?: StringFilter | string
    number?: StringFilter | string
    complement?: StringNullableFilter | string | null
    campaign_address?: CampaignAddressListRelationFilter
    ngo_address?: NgoAddressListRelationFilter
    user_address?: UserAddressListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    postal_code?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    campaign_address?: CampaignAddressOrderByRelationAggregateInput
    ngo_address?: NgoAddressOrderByRelationAggregateInput
    user_address?: UserAddressOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = {
    id?: string
  }

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    postal_code?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<AddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    postal_code?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserAddressWhereInput = {
    AND?: Enumerable<UserAddressWhereInput>
    OR?: Enumerable<UserAddressWhereInput>
    NOT?: Enumerable<UserAddressWhereInput>
    id?: StringFilter | string
    id_address?: StringFilter | string
    id_user?: StringFilter | string
    address?: XOR<AddressRelationFilter, AddressWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAddressOrderByWithRelationInput = {
    id?: SortOrder
    id_address?: SortOrder
    id_user?: SortOrder
    address?: AddressOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserAddressWhereUniqueInput = {
    id?: string
    id_user?: string
  }

  export type UserAddressOrderByWithAggregationInput = {
    id?: SortOrder
    id_address?: SortOrder
    id_user?: SortOrder
    _count?: UserAddressCountOrderByAggregateInput
    _max?: UserAddressMaxOrderByAggregateInput
    _min?: UserAddressMinOrderByAggregateInput
  }

  export type UserAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserAddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_address?: StringWithAggregatesFilter | string
    id_user?: StringWithAggregatesFilter | string
  }

  export type CampaignWhereInput = {
    AND?: Enumerable<CampaignWhereInput>
    OR?: Enumerable<CampaignWhereInput>
    NOT?: Enumerable<CampaignWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    begin_date?: DateTimeFilter | Date | string
    end_date?: DateTimeFilter | Date | string
    home_office?: BoolFilter | boolean
    id_ngo?: StringFilter | string
    how_to_contribute?: StringFilter | string
    prerequisites?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    is_active?: BoolFilter | boolean
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
    campaign_address?: XOR<CampaignAddressRelationFilter, CampaignAddressWhereInput> | null
    campaign_causes?: CampaignCausesListRelationFilter
    campaign_participants?: CampaignParticipantsListRelationFilter
    campaign_photos?: CampaignPhotosListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    begin_date?: SortOrder
    end_date?: SortOrder
    home_office?: SortOrder
    id_ngo?: SortOrder
    how_to_contribute?: SortOrder
    prerequisites?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
    ngo?: NGOOrderByWithRelationInput
    campaign_address?: CampaignAddressOrderByWithRelationInput
    campaign_causes?: CampaignCausesOrderByRelationAggregateInput
    campaign_participants?: CampaignParticipantsOrderByRelationAggregateInput
    campaign_photos?: CampaignPhotosOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = {
    id?: string
    title?: string
  }

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    begin_date?: SortOrder
    end_date?: SortOrder
    home_office?: SortOrder
    id_ngo?: SortOrder
    how_to_contribute?: SortOrder
    prerequisites?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    begin_date?: DateTimeWithAggregatesFilter | Date | string
    end_date?: DateTimeWithAggregatesFilter | Date | string
    home_office?: BoolWithAggregatesFilter | boolean
    id_ngo?: StringWithAggregatesFilter | string
    how_to_contribute?: StringWithAggregatesFilter | string
    prerequisites?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    is_active?: BoolWithAggregatesFilter | boolean
  }

  export type CampaignAddressWhereInput = {
    AND?: Enumerable<CampaignAddressWhereInput>
    OR?: Enumerable<CampaignAddressWhereInput>
    NOT?: Enumerable<CampaignAddressWhereInput>
    id?: StringFilter | string
    id_campaign?: StringFilter | string
    id_address?: StringFilter | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    address?: XOR<AddressRelationFilter, AddressWhereInput>
  }

  export type CampaignAddressOrderByWithRelationInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_address?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
  }

  export type CampaignAddressWhereUniqueInput = {
    id?: string
    id_campaign?: string
  }

  export type CampaignAddressOrderByWithAggregationInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_address?: SortOrder
    _count?: CampaignAddressCountOrderByAggregateInput
    _max?: CampaignAddressMaxOrderByAggregateInput
    _min?: CampaignAddressMinOrderByAggregateInput
  }

  export type CampaignAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignAddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_campaign?: StringWithAggregatesFilter | string
    id_address?: StringWithAggregatesFilter | string
  }

  export type CampaignCausesWhereInput = {
    AND?: Enumerable<CampaignCausesWhereInput>
    OR?: Enumerable<CampaignCausesWhereInput>
    NOT?: Enumerable<CampaignCausesWhereInput>
    id?: StringFilter | string
    id_cause?: StringFilter | string
    id_campaign?: StringFilter | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    causes?: XOR<CausesRelationFilter, CausesWhereInput>
  }

  export type CampaignCausesOrderByWithRelationInput = {
    id?: SortOrder
    id_cause?: SortOrder
    id_campaign?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    causes?: CausesOrderByWithRelationInput
  }

  export type CampaignCausesWhereUniqueInput = {
    id?: string
    id_cause_id_campaign?: CampaignCausesId_causeId_campaignCompoundUniqueInput
  }

  export type CampaignCausesOrderByWithAggregationInput = {
    id?: SortOrder
    id_cause?: SortOrder
    id_campaign?: SortOrder
    _count?: CampaignCausesCountOrderByAggregateInput
    _max?: CampaignCausesMaxOrderByAggregateInput
    _min?: CampaignCausesMinOrderByAggregateInput
  }

  export type CampaignCausesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignCausesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignCausesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignCausesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_cause?: StringWithAggregatesFilter | string
    id_campaign?: StringWithAggregatesFilter | string
  }

  export type CampaignParticipantsWhereInput = {
    AND?: Enumerable<CampaignParticipantsWhereInput>
    OR?: Enumerable<CampaignParticipantsWhereInput>
    NOT?: Enumerable<CampaignParticipantsWhereInput>
    id?: StringFilter | string
    id_campaign?: StringFilter | string
    id_user?: StringFilter | string
    id_status?: StringFilter | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    status?: XOR<StatusRelationFilter, StatusWhereInput>
  }

  export type CampaignParticipantsOrderByWithRelationInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_user?: SortOrder
    id_status?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    status?: StatusOrderByWithRelationInput
  }

  export type CampaignParticipantsWhereUniqueInput = {
    id?: string
    id_campaign_id_user?: CampaignParticipantsId_campaignId_userCompoundUniqueInput
  }

  export type CampaignParticipantsOrderByWithAggregationInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_user?: SortOrder
    id_status?: SortOrder
    _count?: CampaignParticipantsCountOrderByAggregateInput
    _max?: CampaignParticipantsMaxOrderByAggregateInput
    _min?: CampaignParticipantsMinOrderByAggregateInput
  }

  export type CampaignParticipantsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignParticipantsScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignParticipantsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignParticipantsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_campaign?: StringWithAggregatesFilter | string
    id_user?: StringWithAggregatesFilter | string
    id_status?: StringWithAggregatesFilter | string
  }

  export type CampaignPhotosWhereInput = {
    AND?: Enumerable<CampaignPhotosWhereInput>
    OR?: Enumerable<CampaignPhotosWhereInput>
    NOT?: Enumerable<CampaignPhotosWhereInput>
    id?: StringFilter | string
    photo_url?: StringFilter | string
    id_campaign?: StringFilter | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignPhotosOrderByWithRelationInput = {
    id?: SortOrder
    photo_url?: SortOrder
    id_campaign?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignPhotosWhereUniqueInput = {
    id?: string
  }

  export type CampaignPhotosOrderByWithAggregationInput = {
    id?: SortOrder
    photo_url?: SortOrder
    id_campaign?: SortOrder
    _count?: CampaignPhotosCountOrderByAggregateInput
    _max?: CampaignPhotosMaxOrderByAggregateInput
    _min?: CampaignPhotosMinOrderByAggregateInput
  }

  export type CampaignPhotosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CampaignPhotosScalarWhereWithAggregatesInput>
    OR?: Enumerable<CampaignPhotosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CampaignPhotosScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    photo_url?: StringWithAggregatesFilter | string
    id_campaign?: StringWithAggregatesFilter | string
  }

  export type CausesWhereInput = {
    AND?: Enumerable<CausesWhereInput>
    OR?: Enumerable<CausesWhereInput>
    NOT?: Enumerable<CausesWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    campaign_causes?: CampaignCausesListRelationFilter
    ngo_causes?: NgoCausesListRelationFilter
  }

  export type CausesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    campaign_causes?: CampaignCausesOrderByRelationAggregateInput
    ngo_causes?: NgoCausesOrderByRelationAggregateInput
  }

  export type CausesWhereUniqueInput = {
    id?: string
  }

  export type CausesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    _count?: CausesCountOrderByAggregateInput
    _max?: CausesMaxOrderByAggregateInput
    _min?: CausesMinOrderByAggregateInput
  }

  export type CausesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CausesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CausesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CausesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type FollowingWhereInput = {
    AND?: Enumerable<FollowingWhereInput>
    OR?: Enumerable<FollowingWhereInput>
    NOT?: Enumerable<FollowingWhereInput>
    id?: StringFilter | string
    id_user?: StringFilter | string
    id_ngo?: StringFilter | string
    id_status?: StringFilter | string
    status?: XOR<StatusRelationFilter, StatusWhereInput>
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowingOrderByWithRelationInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_status?: SortOrder
    status?: StatusOrderByWithRelationInput
    ngo?: NGOOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FollowingWhereUniqueInput = {
    id?: string
  }

  export type FollowingOrderByWithAggregationInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_status?: SortOrder
    _count?: FollowingCountOrderByAggregateInput
    _max?: FollowingMaxOrderByAggregateInput
    _min?: FollowingMinOrderByAggregateInput
  }

  export type FollowingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FollowingScalarWhereWithAggregatesInput>
    OR?: Enumerable<FollowingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FollowingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_user?: StringWithAggregatesFilter | string
    id_ngo?: StringWithAggregatesFilter | string
    id_status?: StringWithAggregatesFilter | string
  }

  export type NGOWhereInput = {
    AND?: Enumerable<NGOWhereInput>
    OR?: Enumerable<NGOWhereInput>
    NOT?: Enumerable<NGOWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    cnpj?: StringFilter | string
    foundation_date?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    id_type?: StringFilter | string
    photo_url?: StringFilter | string
    banner_photo?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    campaign?: CampaignListRelationFilter
    comment_ngo?: CommentNgoListRelationFilter
    following?: FollowingListRelationFilter
    type?: XOR<TypeRelationFilter, TypeWhereInput>
    ngo_address?: XOR<NgoAddressRelationFilter, NgoAddressWhereInput> | null
    ngo_causes?: NgoCausesListRelationFilter
    ngo_phone?: NgoPhoneListRelationFilter
    post_ngo?: PostNgoListRelationFilter
    comment_likes?: CommentLikesListRelationFilter
    post_likes?: PostLikesListRelationFilter
    attached_link?: AttachedLinkListRelationFilter
  }

  export type NGOOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    foundation_date?: SortOrder
    description?: SortOrder
    email?: SortOrder
    password?: SortOrder
    id_type?: SortOrder
    photo_url?: SortOrder
    banner_photo?: SortOrder
    created_at?: SortOrder
    campaign?: CampaignOrderByRelationAggregateInput
    comment_ngo?: CommentNgoOrderByRelationAggregateInput
    following?: FollowingOrderByRelationAggregateInput
    type?: TypeOrderByWithRelationInput
    ngo_address?: NgoAddressOrderByWithRelationInput
    ngo_causes?: NgoCausesOrderByRelationAggregateInput
    ngo_phone?: NgoPhoneOrderByRelationAggregateInput
    post_ngo?: PostNgoOrderByRelationAggregateInput
    comment_likes?: CommentLikesOrderByRelationAggregateInput
    post_likes?: PostLikesOrderByRelationAggregateInput
    attached_link?: AttachedLinkOrderByRelationAggregateInput
  }

  export type NGOWhereUniqueInput = {
    id?: string
    cnpj?: string
    email?: string
  }

  export type NGOOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    foundation_date?: SortOrder
    description?: SortOrder
    email?: SortOrder
    password?: SortOrder
    id_type?: SortOrder
    photo_url?: SortOrder
    banner_photo?: SortOrder
    created_at?: SortOrder
    _count?: NGOCountOrderByAggregateInput
    _max?: NGOMaxOrderByAggregateInput
    _min?: NGOMinOrderByAggregateInput
  }

  export type NGOScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NGOScalarWhereWithAggregatesInput>
    OR?: Enumerable<NGOScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NGOScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    cnpj?: StringWithAggregatesFilter | string
    foundation_date?: DateTimeNullableWithAggregatesFilter | Date | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    id_type?: StringWithAggregatesFilter | string
    photo_url?: StringWithAggregatesFilter | string
    banner_photo?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type NgoAddressWhereInput = {
    AND?: Enumerable<NgoAddressWhereInput>
    OR?: Enumerable<NgoAddressWhereInput>
    NOT?: Enumerable<NgoAddressWhereInput>
    id?: StringFilter | string
    id_ngo?: StringFilter | string
    id_address?: StringFilter | string
    address?: XOR<AddressRelationFilter, AddressWhereInput>
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
  }

  export type NgoAddressOrderByWithRelationInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_address?: SortOrder
    address?: AddressOrderByWithRelationInput
    ngo?: NGOOrderByWithRelationInput
  }

  export type NgoAddressWhereUniqueInput = {
    id?: string
    id_ngo?: string
  }

  export type NgoAddressOrderByWithAggregationInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_address?: SortOrder
    _count?: NgoAddressCountOrderByAggregateInput
    _max?: NgoAddressMaxOrderByAggregateInput
    _min?: NgoAddressMinOrderByAggregateInput
  }

  export type NgoAddressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NgoAddressScalarWhereWithAggregatesInput>
    OR?: Enumerable<NgoAddressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NgoAddressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_ngo?: StringWithAggregatesFilter | string
    id_address?: StringWithAggregatesFilter | string
  }

  export type NgoCausesWhereInput = {
    AND?: Enumerable<NgoCausesWhereInput>
    OR?: Enumerable<NgoCausesWhereInput>
    NOT?: Enumerable<NgoCausesWhereInput>
    id?: StringFilter | string
    id_causes?: StringFilter | string
    id_ngo?: StringFilter | string
    causes?: XOR<CausesRelationFilter, CausesWhereInput>
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
  }

  export type NgoCausesOrderByWithRelationInput = {
    id?: SortOrder
    id_causes?: SortOrder
    id_ngo?: SortOrder
    causes?: CausesOrderByWithRelationInput
    ngo?: NGOOrderByWithRelationInput
  }

  export type NgoCausesWhereUniqueInput = {
    id?: string
  }

  export type NgoCausesOrderByWithAggregationInput = {
    id?: SortOrder
    id_causes?: SortOrder
    id_ngo?: SortOrder
    _count?: NgoCausesCountOrderByAggregateInput
    _max?: NgoCausesMaxOrderByAggregateInput
    _min?: NgoCausesMinOrderByAggregateInput
  }

  export type NgoCausesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NgoCausesScalarWhereWithAggregatesInput>
    OR?: Enumerable<NgoCausesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NgoCausesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_causes?: StringWithAggregatesFilter | string
    id_ngo?: StringWithAggregatesFilter | string
  }

  export type NgoPhoneWhereInput = {
    AND?: Enumerable<NgoPhoneWhereInput>
    OR?: Enumerable<NgoPhoneWhereInput>
    NOT?: Enumerable<NgoPhoneWhereInput>
    id?: StringFilter | string
    id_ngo?: StringFilter | string
    id_phone?: StringFilter | string
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
    phone?: XOR<PhoneRelationFilter, PhoneWhereInput>
  }

  export type NgoPhoneOrderByWithRelationInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_phone?: SortOrder
    ngo?: NGOOrderByWithRelationInput
    phone?: PhoneOrderByWithRelationInput
  }

  export type NgoPhoneWhereUniqueInput = {
    id?: string
  }

  export type NgoPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_phone?: SortOrder
    _count?: NgoPhoneCountOrderByAggregateInput
    _max?: NgoPhoneMaxOrderByAggregateInput
    _min?: NgoPhoneMinOrderByAggregateInput
  }

  export type NgoPhoneScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NgoPhoneScalarWhereWithAggregatesInput>
    OR?: Enumerable<NgoPhoneScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NgoPhoneScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_ngo?: StringWithAggregatesFilter | string
    id_phone?: StringWithAggregatesFilter | string
  }

  export type UserPhoneWhereInput = {
    AND?: Enumerable<UserPhoneWhereInput>
    OR?: Enumerable<UserPhoneWhereInput>
    NOT?: Enumerable<UserPhoneWhereInput>
    id?: StringFilter | string
    id_phone?: StringFilter | string
    id_user?: StringFilter | string
    phone?: XOR<PhoneRelationFilter, PhoneWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserPhoneOrderByWithRelationInput = {
    id?: SortOrder
    id_phone?: SortOrder
    id_user?: SortOrder
    phone?: PhoneOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserPhoneWhereUniqueInput = {
    id?: string
    id_user?: string
  }

  export type UserPhoneOrderByWithAggregationInput = {
    id?: SortOrder
    id_phone?: SortOrder
    id_user?: SortOrder
    _count?: UserPhoneCountOrderByAggregateInput
    _max?: UserPhoneMaxOrderByAggregateInput
    _min?: UserPhoneMinOrderByAggregateInput
  }

  export type UserPhoneScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserPhoneScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserPhoneScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserPhoneScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_phone?: StringWithAggregatesFilter | string
    id_user?: StringWithAggregatesFilter | string
  }

  export type TypeWhereInput = {
    AND?: Enumerable<TypeWhereInput>
    OR?: Enumerable<TypeWhereInput>
    NOT?: Enumerable<TypeWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    ngo?: NGOListRelationFilter
    user?: UserListRelationFilter
  }

  export type TypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ngo?: NGOOrderByRelationAggregateInput
    user?: UserOrderByRelationAggregateInput
  }

  export type TypeWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type TypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TypeCountOrderByAggregateInput
    _max?: TypeMaxOrderByAggregateInput
    _min?: TypeMinOrderByAggregateInput
  }

  export type TypeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypeScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: StringFilter | string
    content?: StringNullableFilter | string | null
    created_at?: DateTimeFilter | Date | string
    comment?: CommentListRelationFilter
    post_ngo?: PostNgoListRelationFilter
    post_photo?: PostPhotoListRelationFilter
    post_user?: PostUserListRelationFilter
    post_likes?: PostLikesListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    comment?: CommentOrderByRelationAggregateInput
    post_ngo?: PostNgoOrderByRelationAggregateInput
    post_photo?: PostPhotoOrderByRelationAggregateInput
    post_user?: PostUserOrderByRelationAggregateInput
    post_likes?: PostLikesOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = {
    id?: string
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PostPhotoWhereInput = {
    AND?: Enumerable<PostPhotoWhereInput>
    OR?: Enumerable<PostPhotoWhereInput>
    NOT?: Enumerable<PostPhotoWhereInput>
    id?: StringFilter | string
    id_post?: StringFilter | string
    photo_url?: StringFilter | string
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostPhotoOrderByWithRelationInput = {
    id?: SortOrder
    id_post?: SortOrder
    photo_url?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type PostPhotoWhereUniqueInput = {
    id?: string
  }

  export type PostPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    id_post?: SortOrder
    photo_url?: SortOrder
    _count?: PostPhotoCountOrderByAggregateInput
    _max?: PostPhotoMaxOrderByAggregateInput
    _min?: PostPhotoMinOrderByAggregateInput
  }

  export type PostPhotoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostPhotoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostPhotoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostPhotoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_post?: StringWithAggregatesFilter | string
    photo_url?: StringWithAggregatesFilter | string
  }

  export type PostNgoWhereInput = {
    AND?: Enumerable<PostNgoWhereInput>
    OR?: Enumerable<PostNgoWhereInput>
    NOT?: Enumerable<PostNgoWhereInput>
    id?: StringFilter | string
    id_post?: StringFilter | string
    id_ngo?: StringFilter | string
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostNgoOrderByWithRelationInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_ngo?: SortOrder
    ngo?: NGOOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostNgoWhereUniqueInput = {
    id?: string
  }

  export type PostNgoOrderByWithAggregationInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_ngo?: SortOrder
    _count?: PostNgoCountOrderByAggregateInput
    _max?: PostNgoMaxOrderByAggregateInput
    _min?: PostNgoMinOrderByAggregateInput
  }

  export type PostNgoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostNgoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostNgoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostNgoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_post?: StringWithAggregatesFilter | string
    id_ngo?: StringWithAggregatesFilter | string
  }

  export type PostUserWhereInput = {
    AND?: Enumerable<PostUserWhereInput>
    OR?: Enumerable<PostUserWhereInput>
    NOT?: Enumerable<PostUserWhereInput>
    id?: StringFilter | string
    id_post?: StringFilter | string
    id_user?: StringFilter | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostUserOrderByWithRelationInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_user?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostUserWhereUniqueInput = {
    id?: string
  }

  export type PostUserOrderByWithAggregationInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_user?: SortOrder
    _count?: PostUserCountOrderByAggregateInput
    _max?: PostUserMaxOrderByAggregateInput
    _min?: PostUserMinOrderByAggregateInput
  }

  export type PostUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostUserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_post?: StringWithAggregatesFilter | string
    id_user?: StringWithAggregatesFilter | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    id_post?: StringFilter | string
    post?: XOR<PostRelationFilter, PostWhereInput>
    comment_ngo?: CommentNgoListRelationFilter
    comment_user?: CommentUserListRelationFilter
    comment_likes?: CommentLikesListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    id_post?: SortOrder
    post?: PostOrderByWithRelationInput
    comment_ngo?: CommentNgoOrderByRelationAggregateInput
    comment_user?: CommentUserOrderByRelationAggregateInput
    comment_likes?: CommentLikesOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = {
    id?: string
  }

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    id_post?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    created_at?: DateTimeWithAggregatesFilter | Date | string
    id_post?: StringWithAggregatesFilter | string
  }

  export type CommentUserWhereInput = {
    AND?: Enumerable<CommentUserWhereInput>
    OR?: Enumerable<CommentUserWhereInput>
    NOT?: Enumerable<CommentUserWhereInput>
    id?: StringFilter | string
    id_comment?: StringFilter | string
    id_user?: StringFilter | string
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentUserOrderByWithRelationInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentUserWhereUniqueInput = {
    id?: string
  }

  export type CommentUserOrderByWithAggregationInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    _count?: CommentUserCountOrderByAggregateInput
    _max?: CommentUserMaxOrderByAggregateInput
    _min?: CommentUserMinOrderByAggregateInput
  }

  export type CommentUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentUserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_comment?: StringWithAggregatesFilter | string
    id_user?: StringWithAggregatesFilter | string
  }

  export type CommentNgoWhereInput = {
    AND?: Enumerable<CommentNgoWhereInput>
    OR?: Enumerable<CommentNgoWhereInput>
    NOT?: Enumerable<CommentNgoWhereInput>
    id?: StringFilter | string
    id_comment?: StringFilter | string
    id_ngo?: StringFilter | string
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
    ngo?: XOR<NGORelationFilter, NGOWhereInput>
  }

  export type CommentNgoOrderByWithRelationInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_ngo?: SortOrder
    comment?: CommentOrderByWithRelationInput
    ngo?: NGOOrderByWithRelationInput
  }

  export type CommentNgoWhereUniqueInput = {
    id?: string
  }

  export type CommentNgoOrderByWithAggregationInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_ngo?: SortOrder
    _count?: CommentNgoCountOrderByAggregateInput
    _max?: CommentNgoMaxOrderByAggregateInput
    _min?: CommentNgoMinOrderByAggregateInput
  }

  export type CommentNgoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentNgoScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentNgoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentNgoScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_comment?: StringWithAggregatesFilter | string
    id_ngo?: StringWithAggregatesFilter | string
  }

  export type CommentLikesWhereInput = {
    AND?: Enumerable<CommentLikesWhereInput>
    OR?: Enumerable<CommentLikesWhereInput>
    NOT?: Enumerable<CommentLikesWhereInput>
    id?: StringFilter | string
    id_comment?: StringFilter | string
    id_user?: StringNullableFilter | string | null
    id_ngo?: StringNullableFilter | string | null
    ngo?: XOR<NGORelationFilter, NGOWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    comment?: XOR<CommentRelationFilter, CommentWhereInput>
  }

  export type CommentLikesOrderByWithRelationInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    ngo?: NGOOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type CommentLikesWhereUniqueInput = {
    id?: string
  }

  export type CommentLikesOrderByWithAggregationInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    _count?: CommentLikesCountOrderByAggregateInput
    _max?: CommentLikesMaxOrderByAggregateInput
    _min?: CommentLikesMinOrderByAggregateInput
  }

  export type CommentLikesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentLikesScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentLikesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentLikesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_comment?: StringWithAggregatesFilter | string
    id_user?: StringNullableWithAggregatesFilter | string | null
    id_ngo?: StringNullableWithAggregatesFilter | string | null
  }

  export type PostLikesWhereInput = {
    AND?: Enumerable<PostLikesWhereInput>
    OR?: Enumerable<PostLikesWhereInput>
    NOT?: Enumerable<PostLikesWhereInput>
    id?: StringFilter | string
    id_user?: StringNullableFilter | string | null
    id_ngo?: StringNullableFilter | string | null
    id_post?: StringFilter | string
    ngo?: XOR<NGORelationFilter, NGOWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    post?: XOR<PostRelationFilter, PostWhereInput>
  }

  export type PostLikesOrderByWithRelationInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_post?: SortOrder
    ngo?: NGOOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
  }

  export type PostLikesWhereUniqueInput = {
    id?: string
    id_ngo_id_post?: PostLikesId_ngoId_postCompoundUniqueInput
    id_user_id_post?: PostLikesId_userId_postCompoundUniqueInput
  }

  export type PostLikesOrderByWithAggregationInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_post?: SortOrder
    _count?: PostLikesCountOrderByAggregateInput
    _max?: PostLikesMaxOrderByAggregateInput
    _min?: PostLikesMinOrderByAggregateInput
  }

  export type PostLikesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostLikesScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostLikesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostLikesScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    id_user?: StringNullableWithAggregatesFilter | string | null
    id_ngo?: StringNullableWithAggregatesFilter | string | null
    id_post?: StringWithAggregatesFilter | string
  }

  export type AttachedLinkWhereInput = {
    AND?: Enumerable<AttachedLinkWhereInput>
    OR?: Enumerable<AttachedLinkWhereInput>
    NOT?: Enumerable<AttachedLinkWhereInput>
    id?: StringFilter | string
    attached_link?: StringFilter | string
    id_source?: StringFilter | string
    id_user?: StringNullableFilter | string | null
    id_ngo?: StringNullableFilter | string | null
    source?: XOR<SourceRelationFilter, SourceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    ngo?: XOR<NGORelationFilter, NGOWhereInput> | null
  }

  export type AttachedLinkOrderByWithRelationInput = {
    id?: SortOrder
    attached_link?: SortOrder
    id_source?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    source?: SourceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    ngo?: NGOOrderByWithRelationInput
  }

  export type AttachedLinkWhereUniqueInput = {
    id?: string
  }

  export type AttachedLinkOrderByWithAggregationInput = {
    id?: SortOrder
    attached_link?: SortOrder
    id_source?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    _count?: AttachedLinkCountOrderByAggregateInput
    _max?: AttachedLinkMaxOrderByAggregateInput
    _min?: AttachedLinkMinOrderByAggregateInput
  }

  export type AttachedLinkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttachedLinkScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttachedLinkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttachedLinkScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    attached_link?: StringWithAggregatesFilter | string
    id_source?: StringWithAggregatesFilter | string
    id_user?: StringNullableWithAggregatesFilter | string | null
    id_ngo?: StringNullableWithAggregatesFilter | string | null
  }

  export type SourceWhereInput = {
    AND?: Enumerable<SourceWhereInput>
    OR?: Enumerable<SourceWhereInput>
    NOT?: Enumerable<SourceWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    attached_link?: AttachedLinkListRelationFilter
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    attached_link?: AttachedLinkOrderByRelationAggregateInput
  }

  export type SourceWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: SourceCountOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<SourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SourceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type StatusWhereInput = {
    AND?: Enumerable<StatusWhereInput>
    OR?: Enumerable<StatusWhereInput>
    NOT?: Enumerable<StatusWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    CampaignParticipants?: CampaignParticipantsListRelationFilter
    Following?: FollowingListRelationFilter
  }

  export type StatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    CampaignParticipants?: CampaignParticipantsOrderByRelationAggregateInput
    Following?: FollowingOrderByRelationAggregateInput
  }

  export type StatusWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type StatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: StatusCountOrderByAggregateInput
    _max?: StatusMaxOrderByAggregateInput
    _min?: StatusMinOrderByAggregateInput
  }

  export type StatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<StatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StatusScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenderCreateInput = {
    id?: string
    name: string
    abbreviation: string
    user?: UserCreateNestedManyWithoutGenderInput
  }

  export type GenderUncheckedCreateInput = {
    id?: string
    name: string
    abbreviation: string
    user?: UserUncheckedCreateNestedManyWithoutGenderInput
  }

  export type GenderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutGenderNestedInput
  }

  export type GenderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutGenderNestedInput
  }

  export type GenderCreateManyInput = {
    id?: string
    name: string
    abbreviation: string
  }

  export type GenderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type GenderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneCreateInput = {
    id?: string
    number?: string | null
    ngo_phone?: NgoPhoneCreateNestedManyWithoutPhoneInput
    user_phone?: UserPhoneCreateNestedManyWithoutPhoneInput
  }

  export type PhoneUncheckedCreateInput = {
    id?: string
    number?: string | null
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutPhoneInput
    user_phone?: UserPhoneUncheckedCreateNestedManyWithoutPhoneInput
  }

  export type PhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_phone?: NgoPhoneUpdateManyWithoutPhoneNestedInput
    user_phone?: UserPhoneUpdateManyWithoutPhoneNestedInput
  }

  export type PhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutPhoneNestedInput
    user_phone?: UserPhoneUncheckedUpdateManyWithoutPhoneNestedInput
  }

  export type PhoneCreateManyInput = {
    id?: string
    number?: string | null
  }

  export type PhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressCreateInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    campaign_address?: CampaignAddressCreateNestedManyWithoutAddressInput
    ngo_address?: NgoAddressCreateNestedManyWithoutAddressInput
    user_address?: UserAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    campaign_address?: CampaignAddressUncheckedCreateNestedManyWithoutAddressInput
    ngo_address?: NgoAddressUncheckedCreateNestedManyWithoutAddressInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_address?: CampaignAddressUpdateManyWithoutAddressNestedInput
    ngo_address?: NgoAddressUpdateManyWithoutAddressNestedInput
    user_address?: UserAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_address?: CampaignAddressUncheckedUpdateManyWithoutAddressNestedInput
    ngo_address?: NgoAddressUncheckedUpdateManyWithoutAddressNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserAddressCreateInput = {
    id?: string
    address: AddressCreateNestedOneWithoutUser_addressInput
    user: UserCreateNestedOneWithoutUser_addressInput
  }

  export type UserAddressUncheckedCreateInput = {
    id?: string
    id_address: string
    id_user: string
  }

  export type UserAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneRequiredWithoutUser_addressNestedInput
    user?: UserUpdateOneRequiredWithoutUser_addressNestedInput
  }

  export type UserAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressCreateManyInput = {
    id?: string
    id_address: string
    id_user: string
  }

  export type UserAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    ngo: NGOCreateNestedOneWithoutCampaignInput
    campaign_address?: CampaignAddressCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_address?: CampaignAddressUncheckedCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsUncheckedCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    ngo?: NGOUpdateOneRequiredWithoutCampaignNestedInput
    campaign_address?: CampaignAddressUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    id_ngo?: StringFieldUpdateOperationsInput | string
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_address?: CampaignAddressUncheckedUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    id_ngo?: StringFieldUpdateOperationsInput | string
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CampaignAddressCreateInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_addressInput
    address: AddressCreateNestedOneWithoutCampaign_addressInput
  }

  export type CampaignAddressUncheckedCreateInput = {
    id?: string
    id_campaign: string
    id_address: string
  }

  export type CampaignAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_addressNestedInput
    address?: AddressUpdateOneRequiredWithoutCampaign_addressNestedInput
  }

  export type CampaignAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignAddressCreateManyInput = {
    id?: string
    id_campaign: string
    id_address: string
  }

  export type CampaignAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesCreateInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_causesInput
    causes: CausesCreateNestedOneWithoutCampaign_causesInput
  }

  export type CampaignCausesUncheckedCreateInput = {
    id?: string
    id_cause: string
    id_campaign: string
  }

  export type CampaignCausesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_causesNestedInput
    causes?: CausesUpdateOneRequiredWithoutCampaign_causesNestedInput
  }

  export type CampaignCausesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_cause?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesCreateManyInput = {
    id?: string
    id_cause: string
    id_campaign: string
  }

  export type CampaignCausesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_cause?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsCreateInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_participantsInput
    user: UserCreateNestedOneWithoutSupported_campaignsInput
    status: StatusCreateNestedOneWithoutCampaignParticipantsInput
  }

  export type CampaignParticipantsUncheckedCreateInput = {
    id?: string
    id_campaign: string
    id_user: string
    id_status: string
  }

  export type CampaignParticipantsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_participantsNestedInput
    user?: UserUpdateOneRequiredWithoutSupported_campaignsNestedInput
    status?: StatusUpdateOneRequiredWithoutCampaignParticipantsNestedInput
  }

  export type CampaignParticipantsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsCreateManyInput = {
    id?: string
    id_campaign: string
    id_user: string
    id_status: string
  }

  export type CampaignParticipantsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignPhotosCreateInput = {
    id?: string
    photo_url: string
    campaign: CampaignCreateNestedOneWithoutCampaign_photosInput
  }

  export type CampaignPhotosUncheckedCreateInput = {
    id?: string
    photo_url: string
    id_campaign: string
  }

  export type CampaignPhotosUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_photosNestedInput
  }

  export type CampaignPhotosUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignPhotosCreateManyInput = {
    id?: string
    photo_url: string
    id_campaign: string
  }

  export type CampaignPhotosUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignPhotosUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type CausesCreateInput = {
    id?: string
    title: string
    description?: string | null
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCausesInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutCausesInput
  }

  export type CausesUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCausesInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutCausesInput
  }

  export type CausesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_causes?: CampaignCausesUpdateManyWithoutCausesNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutCausesNestedInput
  }

  export type CausesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCausesNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutCausesNestedInput
  }

  export type CausesCreateManyInput = {
    id?: string
    title: string
    description?: string | null
  }

  export type CausesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CausesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FollowingCreateInput = {
    id?: string
    status: StatusCreateNestedOneWithoutFollowingInput
    ngo: NGOCreateNestedOneWithoutFollowingInput
    user: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowingUncheckedCreateInput = {
    id?: string
    id_user: string
    id_ngo: string
    id_status: string
  }

  export type FollowingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StatusUpdateOneRequiredWithoutFollowingNestedInput
    ngo?: NGOUpdateOneRequiredWithoutFollowingNestedInput
    user?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type FollowingCreateManyInput = {
    id?: string
    id_user: string
    id_ngo: string
    id_status: string
  }

  export type FollowingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type FollowingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type NGOCreateInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type NGOCreateManyInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
  }

  export type NGOUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NGOUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NgoAddressCreateInput = {
    id?: string
    address: AddressCreateNestedOneWithoutNgo_addressInput
    ngo: NGOCreateNestedOneWithoutNgo_addressInput
  }

  export type NgoAddressUncheckedCreateInput = {
    id?: string
    id_ngo: string
    id_address: string
  }

  export type NgoAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneRequiredWithoutNgo_addressNestedInput
    ngo?: NGOUpdateOneRequiredWithoutNgo_addressNestedInput
  }

  export type NgoAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type NgoAddressCreateManyInput = {
    id?: string
    id_ngo: string
    id_address: string
  }

  export type NgoAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type NgoAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesCreateInput = {
    id?: string
    causes: CausesCreateNestedOneWithoutNgo_causesInput
    ngo: NGOCreateNestedOneWithoutNgo_causesInput
  }

  export type NgoCausesUncheckedCreateInput = {
    id?: string
    id_causes: string
    id_ngo: string
  }

  export type NgoCausesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    causes?: CausesUpdateOneRequiredWithoutNgo_causesNestedInput
    ngo?: NGOUpdateOneRequiredWithoutNgo_causesNestedInput
  }

  export type NgoCausesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_causes?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesCreateManyInput = {
    id?: string
    id_causes: string
    id_ngo: string
  }

  export type NgoCausesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_causes?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type NgoPhoneCreateInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutNgo_phoneInput
    phone: PhoneCreateNestedOneWithoutNgo_phoneInput
  }

  export type NgoPhoneUncheckedCreateInput = {
    id?: string
    id_ngo: string
    id_phone: string
  }

  export type NgoPhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutNgo_phoneNestedInput
    phone?: PhoneUpdateOneRequiredWithoutNgo_phoneNestedInput
  }

  export type NgoPhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_phone?: StringFieldUpdateOperationsInput | string
  }

  export type NgoPhoneCreateManyInput = {
    id?: string
    id_ngo: string
    id_phone: string
  }

  export type NgoPhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type NgoPhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_phone?: StringFieldUpdateOperationsInput | string
  }

  export type UserPhoneCreateInput = {
    id?: string
    phone: PhoneCreateNestedOneWithoutUser_phoneInput
    user: UserCreateNestedOneWithoutUser_phoneInput
  }

  export type UserPhoneUncheckedCreateInput = {
    id?: string
    id_phone: string
    id_user: string
  }

  export type UserPhoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: PhoneUpdateOneRequiredWithoutUser_phoneNestedInput
    user?: UserUpdateOneRequiredWithoutUser_phoneNestedInput
  }

  export type UserPhoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_phone?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserPhoneCreateManyInput = {
    id?: string
    id_phone: string
    id_user: string
  }

  export type UserPhoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserPhoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_phone?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type TypeCreateInput = {
    id?: string
    name: string
    ngo?: NGOCreateNestedManyWithoutTypeInput
    user?: UserCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateInput = {
    id?: string
    name: string
    ngo?: NGOUncheckedCreateNestedManyWithoutTypeInput
    user?: UserUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateManyWithoutTypeNestedInput
    user?: UserUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUncheckedUpdateManyWithoutTypeNestedInput
    user?: UserUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type TypeCreateManyInput = {
    id?: string
    name: string
  }

  export type TypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoCreateNestedManyWithoutPostInput
    post_user?: PostUserCreateNestedManyWithoutPostInput
    post_likes?: PostLikesCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoUncheckedCreateNestedManyWithoutPostInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutPostInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUpdateManyWithoutPostNestedInput
    post_user?: PostUserUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUncheckedUpdateManyWithoutPostNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostPhotoCreateInput = {
    id?: string
    photo_url: string
    post: PostCreateNestedOneWithoutPost_photoInput
  }

  export type PostPhotoUncheckedCreateInput = {
    id?: string
    id_post: string
    photo_url: string
  }

  export type PostPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutPost_photoNestedInput
  }

  export type PostPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type PostPhotoCreateManyInput = {
    id?: string
    id_post: string
    photo_url: string
  }

  export type PostPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type PostPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type PostNgoCreateInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutPost_ngoInput
    post: PostCreateNestedOneWithoutPost_ngoInput
  }

  export type PostNgoUncheckedCreateInput = {
    id?: string
    id_post: string
    id_ngo: string
  }

  export type PostNgoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutPost_ngoNestedInput
    post?: PostUpdateOneRequiredWithoutPost_ngoNestedInput
  }

  export type PostNgoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type PostNgoCreateManyInput = {
    id?: string
    id_post: string
    id_ngo: string
  }

  export type PostNgoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostNgoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type PostUserCreateInput = {
    id?: string
    post: PostCreateNestedOneWithoutPost_userInput
    user: UserCreateNestedOneWithoutPost_userInput
  }

  export type PostUserUncheckedCreateInput = {
    id?: string
    id_post: string
    id_user: string
  }

  export type PostUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutPost_userNestedInput
    user?: UserUpdateOneRequiredWithoutPost_userNestedInput
  }

  export type PostUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type PostUserCreateManyInput = {
    id?: string
    id_post: string
    id_user: string
  }

  export type PostUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutCommentInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutCommentInput
    comment_user?: CommentUserCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    created_at?: Date | string
    id_post: string
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutCommentInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutCommentNestedInput
    comment_user?: CommentUserUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_post?: StringFieldUpdateOperationsInput | string
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutCommentNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    created_at?: Date | string
    id_post: string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUserCreateInput = {
    id?: string
    comment: CommentCreateNestedOneWithoutComment_userInput
    user: UserCreateNestedOneWithoutComment_userInput
  }

  export type CommentUserUncheckedCreateInput = {
    id?: string
    id_comment: string
    id_user: string
  }

  export type CommentUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: CommentUpdateOneRequiredWithoutComment_userNestedInput
    user?: UserUpdateOneRequiredWithoutComment_userNestedInput
  }

  export type CommentUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUserCreateManyInput = {
    id?: string
    id_comment: string
    id_user: string
  }

  export type CommentUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentNgoCreateInput = {
    id?: string
    comment: CommentCreateNestedOneWithoutComment_ngoInput
    ngo: NGOCreateNestedOneWithoutComment_ngoInput
  }

  export type CommentNgoUncheckedCreateInput = {
    id?: string
    id_comment: string
    id_ngo: string
  }

  export type CommentNgoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: CommentUpdateOneRequiredWithoutComment_ngoNestedInput
    ngo?: NGOUpdateOneRequiredWithoutComment_ngoNestedInput
  }

  export type CommentNgoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type CommentNgoCreateManyInput = {
    id?: string
    id_comment: string
    id_ngo: string
  }

  export type CommentNgoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentNgoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikesCreateInput = {
    id?: string
    ngo?: NGOCreateNestedOneWithoutComment_likesInput
    user?: UserCreateNestedOneWithoutComment_likesInput
    comment: CommentCreateNestedOneWithoutComment_likesInput
  }

  export type CommentLikesUncheckedCreateInput = {
    id?: string
    id_comment: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type CommentLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneWithoutComment_likesNestedInput
    user?: UserUpdateOneWithoutComment_likesNestedInput
    comment?: CommentUpdateOneRequiredWithoutComment_likesNestedInput
  }

  export type CommentLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentLikesCreateManyInput = {
    id?: string
    id_comment: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type CommentLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostLikesCreateInput = {
    id?: string
    ngo?: NGOCreateNestedOneWithoutPost_likesInput
    user?: UserCreateNestedOneWithoutPost_likesInput
    post: PostCreateNestedOneWithoutPost_likesInput
  }

  export type PostLikesUncheckedCreateInput = {
    id?: string
    id_user?: string | null
    id_ngo?: string | null
    id_post: string
  }

  export type PostLikesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneWithoutPost_likesNestedInput
    user?: UserUpdateOneWithoutPost_likesNestedInput
    post?: PostUpdateOneRequiredWithoutPost_likesNestedInput
  }

  export type PostLikesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikesCreateManyInput = {
    id?: string
    id_user?: string | null
    id_ngo?: string | null
    id_post: string
  }

  export type PostLikesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type AttachedLinkCreateInput = {
    id?: string
    attached_link: string
    source: SourceCreateNestedOneWithoutAttached_linkInput
    user?: UserCreateNestedOneWithoutAttached_linkInput
    ngo?: NGOCreateNestedOneWithoutAttached_linkInput
  }

  export type AttachedLinkUncheckedCreateInput = {
    id?: string
    attached_link: string
    id_source: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type AttachedLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    source?: SourceUpdateOneRequiredWithoutAttached_linkNestedInput
    user?: UserUpdateOneWithoutAttached_linkNestedInput
    ngo?: NGOUpdateOneWithoutAttached_linkNestedInput
  }

  export type AttachedLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    id_source?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachedLinkCreateManyInput = {
    id?: string
    attached_link: string
    id_source: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type AttachedLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
  }

  export type AttachedLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    id_source?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SourceCreateInput = {
    id?: string
    name: string
    attached_link?: AttachedLinkCreateNestedManyWithoutSourceInput
  }

  export type SourceUncheckedCreateInput = {
    id?: string
    name: string
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutSourceInput
  }

  export type SourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attached_link?: AttachedLinkUpdateManyWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type SourceCreateManyInput = {
    id?: string
    name: string
  }

  export type SourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusCreateInput = {
    id?: string
    name: string
    CampaignParticipants?: CampaignParticipantsCreateNestedManyWithoutStatusInput
    Following?: FollowingCreateNestedManyWithoutStatusInput
  }

  export type StatusUncheckedCreateInput = {
    id?: string
    name: string
    CampaignParticipants?: CampaignParticipantsUncheckedCreateNestedManyWithoutStatusInput
    Following?: FollowingUncheckedCreateNestedManyWithoutStatusInput
  }

  export type StatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    CampaignParticipants?: CampaignParticipantsUpdateManyWithoutStatusNestedInput
    Following?: FollowingUpdateManyWithoutStatusNestedInput
  }

  export type StatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    CampaignParticipants?: CampaignParticipantsUncheckedUpdateManyWithoutStatusNestedInput
    Following?: FollowingUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type StatusCreateManyInput = {
    id?: string
    name: string
  }

  export type StatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type CampaignParticipantsListRelationFilter = {
    every?: CampaignParticipantsWhereInput
    some?: CampaignParticipantsWhereInput
    none?: CampaignParticipantsWhereInput
  }

  export type CommentUserListRelationFilter = {
    every?: CommentUserWhereInput
    some?: CommentUserWhereInput
    none?: CommentUserWhereInput
  }

  export type FollowingListRelationFilter = {
    every?: FollowingWhereInput
    some?: FollowingWhereInput
    none?: FollowingWhereInput
  }

  export type PostUserListRelationFilter = {
    every?: PostUserWhereInput
    some?: PostUserWhereInput
    none?: PostUserWhereInput
  }

  export type GenderRelationFilter = {
    is?: GenderWhereInput
    isNot?: GenderWhereInput
  }

  export type TypeRelationFilter = {
    is?: TypeWhereInput
    isNot?: TypeWhereInput
  }

  export type UserAddressRelationFilter = {
    is?: UserAddressWhereInput | null
    isNot?: UserAddressWhereInput | null
  }

  export type UserPhoneRelationFilter = {
    is?: UserPhoneWhereInput | null
    isNot?: UserPhoneWhereInput | null
  }

  export type CommentLikesListRelationFilter = {
    every?: CommentLikesWhereInput
    some?: CommentLikesWhereInput
    none?: CommentLikesWhereInput
  }

  export type PostLikesListRelationFilter = {
    every?: PostLikesWhereInput
    some?: PostLikesWhereInput
    none?: PostLikesWhereInput
  }

  export type AttachedLinkListRelationFilter = {
    every?: AttachedLinkWhereInput
    some?: AttachedLinkWhereInput
    none?: AttachedLinkWhereInput
  }

  export type CampaignParticipantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttachedLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    id_gender?: SortOrder
    birthdate?: SortOrder
    rg?: SortOrder
    id_type?: SortOrder
    description?: SortOrder
    banner_photo?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    id_gender?: SortOrder
    birthdate?: SortOrder
    rg?: SortOrder
    id_type?: SortOrder
    description?: SortOrder
    banner_photo?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    cpf?: SortOrder
    id_gender?: SortOrder
    birthdate?: SortOrder
    rg?: SortOrder
    id_type?: SortOrder
    description?: SortOrder
    banner_photo?: SortOrder
    photo_url?: SortOrder
    created_at?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
  }

  export type GenderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
  }

  export type GenderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
  }

  export type NgoPhoneListRelationFilter = {
    every?: NgoPhoneWhereInput
    some?: NgoPhoneWhereInput
    none?: NgoPhoneWhereInput
  }

  export type UserPhoneListRelationFilter = {
    every?: UserPhoneWhereInput
    some?: UserPhoneWhereInput
    none?: UserPhoneWhereInput
  }

  export type NgoPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPhoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhoneCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type PhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type PhoneMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
  }

  export type CampaignAddressListRelationFilter = {
    every?: CampaignAddressWhereInput
    some?: CampaignAddressWhereInput
    none?: CampaignAddressWhereInput
  }

  export type NgoAddressListRelationFilter = {
    every?: NgoAddressWhereInput
    some?: NgoAddressWhereInput
    none?: NgoAddressWhereInput
  }

  export type UserAddressListRelationFilter = {
    every?: UserAddressWhereInput
    some?: UserAddressWhereInput
    none?: UserAddressWhereInput
  }

  export type CampaignAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NgoAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    postal_code?: SortOrder
    number?: SortOrder
    complement?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    postal_code?: SortOrder
    number?: SortOrder
    complement?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    postal_code?: SortOrder
    number?: SortOrder
    complement?: SortOrder
  }

  export type AddressRelationFilter = {
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserAddressCountOrderByAggregateInput = {
    id?: SortOrder
    id_address?: SortOrder
    id_user?: SortOrder
  }

  export type UserAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    id_address?: SortOrder
    id_user?: SortOrder
  }

  export type UserAddressMinOrderByAggregateInput = {
    id?: SortOrder
    id_address?: SortOrder
    id_user?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NGORelationFilter = {
    is?: NGOWhereInput
    isNot?: NGOWhereInput
  }

  export type CampaignAddressRelationFilter = {
    is?: CampaignAddressWhereInput | null
    isNot?: CampaignAddressWhereInput | null
  }

  export type CampaignCausesListRelationFilter = {
    every?: CampaignCausesWhereInput
    some?: CampaignCausesWhereInput
    none?: CampaignCausesWhereInput
  }

  export type CampaignPhotosListRelationFilter = {
    every?: CampaignPhotosWhereInput
    some?: CampaignPhotosWhereInput
    none?: CampaignPhotosWhereInput
  }

  export type CampaignCausesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignPhotosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    begin_date?: SortOrder
    end_date?: SortOrder
    home_office?: SortOrder
    id_ngo?: SortOrder
    how_to_contribute?: SortOrder
    prerequisites?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    begin_date?: SortOrder
    end_date?: SortOrder
    home_office?: SortOrder
    id_ngo?: SortOrder
    how_to_contribute?: SortOrder
    prerequisites?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    begin_date?: SortOrder
    end_date?: SortOrder
    home_office?: SortOrder
    id_ngo?: SortOrder
    how_to_contribute?: SortOrder
    prerequisites?: SortOrder
    created_at?: SortOrder
    is_active?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignAddressCountOrderByAggregateInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_address?: SortOrder
  }

  export type CampaignAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_address?: SortOrder
  }

  export type CampaignAddressMinOrderByAggregateInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_address?: SortOrder
  }

  export type CausesRelationFilter = {
    is?: CausesWhereInput
    isNot?: CausesWhereInput
  }

  export type CampaignCausesId_causeId_campaignCompoundUniqueInput = {
    id_cause: string
    id_campaign: string
  }

  export type CampaignCausesCountOrderByAggregateInput = {
    id?: SortOrder
    id_cause?: SortOrder
    id_campaign?: SortOrder
  }

  export type CampaignCausesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_cause?: SortOrder
    id_campaign?: SortOrder
  }

  export type CampaignCausesMinOrderByAggregateInput = {
    id?: SortOrder
    id_cause?: SortOrder
    id_campaign?: SortOrder
  }

  export type StatusRelationFilter = {
    is?: StatusWhereInput
    isNot?: StatusWhereInput
  }

  export type CampaignParticipantsId_campaignId_userCompoundUniqueInput = {
    id_campaign: string
    id_user: string
  }

  export type CampaignParticipantsCountOrderByAggregateInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_user?: SortOrder
    id_status?: SortOrder
  }

  export type CampaignParticipantsMaxOrderByAggregateInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_user?: SortOrder
    id_status?: SortOrder
  }

  export type CampaignParticipantsMinOrderByAggregateInput = {
    id?: SortOrder
    id_campaign?: SortOrder
    id_user?: SortOrder
    id_status?: SortOrder
  }

  export type CampaignPhotosCountOrderByAggregateInput = {
    id?: SortOrder
    photo_url?: SortOrder
    id_campaign?: SortOrder
  }

  export type CampaignPhotosMaxOrderByAggregateInput = {
    id?: SortOrder
    photo_url?: SortOrder
    id_campaign?: SortOrder
  }

  export type CampaignPhotosMinOrderByAggregateInput = {
    id?: SortOrder
    photo_url?: SortOrder
    id_campaign?: SortOrder
  }

  export type NgoCausesListRelationFilter = {
    every?: NgoCausesWhereInput
    some?: NgoCausesWhereInput
    none?: NgoCausesWhereInput
  }

  export type NgoCausesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CausesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type CausesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type CausesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type FollowingCountOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_status?: SortOrder
  }

  export type FollowingMaxOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_status?: SortOrder
  }

  export type FollowingMinOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_status?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CommentNgoListRelationFilter = {
    every?: CommentNgoWhereInput
    some?: CommentNgoWhereInput
    none?: CommentNgoWhereInput
  }

  export type NgoAddressRelationFilter = {
    is?: NgoAddressWhereInput | null
    isNot?: NgoAddressWhereInput | null
  }

  export type PostNgoListRelationFilter = {
    every?: PostNgoWhereInput
    some?: PostNgoWhereInput
    none?: PostNgoWhereInput
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentNgoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostNgoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NGOCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    foundation_date?: SortOrder
    description?: SortOrder
    email?: SortOrder
    password?: SortOrder
    id_type?: SortOrder
    photo_url?: SortOrder
    banner_photo?: SortOrder
    created_at?: SortOrder
  }

  export type NGOMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    foundation_date?: SortOrder
    description?: SortOrder
    email?: SortOrder
    password?: SortOrder
    id_type?: SortOrder
    photo_url?: SortOrder
    banner_photo?: SortOrder
    created_at?: SortOrder
  }

  export type NGOMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    cnpj?: SortOrder
    foundation_date?: SortOrder
    description?: SortOrder
    email?: SortOrder
    password?: SortOrder
    id_type?: SortOrder
    photo_url?: SortOrder
    banner_photo?: SortOrder
    created_at?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NgoAddressCountOrderByAggregateInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_address?: SortOrder
  }

  export type NgoAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_address?: SortOrder
  }

  export type NgoAddressMinOrderByAggregateInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_address?: SortOrder
  }

  export type NgoCausesCountOrderByAggregateInput = {
    id?: SortOrder
    id_causes?: SortOrder
    id_ngo?: SortOrder
  }

  export type NgoCausesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_causes?: SortOrder
    id_ngo?: SortOrder
  }

  export type NgoCausesMinOrderByAggregateInput = {
    id?: SortOrder
    id_causes?: SortOrder
    id_ngo?: SortOrder
  }

  export type PhoneRelationFilter = {
    is?: PhoneWhereInput
    isNot?: PhoneWhereInput
  }

  export type NgoPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_phone?: SortOrder
  }

  export type NgoPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_phone?: SortOrder
  }

  export type NgoPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    id_ngo?: SortOrder
    id_phone?: SortOrder
  }

  export type UserPhoneCountOrderByAggregateInput = {
    id?: SortOrder
    id_phone?: SortOrder
    id_user?: SortOrder
  }

  export type UserPhoneMaxOrderByAggregateInput = {
    id?: SortOrder
    id_phone?: SortOrder
    id_user?: SortOrder
  }

  export type UserPhoneMinOrderByAggregateInput = {
    id?: SortOrder
    id_phone?: SortOrder
    id_user?: SortOrder
  }

  export type NGOListRelationFilter = {
    every?: NGOWhereInput
    some?: NGOWhereInput
    none?: NGOWhereInput
  }

  export type NGOOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PostPhotoListRelationFilter = {
    every?: PostPhotoWhereInput
    some?: PostPhotoWhereInput
    none?: PostPhotoWhereInput
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PostPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    photo_url?: SortOrder
  }

  export type PostPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    photo_url?: SortOrder
  }

  export type PostPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    photo_url?: SortOrder
  }

  export type PostNgoCountOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_ngo?: SortOrder
  }

  export type PostNgoMaxOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_ngo?: SortOrder
  }

  export type PostNgoMinOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_ngo?: SortOrder
  }

  export type PostUserCountOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_user?: SortOrder
  }

  export type PostUserMaxOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_user?: SortOrder
  }

  export type PostUserMinOrderByAggregateInput = {
    id?: SortOrder
    id_post?: SortOrder
    id_user?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    id_post?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    id_post?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    id_post?: SortOrder
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentUserCountOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
  }

  export type CommentUserMaxOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
  }

  export type CommentUserMinOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
  }

  export type CommentNgoCountOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_ngo?: SortOrder
  }

  export type CommentNgoMaxOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_ngo?: SortOrder
  }

  export type CommentNgoMinOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_ngo?: SortOrder
  }

  export type CommentLikesCountOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
  }

  export type CommentLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
  }

  export type CommentLikesMinOrderByAggregateInput = {
    id?: SortOrder
    id_comment?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
  }

  export type PostLikesId_ngoId_postCompoundUniqueInput = {
    id_ngo: string
    id_post: string
  }

  export type PostLikesId_userId_postCompoundUniqueInput = {
    id_user: string
    id_post: string
  }

  export type PostLikesCountOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_post?: SortOrder
  }

  export type PostLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_post?: SortOrder
  }

  export type PostLikesMinOrderByAggregateInput = {
    id?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
    id_post?: SortOrder
  }

  export type SourceRelationFilter = {
    is?: SourceWhereInput
    isNot?: SourceWhereInput
  }

  export type AttachedLinkCountOrderByAggregateInput = {
    id?: SortOrder
    attached_link?: SortOrder
    id_source?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
  }

  export type AttachedLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    attached_link?: SortOrder
    id_source?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
  }

  export type AttachedLinkMinOrderByAggregateInput = {
    id?: SortOrder
    attached_link?: SortOrder
    id_source?: SortOrder
    id_user?: SortOrder
    id_ngo?: SortOrder
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CampaignParticipantsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutUserInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutUserInput>
    createMany?: CampaignParticipantsCreateManyUserInputEnvelope
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
  }

  export type CommentUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutUserInput>, Enumerable<CommentUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutUserInput>
    createMany?: CommentUserCreateManyUserInputEnvelope
    connect?: Enumerable<CommentUserWhereUniqueInput>
  }

  export type FollowingCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutUserInput>, Enumerable<FollowingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutUserInput>
    createMany?: FollowingCreateManyUserInputEnvelope
    connect?: Enumerable<FollowingWhereUniqueInput>
  }

  export type PostUserCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutUserInput>, Enumerable<PostUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutUserInput>
    createMany?: PostUserCreateManyUserInputEnvelope
    connect?: Enumerable<PostUserWhereUniqueInput>
  }

  export type GenderCreateNestedOneWithoutUserInput = {
    create?: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
    connectOrCreate?: GenderCreateOrConnectWithoutUserInput
    connect?: GenderWhereUniqueInput
  }

  export type TypeCreateNestedOneWithoutUserInput = {
    create?: XOR<TypeCreateWithoutUserInput, TypeUncheckedCreateWithoutUserInput>
    connectOrCreate?: TypeCreateOrConnectWithoutUserInput
    connect?: TypeWhereUniqueInput
  }

  export type UserAddressCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    connect?: UserAddressWhereUniqueInput
  }

  export type UserPhoneCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    connect?: UserPhoneWhereUniqueInput
  }

  export type CommentLikesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutUserInput>, Enumerable<CommentLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutUserInput>
    createMany?: CommentLikesCreateManyUserInputEnvelope
    connect?: Enumerable<CommentLikesWhereUniqueInput>
  }

  export type PostLikesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutUserInput>, Enumerable<PostLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutUserInput>
    createMany?: PostLikesCreateManyUserInputEnvelope
    connect?: Enumerable<PostLikesWhereUniqueInput>
  }

  export type AttachedLinkCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutUserInput>, Enumerable<AttachedLinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutUserInput>
    createMany?: AttachedLinkCreateManyUserInputEnvelope
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
  }

  export type CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutUserInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutUserInput>
    createMany?: CampaignParticipantsCreateManyUserInputEnvelope
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
  }

  export type CommentUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutUserInput>, Enumerable<CommentUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutUserInput>
    createMany?: CommentUserCreateManyUserInputEnvelope
    connect?: Enumerable<CommentUserWhereUniqueInput>
  }

  export type FollowingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutUserInput>, Enumerable<FollowingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutUserInput>
    createMany?: FollowingCreateManyUserInputEnvelope
    connect?: Enumerable<FollowingWhereUniqueInput>
  }

  export type PostUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutUserInput>, Enumerable<PostUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutUserInput>
    createMany?: PostUserCreateManyUserInputEnvelope
    connect?: Enumerable<PostUserWhereUniqueInput>
  }

  export type UserAddressUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    connect?: UserAddressWhereUniqueInput
  }

  export type UserPhoneUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    connect?: UserPhoneWhereUniqueInput
  }

  export type CommentLikesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutUserInput>, Enumerable<CommentLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutUserInput>
    createMany?: CommentLikesCreateManyUserInputEnvelope
    connect?: Enumerable<CommentLikesWhereUniqueInput>
  }

  export type PostLikesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutUserInput>, Enumerable<PostLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutUserInput>
    createMany?: PostLikesCreateManyUserInputEnvelope
    connect?: Enumerable<PostLikesWhereUniqueInput>
  }

  export type AttachedLinkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutUserInput>, Enumerable<AttachedLinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutUserInput>
    createMany?: AttachedLinkCreateManyUserInputEnvelope
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CampaignParticipantsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutUserInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CampaignParticipantsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CampaignParticipantsCreateManyUserInputEnvelope
    set?: Enumerable<CampaignParticipantsWhereUniqueInput>
    disconnect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    delete?: Enumerable<CampaignParticipantsWhereUniqueInput>
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    update?: Enumerable<CampaignParticipantsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CampaignParticipantsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CampaignParticipantsScalarWhereInput>
  }

  export type CommentUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutUserInput>, Enumerable<CommentUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentUserCreateManyUserInputEnvelope
    set?: Enumerable<CommentUserWhereUniqueInput>
    disconnect?: Enumerable<CommentUserWhereUniqueInput>
    delete?: Enumerable<CommentUserWhereUniqueInput>
    connect?: Enumerable<CommentUserWhereUniqueInput>
    update?: Enumerable<CommentUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentUserScalarWhereInput>
  }

  export type FollowingUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutUserInput>, Enumerable<FollowingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FollowingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FollowingCreateManyUserInputEnvelope
    set?: Enumerable<FollowingWhereUniqueInput>
    disconnect?: Enumerable<FollowingWhereUniqueInput>
    delete?: Enumerable<FollowingWhereUniqueInput>
    connect?: Enumerable<FollowingWhereUniqueInput>
    update?: Enumerable<FollowingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FollowingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FollowingScalarWhereInput>
  }

  export type PostUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutUserInput>, Enumerable<PostUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostUserCreateManyUserInputEnvelope
    set?: Enumerable<PostUserWhereUniqueInput>
    disconnect?: Enumerable<PostUserWhereUniqueInput>
    delete?: Enumerable<PostUserWhereUniqueInput>
    connect?: Enumerable<PostUserWhereUniqueInput>
    update?: Enumerable<PostUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostUserScalarWhereInput>
  }

  export type GenderUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
    connectOrCreate?: GenderCreateOrConnectWithoutUserInput
    upsert?: GenderUpsertWithoutUserInput
    connect?: GenderWhereUniqueInput
    update?: XOR<GenderUpdateWithoutUserInput, GenderUncheckedUpdateWithoutUserInput>
  }

  export type TypeUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<TypeCreateWithoutUserInput, TypeUncheckedCreateWithoutUserInput>
    connectOrCreate?: TypeCreateOrConnectWithoutUserInput
    upsert?: TypeUpsertWithoutUserInput
    connect?: TypeWhereUniqueInput
    update?: XOR<TypeUpdateWithoutUserInput, TypeUncheckedUpdateWithoutUserInput>
  }

  export type UserAddressUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    upsert?: UserAddressUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserAddressWhereUniqueInput
    update?: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserPhoneUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    upsert?: UserPhoneUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserPhoneWhereUniqueInput
    update?: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type CommentLikesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutUserInput>, Enumerable<CommentLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentLikesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentLikesCreateManyUserInputEnvelope
    set?: Enumerable<CommentLikesWhereUniqueInput>
    disconnect?: Enumerable<CommentLikesWhereUniqueInput>
    delete?: Enumerable<CommentLikesWhereUniqueInput>
    connect?: Enumerable<CommentLikesWhereUniqueInput>
    update?: Enumerable<CommentLikesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentLikesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentLikesScalarWhereInput>
  }

  export type PostLikesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutUserInput>, Enumerable<PostLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostLikesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostLikesCreateManyUserInputEnvelope
    set?: Enumerable<PostLikesWhereUniqueInput>
    disconnect?: Enumerable<PostLikesWhereUniqueInput>
    delete?: Enumerable<PostLikesWhereUniqueInput>
    connect?: Enumerable<PostLikesWhereUniqueInput>
    update?: Enumerable<PostLikesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostLikesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostLikesScalarWhereInput>
  }

  export type AttachedLinkUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutUserInput>, Enumerable<AttachedLinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AttachedLinkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AttachedLinkCreateManyUserInputEnvelope
    set?: Enumerable<AttachedLinkWhereUniqueInput>
    disconnect?: Enumerable<AttachedLinkWhereUniqueInput>
    delete?: Enumerable<AttachedLinkWhereUniqueInput>
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
    update?: Enumerable<AttachedLinkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AttachedLinkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AttachedLinkScalarWhereInput>
  }

  export type CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutUserInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CampaignParticipantsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CampaignParticipantsCreateManyUserInputEnvelope
    set?: Enumerable<CampaignParticipantsWhereUniqueInput>
    disconnect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    delete?: Enumerable<CampaignParticipantsWhereUniqueInput>
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    update?: Enumerable<CampaignParticipantsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CampaignParticipantsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CampaignParticipantsScalarWhereInput>
  }

  export type CommentUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutUserInput>, Enumerable<CommentUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentUserCreateManyUserInputEnvelope
    set?: Enumerable<CommentUserWhereUniqueInput>
    disconnect?: Enumerable<CommentUserWhereUniqueInput>
    delete?: Enumerable<CommentUserWhereUniqueInput>
    connect?: Enumerable<CommentUserWhereUniqueInput>
    update?: Enumerable<CommentUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentUserScalarWhereInput>
  }

  export type FollowingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutUserInput>, Enumerable<FollowingUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<FollowingUpsertWithWhereUniqueWithoutUserInput>
    createMany?: FollowingCreateManyUserInputEnvelope
    set?: Enumerable<FollowingWhereUniqueInput>
    disconnect?: Enumerable<FollowingWhereUniqueInput>
    delete?: Enumerable<FollowingWhereUniqueInput>
    connect?: Enumerable<FollowingWhereUniqueInput>
    update?: Enumerable<FollowingUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<FollowingUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<FollowingScalarWhereInput>
  }

  export type PostUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutUserInput>, Enumerable<PostUserUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUserUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostUserCreateManyUserInputEnvelope
    set?: Enumerable<PostUserWhereUniqueInput>
    disconnect?: Enumerable<PostUserWhereUniqueInput>
    delete?: Enumerable<PostUserWhereUniqueInput>
    connect?: Enumerable<PostUserWhereUniqueInput>
    update?: Enumerable<PostUserUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUserUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostUserScalarWhereInput>
  }

  export type UserAddressUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserAddressCreateOrConnectWithoutUserInput
    upsert?: UserAddressUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserAddressWhereUniqueInput
    update?: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
  }

  export type UserPhoneUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPhoneCreateOrConnectWithoutUserInput
    upsert?: UserPhoneUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserPhoneWhereUniqueInput
    update?: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
  }

  export type CommentLikesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutUserInput>, Enumerable<CommentLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentLikesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentLikesCreateManyUserInputEnvelope
    set?: Enumerable<CommentLikesWhereUniqueInput>
    disconnect?: Enumerable<CommentLikesWhereUniqueInput>
    delete?: Enumerable<CommentLikesWhereUniqueInput>
    connect?: Enumerable<CommentLikesWhereUniqueInput>
    update?: Enumerable<CommentLikesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentLikesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentLikesScalarWhereInput>
  }

  export type PostLikesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutUserInput>, Enumerable<PostLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostLikesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostLikesCreateManyUserInputEnvelope
    set?: Enumerable<PostLikesWhereUniqueInput>
    disconnect?: Enumerable<PostLikesWhereUniqueInput>
    delete?: Enumerable<PostLikesWhereUniqueInput>
    connect?: Enumerable<PostLikesWhereUniqueInput>
    update?: Enumerable<PostLikesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostLikesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostLikesScalarWhereInput>
  }

  export type AttachedLinkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutUserInput>, Enumerable<AttachedLinkUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<AttachedLinkUpsertWithWhereUniqueWithoutUserInput>
    createMany?: AttachedLinkCreateManyUserInputEnvelope
    set?: Enumerable<AttachedLinkWhereUniqueInput>
    disconnect?: Enumerable<AttachedLinkWhereUniqueInput>
    delete?: Enumerable<AttachedLinkWhereUniqueInput>
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
    update?: Enumerable<AttachedLinkUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<AttachedLinkUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<AttachedLinkScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutGenderInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutGenderNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutGenderInput>, Enumerable<UserUncheckedCreateWithoutGenderInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutGenderInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutGenderInput>
    createMany?: UserCreateManyGenderInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutGenderInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutGenderInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NgoPhoneCreateNestedManyWithoutPhoneInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutPhoneInput>, Enumerable<NgoPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutPhoneInput>
    createMany?: NgoPhoneCreateManyPhoneInputEnvelope
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
  }

  export type UserPhoneCreateNestedManyWithoutPhoneInput = {
    create?: XOR<Enumerable<UserPhoneCreateWithoutPhoneInput>, Enumerable<UserPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<UserPhoneCreateOrConnectWithoutPhoneInput>
    createMany?: UserPhoneCreateManyPhoneInputEnvelope
    connect?: Enumerable<UserPhoneWhereUniqueInput>
  }

  export type NgoPhoneUncheckedCreateNestedManyWithoutPhoneInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutPhoneInput>, Enumerable<NgoPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutPhoneInput>
    createMany?: NgoPhoneCreateManyPhoneInputEnvelope
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
  }

  export type UserPhoneUncheckedCreateNestedManyWithoutPhoneInput = {
    create?: XOR<Enumerable<UserPhoneCreateWithoutPhoneInput>, Enumerable<UserPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<UserPhoneCreateOrConnectWithoutPhoneInput>
    createMany?: UserPhoneCreateManyPhoneInputEnvelope
    connect?: Enumerable<UserPhoneWhereUniqueInput>
  }

  export type NgoPhoneUpdateManyWithoutPhoneNestedInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutPhoneInput>, Enumerable<NgoPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutPhoneInput>
    upsert?: Enumerable<NgoPhoneUpsertWithWhereUniqueWithoutPhoneInput>
    createMany?: NgoPhoneCreateManyPhoneInputEnvelope
    set?: Enumerable<NgoPhoneWhereUniqueInput>
    disconnect?: Enumerable<NgoPhoneWhereUniqueInput>
    delete?: Enumerable<NgoPhoneWhereUniqueInput>
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
    update?: Enumerable<NgoPhoneUpdateWithWhereUniqueWithoutPhoneInput>
    updateMany?: Enumerable<NgoPhoneUpdateManyWithWhereWithoutPhoneInput>
    deleteMany?: Enumerable<NgoPhoneScalarWhereInput>
  }

  export type UserPhoneUpdateManyWithoutPhoneNestedInput = {
    create?: XOR<Enumerable<UserPhoneCreateWithoutPhoneInput>, Enumerable<UserPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<UserPhoneCreateOrConnectWithoutPhoneInput>
    upsert?: Enumerable<UserPhoneUpsertWithWhereUniqueWithoutPhoneInput>
    createMany?: UserPhoneCreateManyPhoneInputEnvelope
    set?: Enumerable<UserPhoneWhereUniqueInput>
    disconnect?: Enumerable<UserPhoneWhereUniqueInput>
    delete?: Enumerable<UserPhoneWhereUniqueInput>
    connect?: Enumerable<UserPhoneWhereUniqueInput>
    update?: Enumerable<UserPhoneUpdateWithWhereUniqueWithoutPhoneInput>
    updateMany?: Enumerable<UserPhoneUpdateManyWithWhereWithoutPhoneInput>
    deleteMany?: Enumerable<UserPhoneScalarWhereInput>
  }

  export type NgoPhoneUncheckedUpdateManyWithoutPhoneNestedInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutPhoneInput>, Enumerable<NgoPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutPhoneInput>
    upsert?: Enumerable<NgoPhoneUpsertWithWhereUniqueWithoutPhoneInput>
    createMany?: NgoPhoneCreateManyPhoneInputEnvelope
    set?: Enumerable<NgoPhoneWhereUniqueInput>
    disconnect?: Enumerable<NgoPhoneWhereUniqueInput>
    delete?: Enumerable<NgoPhoneWhereUniqueInput>
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
    update?: Enumerable<NgoPhoneUpdateWithWhereUniqueWithoutPhoneInput>
    updateMany?: Enumerable<NgoPhoneUpdateManyWithWhereWithoutPhoneInput>
    deleteMany?: Enumerable<NgoPhoneScalarWhereInput>
  }

  export type UserPhoneUncheckedUpdateManyWithoutPhoneNestedInput = {
    create?: XOR<Enumerable<UserPhoneCreateWithoutPhoneInput>, Enumerable<UserPhoneUncheckedCreateWithoutPhoneInput>>
    connectOrCreate?: Enumerable<UserPhoneCreateOrConnectWithoutPhoneInput>
    upsert?: Enumerable<UserPhoneUpsertWithWhereUniqueWithoutPhoneInput>
    createMany?: UserPhoneCreateManyPhoneInputEnvelope
    set?: Enumerable<UserPhoneWhereUniqueInput>
    disconnect?: Enumerable<UserPhoneWhereUniqueInput>
    delete?: Enumerable<UserPhoneWhereUniqueInput>
    connect?: Enumerable<UserPhoneWhereUniqueInput>
    update?: Enumerable<UserPhoneUpdateWithWhereUniqueWithoutPhoneInput>
    updateMany?: Enumerable<UserPhoneUpdateManyWithWhereWithoutPhoneInput>
    deleteMany?: Enumerable<UserPhoneScalarWhereInput>
  }

  export type CampaignAddressCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<CampaignAddressCreateWithoutAddressInput>, Enumerable<CampaignAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CampaignAddressCreateOrConnectWithoutAddressInput>
    createMany?: CampaignAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<CampaignAddressWhereUniqueInput>
  }

  export type NgoAddressCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<NgoAddressCreateWithoutAddressInput>, Enumerable<NgoAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<NgoAddressCreateOrConnectWithoutAddressInput>
    createMany?: NgoAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<NgoAddressWhereUniqueInput>
  }

  export type UserAddressCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type CampaignAddressUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<CampaignAddressCreateWithoutAddressInput>, Enumerable<CampaignAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CampaignAddressCreateOrConnectWithoutAddressInput>
    createMany?: CampaignAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<CampaignAddressWhereUniqueInput>
  }

  export type NgoAddressUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<NgoAddressCreateWithoutAddressInput>, Enumerable<NgoAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<NgoAddressCreateOrConnectWithoutAddressInput>
    createMany?: NgoAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<NgoAddressWhereUniqueInput>
  }

  export type UserAddressUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    connect?: Enumerable<UserAddressWhereUniqueInput>
  }

  export type CampaignAddressUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<CampaignAddressCreateWithoutAddressInput>, Enumerable<CampaignAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CampaignAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<CampaignAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: CampaignAddressCreateManyAddressInputEnvelope
    set?: Enumerable<CampaignAddressWhereUniqueInput>
    disconnect?: Enumerable<CampaignAddressWhereUniqueInput>
    delete?: Enumerable<CampaignAddressWhereUniqueInput>
    connect?: Enumerable<CampaignAddressWhereUniqueInput>
    update?: Enumerable<CampaignAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<CampaignAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<CampaignAddressScalarWhereInput>
  }

  export type NgoAddressUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<NgoAddressCreateWithoutAddressInput>, Enumerable<NgoAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<NgoAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<NgoAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: NgoAddressCreateManyAddressInputEnvelope
    set?: Enumerable<NgoAddressWhereUniqueInput>
    disconnect?: Enumerable<NgoAddressWhereUniqueInput>
    delete?: Enumerable<NgoAddressWhereUniqueInput>
    connect?: Enumerable<NgoAddressWhereUniqueInput>
    update?: Enumerable<NgoAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<NgoAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<NgoAddressScalarWhereInput>
  }

  export type UserAddressUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type CampaignAddressUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<CampaignAddressCreateWithoutAddressInput>, Enumerable<CampaignAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<CampaignAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<CampaignAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: CampaignAddressCreateManyAddressInputEnvelope
    set?: Enumerable<CampaignAddressWhereUniqueInput>
    disconnect?: Enumerable<CampaignAddressWhereUniqueInput>
    delete?: Enumerable<CampaignAddressWhereUniqueInput>
    connect?: Enumerable<CampaignAddressWhereUniqueInput>
    update?: Enumerable<CampaignAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<CampaignAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<CampaignAddressScalarWhereInput>
  }

  export type NgoAddressUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<NgoAddressCreateWithoutAddressInput>, Enumerable<NgoAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<NgoAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<NgoAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: NgoAddressCreateManyAddressInputEnvelope
    set?: Enumerable<NgoAddressWhereUniqueInput>
    disconnect?: Enumerable<NgoAddressWhereUniqueInput>
    delete?: Enumerable<NgoAddressWhereUniqueInput>
    connect?: Enumerable<NgoAddressWhereUniqueInput>
    update?: Enumerable<NgoAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<NgoAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<NgoAddressScalarWhereInput>
  }

  export type UserAddressUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<Enumerable<UserAddressCreateWithoutAddressInput>, Enumerable<UserAddressUncheckedCreateWithoutAddressInput>>
    connectOrCreate?: Enumerable<UserAddressCreateOrConnectWithoutAddressInput>
    upsert?: Enumerable<UserAddressUpsertWithWhereUniqueWithoutAddressInput>
    createMany?: UserAddressCreateManyAddressInputEnvelope
    set?: Enumerable<UserAddressWhereUniqueInput>
    disconnect?: Enumerable<UserAddressWhereUniqueInput>
    delete?: Enumerable<UserAddressWhereUniqueInput>
    connect?: Enumerable<UserAddressWhereUniqueInput>
    update?: Enumerable<UserAddressUpdateWithWhereUniqueWithoutAddressInput>
    updateMany?: Enumerable<UserAddressUpdateManyWithWhereWithoutAddressInput>
    deleteMany?: Enumerable<UserAddressScalarWhereInput>
  }

  export type AddressCreateNestedOneWithoutUser_addressInput = {
    create?: XOR<AddressCreateWithoutUser_addressInput, AddressUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUser_addressInput
    connect?: AddressWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_addressInput = {
    create?: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_addressInput
    connect?: UserWhereUniqueInput
  }

  export type AddressUpdateOneRequiredWithoutUser_addressNestedInput = {
    create?: XOR<AddressCreateWithoutUser_addressInput, AddressUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutUser_addressInput
    upsert?: AddressUpsertWithoutUser_addressInput
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutUser_addressInput, AddressUncheckedUpdateWithoutUser_addressInput>
  }

  export type UserUpdateOneRequiredWithoutUser_addressNestedInput = {
    create?: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_addressInput
    upsert?: UserUpsertWithoutUser_addressInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_addressInput, UserUncheckedUpdateWithoutUser_addressInput>
  }

  export type NGOCreateNestedOneWithoutCampaignInput = {
    create?: XOR<NGOCreateWithoutCampaignInput, NGOUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: NGOCreateOrConnectWithoutCampaignInput
    connect?: NGOWhereUniqueInput
  }

  export type CampaignAddressCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignAddressCreateWithoutCampaignInput, CampaignAddressUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAddressCreateOrConnectWithoutCampaignInput
    connect?: CampaignAddressWhereUniqueInput
  }

  export type CampaignCausesCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCampaignInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignCausesCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
  }

  export type CampaignParticipantsCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutCampaignInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignParticipantsCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
  }

  export type CampaignPhotosCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignPhotosCreateWithoutCampaignInput>, Enumerable<CampaignPhotosUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignPhotosCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignPhotosCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignPhotosWhereUniqueInput>
  }

  export type CampaignAddressUncheckedCreateNestedOneWithoutCampaignInput = {
    create?: XOR<CampaignAddressCreateWithoutCampaignInput, CampaignAddressUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAddressCreateOrConnectWithoutCampaignInput
    connect?: CampaignAddressWhereUniqueInput
  }

  export type CampaignCausesUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCampaignInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignCausesCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
  }

  export type CampaignParticipantsUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutCampaignInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignParticipantsCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
  }

  export type CampaignPhotosUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<Enumerable<CampaignPhotosCreateWithoutCampaignInput>, Enumerable<CampaignPhotosUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignPhotosCreateOrConnectWithoutCampaignInput>
    createMany?: CampaignPhotosCreateManyCampaignInputEnvelope
    connect?: Enumerable<CampaignPhotosWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NGOUpdateOneRequiredWithoutCampaignNestedInput = {
    create?: XOR<NGOCreateWithoutCampaignInput, NGOUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: NGOCreateOrConnectWithoutCampaignInput
    upsert?: NGOUpsertWithoutCampaignInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutCampaignInput, NGOUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignAddressUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignAddressCreateWithoutCampaignInput, CampaignAddressUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAddressCreateOrConnectWithoutCampaignInput
    upsert?: CampaignAddressUpsertWithoutCampaignInput
    disconnect?: boolean
    delete?: boolean
    connect?: CampaignAddressWhereUniqueInput
    update?: XOR<CampaignAddressUpdateWithoutCampaignInput, CampaignAddressUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignCausesUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCampaignInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignCausesUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignCausesCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignCausesWhereUniqueInput>
    disconnect?: Enumerable<CampaignCausesWhereUniqueInput>
    delete?: Enumerable<CampaignCausesWhereUniqueInput>
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
    update?: Enumerable<CampaignCausesUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignCausesUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignCausesScalarWhereInput>
  }

  export type CampaignParticipantsUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutCampaignInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignParticipantsUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignParticipantsCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignParticipantsWhereUniqueInput>
    disconnect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    delete?: Enumerable<CampaignParticipantsWhereUniqueInput>
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    update?: Enumerable<CampaignParticipantsUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignParticipantsUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignParticipantsScalarWhereInput>
  }

  export type CampaignPhotosUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignPhotosCreateWithoutCampaignInput>, Enumerable<CampaignPhotosUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignPhotosCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignPhotosUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignPhotosCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignPhotosWhereUniqueInput>
    disconnect?: Enumerable<CampaignPhotosWhereUniqueInput>
    delete?: Enumerable<CampaignPhotosWhereUniqueInput>
    connect?: Enumerable<CampaignPhotosWhereUniqueInput>
    update?: Enumerable<CampaignPhotosUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignPhotosUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignPhotosScalarWhereInput>
  }

  export type CampaignAddressUncheckedUpdateOneWithoutCampaignNestedInput = {
    create?: XOR<CampaignAddressCreateWithoutCampaignInput, CampaignAddressUncheckedCreateWithoutCampaignInput>
    connectOrCreate?: CampaignAddressCreateOrConnectWithoutCampaignInput
    upsert?: CampaignAddressUpsertWithoutCampaignInput
    disconnect?: boolean
    delete?: boolean
    connect?: CampaignAddressWhereUniqueInput
    update?: XOR<CampaignAddressUpdateWithoutCampaignInput, CampaignAddressUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignCausesUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCampaignInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignCausesUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignCausesCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignCausesWhereUniqueInput>
    disconnect?: Enumerable<CampaignCausesWhereUniqueInput>
    delete?: Enumerable<CampaignCausesWhereUniqueInput>
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
    update?: Enumerable<CampaignCausesUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignCausesUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignCausesScalarWhereInput>
  }

  export type CampaignParticipantsUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutCampaignInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignParticipantsUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignParticipantsCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignParticipantsWhereUniqueInput>
    disconnect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    delete?: Enumerable<CampaignParticipantsWhereUniqueInput>
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    update?: Enumerable<CampaignParticipantsUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignParticipantsUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignParticipantsScalarWhereInput>
  }

  export type CampaignPhotosUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<Enumerable<CampaignPhotosCreateWithoutCampaignInput>, Enumerable<CampaignPhotosUncheckedCreateWithoutCampaignInput>>
    connectOrCreate?: Enumerable<CampaignPhotosCreateOrConnectWithoutCampaignInput>
    upsert?: Enumerable<CampaignPhotosUpsertWithWhereUniqueWithoutCampaignInput>
    createMany?: CampaignPhotosCreateManyCampaignInputEnvelope
    set?: Enumerable<CampaignPhotosWhereUniqueInput>
    disconnect?: Enumerable<CampaignPhotosWhereUniqueInput>
    delete?: Enumerable<CampaignPhotosWhereUniqueInput>
    connect?: Enumerable<CampaignPhotosWhereUniqueInput>
    update?: Enumerable<CampaignPhotosUpdateWithWhereUniqueWithoutCampaignInput>
    updateMany?: Enumerable<CampaignPhotosUpdateManyWithWhereWithoutCampaignInput>
    deleteMany?: Enumerable<CampaignPhotosScalarWhereInput>
  }

  export type CampaignCreateNestedOneWithoutCampaign_addressInput = {
    create?: XOR<CampaignCreateWithoutCampaign_addressInput, CampaignUncheckedCreateWithoutCampaign_addressInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_addressInput
    connect?: CampaignWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutCampaign_addressInput = {
    create?: XOR<AddressCreateWithoutCampaign_addressInput, AddressUncheckedCreateWithoutCampaign_addressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCampaign_addressInput
    connect?: AddressWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaign_addressNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaign_addressInput, CampaignUncheckedCreateWithoutCampaign_addressInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_addressInput
    upsert?: CampaignUpsertWithoutCampaign_addressInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutCampaign_addressInput, CampaignUncheckedUpdateWithoutCampaign_addressInput>
  }

  export type AddressUpdateOneRequiredWithoutCampaign_addressNestedInput = {
    create?: XOR<AddressCreateWithoutCampaign_addressInput, AddressUncheckedCreateWithoutCampaign_addressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCampaign_addressInput
    upsert?: AddressUpsertWithoutCampaign_addressInput
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutCampaign_addressInput, AddressUncheckedUpdateWithoutCampaign_addressInput>
  }

  export type CampaignCreateNestedOneWithoutCampaign_causesInput = {
    create?: XOR<CampaignCreateWithoutCampaign_causesInput, CampaignUncheckedCreateWithoutCampaign_causesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_causesInput
    connect?: CampaignWhereUniqueInput
  }

  export type CausesCreateNestedOneWithoutCampaign_causesInput = {
    create?: XOR<CausesCreateWithoutCampaign_causesInput, CausesUncheckedCreateWithoutCampaign_causesInput>
    connectOrCreate?: CausesCreateOrConnectWithoutCampaign_causesInput
    connect?: CausesWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaign_causesNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaign_causesInput, CampaignUncheckedCreateWithoutCampaign_causesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_causesInput
    upsert?: CampaignUpsertWithoutCampaign_causesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutCampaign_causesInput, CampaignUncheckedUpdateWithoutCampaign_causesInput>
  }

  export type CausesUpdateOneRequiredWithoutCampaign_causesNestedInput = {
    create?: XOR<CausesCreateWithoutCampaign_causesInput, CausesUncheckedCreateWithoutCampaign_causesInput>
    connectOrCreate?: CausesCreateOrConnectWithoutCampaign_causesInput
    upsert?: CausesUpsertWithoutCampaign_causesInput
    connect?: CausesWhereUniqueInput
    update?: XOR<CausesUpdateWithoutCampaign_causesInput, CausesUncheckedUpdateWithoutCampaign_causesInput>
  }

  export type CampaignCreateNestedOneWithoutCampaign_participantsInput = {
    create?: XOR<CampaignCreateWithoutCampaign_participantsInput, CampaignUncheckedCreateWithoutCampaign_participantsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_participantsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupported_campaignsInput = {
    create?: XOR<UserCreateWithoutSupported_campaignsInput, UserUncheckedCreateWithoutSupported_campaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupported_campaignsInput
    connect?: UserWhereUniqueInput
  }

  export type StatusCreateNestedOneWithoutCampaignParticipantsInput = {
    create?: XOR<StatusCreateWithoutCampaignParticipantsInput, StatusUncheckedCreateWithoutCampaignParticipantsInput>
    connectOrCreate?: StatusCreateOrConnectWithoutCampaignParticipantsInput
    connect?: StatusWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaign_participantsNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaign_participantsInput, CampaignUncheckedCreateWithoutCampaign_participantsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_participantsInput
    upsert?: CampaignUpsertWithoutCampaign_participantsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutCampaign_participantsInput, CampaignUncheckedUpdateWithoutCampaign_participantsInput>
  }

  export type UserUpdateOneRequiredWithoutSupported_campaignsNestedInput = {
    create?: XOR<UserCreateWithoutSupported_campaignsInput, UserUncheckedCreateWithoutSupported_campaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupported_campaignsInput
    upsert?: UserUpsertWithoutSupported_campaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSupported_campaignsInput, UserUncheckedUpdateWithoutSupported_campaignsInput>
  }

  export type StatusUpdateOneRequiredWithoutCampaignParticipantsNestedInput = {
    create?: XOR<StatusCreateWithoutCampaignParticipantsInput, StatusUncheckedCreateWithoutCampaignParticipantsInput>
    connectOrCreate?: StatusCreateOrConnectWithoutCampaignParticipantsInput
    upsert?: StatusUpsertWithoutCampaignParticipantsInput
    connect?: StatusWhereUniqueInput
    update?: XOR<StatusUpdateWithoutCampaignParticipantsInput, StatusUncheckedUpdateWithoutCampaignParticipantsInput>
  }

  export type CampaignCreateNestedOneWithoutCampaign_photosInput = {
    create?: XOR<CampaignCreateWithoutCampaign_photosInput, CampaignUncheckedCreateWithoutCampaign_photosInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_photosInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutCampaign_photosNestedInput = {
    create?: XOR<CampaignCreateWithoutCampaign_photosInput, CampaignUncheckedCreateWithoutCampaign_photosInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCampaign_photosInput
    upsert?: CampaignUpsertWithoutCampaign_photosInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<CampaignUpdateWithoutCampaign_photosInput, CampaignUncheckedUpdateWithoutCampaign_photosInput>
  }

  export type CampaignCausesCreateNestedManyWithoutCausesInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCausesInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCausesInput>
    createMany?: CampaignCausesCreateManyCausesInputEnvelope
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
  }

  export type NgoCausesCreateNestedManyWithoutCausesInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutCausesInput>, Enumerable<NgoCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutCausesInput>
    createMany?: NgoCausesCreateManyCausesInputEnvelope
    connect?: Enumerable<NgoCausesWhereUniqueInput>
  }

  export type CampaignCausesUncheckedCreateNestedManyWithoutCausesInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCausesInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCausesInput>
    createMany?: CampaignCausesCreateManyCausesInputEnvelope
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
  }

  export type NgoCausesUncheckedCreateNestedManyWithoutCausesInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutCausesInput>, Enumerable<NgoCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutCausesInput>
    createMany?: NgoCausesCreateManyCausesInputEnvelope
    connect?: Enumerable<NgoCausesWhereUniqueInput>
  }

  export type CampaignCausesUpdateManyWithoutCausesNestedInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCausesInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCausesInput>
    upsert?: Enumerable<CampaignCausesUpsertWithWhereUniqueWithoutCausesInput>
    createMany?: CampaignCausesCreateManyCausesInputEnvelope
    set?: Enumerable<CampaignCausesWhereUniqueInput>
    disconnect?: Enumerable<CampaignCausesWhereUniqueInput>
    delete?: Enumerable<CampaignCausesWhereUniqueInput>
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
    update?: Enumerable<CampaignCausesUpdateWithWhereUniqueWithoutCausesInput>
    updateMany?: Enumerable<CampaignCausesUpdateManyWithWhereWithoutCausesInput>
    deleteMany?: Enumerable<CampaignCausesScalarWhereInput>
  }

  export type NgoCausesUpdateManyWithoutCausesNestedInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutCausesInput>, Enumerable<NgoCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutCausesInput>
    upsert?: Enumerable<NgoCausesUpsertWithWhereUniqueWithoutCausesInput>
    createMany?: NgoCausesCreateManyCausesInputEnvelope
    set?: Enumerable<NgoCausesWhereUniqueInput>
    disconnect?: Enumerable<NgoCausesWhereUniqueInput>
    delete?: Enumerable<NgoCausesWhereUniqueInput>
    connect?: Enumerable<NgoCausesWhereUniqueInput>
    update?: Enumerable<NgoCausesUpdateWithWhereUniqueWithoutCausesInput>
    updateMany?: Enumerable<NgoCausesUpdateManyWithWhereWithoutCausesInput>
    deleteMany?: Enumerable<NgoCausesScalarWhereInput>
  }

  export type CampaignCausesUncheckedUpdateManyWithoutCausesNestedInput = {
    create?: XOR<Enumerable<CampaignCausesCreateWithoutCausesInput>, Enumerable<CampaignCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<CampaignCausesCreateOrConnectWithoutCausesInput>
    upsert?: Enumerable<CampaignCausesUpsertWithWhereUniqueWithoutCausesInput>
    createMany?: CampaignCausesCreateManyCausesInputEnvelope
    set?: Enumerable<CampaignCausesWhereUniqueInput>
    disconnect?: Enumerable<CampaignCausesWhereUniqueInput>
    delete?: Enumerable<CampaignCausesWhereUniqueInput>
    connect?: Enumerable<CampaignCausesWhereUniqueInput>
    update?: Enumerable<CampaignCausesUpdateWithWhereUniqueWithoutCausesInput>
    updateMany?: Enumerable<CampaignCausesUpdateManyWithWhereWithoutCausesInput>
    deleteMany?: Enumerable<CampaignCausesScalarWhereInput>
  }

  export type NgoCausesUncheckedUpdateManyWithoutCausesNestedInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutCausesInput>, Enumerable<NgoCausesUncheckedCreateWithoutCausesInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutCausesInput>
    upsert?: Enumerable<NgoCausesUpsertWithWhereUniqueWithoutCausesInput>
    createMany?: NgoCausesCreateManyCausesInputEnvelope
    set?: Enumerable<NgoCausesWhereUniqueInput>
    disconnect?: Enumerable<NgoCausesWhereUniqueInput>
    delete?: Enumerable<NgoCausesWhereUniqueInput>
    connect?: Enumerable<NgoCausesWhereUniqueInput>
    update?: Enumerable<NgoCausesUpdateWithWhereUniqueWithoutCausesInput>
    updateMany?: Enumerable<NgoCausesUpdateManyWithWhereWithoutCausesInput>
    deleteMany?: Enumerable<NgoCausesScalarWhereInput>
  }

  export type StatusCreateNestedOneWithoutFollowingInput = {
    create?: XOR<StatusCreateWithoutFollowingInput, StatusUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: StatusCreateOrConnectWithoutFollowingInput
    connect?: StatusWhereUniqueInput
  }

  export type NGOCreateNestedOneWithoutFollowingInput = {
    create?: XOR<NGOCreateWithoutFollowingInput, NGOUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: NGOCreateOrConnectWithoutFollowingInput
    connect?: NGOWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type StatusUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<StatusCreateWithoutFollowingInput, StatusUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: StatusCreateOrConnectWithoutFollowingInput
    upsert?: StatusUpsertWithoutFollowingInput
    connect?: StatusWhereUniqueInput
    update?: XOR<StatusUpdateWithoutFollowingInput, StatusUncheckedUpdateWithoutFollowingInput>
  }

  export type NGOUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<NGOCreateWithoutFollowingInput, NGOUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: NGOCreateOrConnectWithoutFollowingInput
    upsert?: NGOUpsertWithoutFollowingInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutFollowingInput, NGOUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type CampaignCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutNgoInput>, Enumerable<CampaignUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutNgoInput>
    createMany?: CampaignCreateManyNgoInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CommentNgoCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutNgoInput>, Enumerable<CommentNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutNgoInput>
    createMany?: CommentNgoCreateManyNgoInputEnvelope
    connect?: Enumerable<CommentNgoWhereUniqueInput>
  }

  export type FollowingCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutNgoInput>, Enumerable<FollowingUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutNgoInput>
    createMany?: FollowingCreateManyNgoInputEnvelope
    connect?: Enumerable<FollowingWhereUniqueInput>
  }

  export type TypeCreateNestedOneWithoutNgoInput = {
    create?: XOR<TypeCreateWithoutNgoInput, TypeUncheckedCreateWithoutNgoInput>
    connectOrCreate?: TypeCreateOrConnectWithoutNgoInput
    connect?: TypeWhereUniqueInput
  }

  export type NgoAddressCreateNestedOneWithoutNgoInput = {
    create?: XOR<NgoAddressCreateWithoutNgoInput, NgoAddressUncheckedCreateWithoutNgoInput>
    connectOrCreate?: NgoAddressCreateOrConnectWithoutNgoInput
    connect?: NgoAddressWhereUniqueInput
  }

  export type NgoCausesCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutNgoInput>, Enumerable<NgoCausesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutNgoInput>
    createMany?: NgoCausesCreateManyNgoInputEnvelope
    connect?: Enumerable<NgoCausesWhereUniqueInput>
  }

  export type NgoPhoneCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutNgoInput>, Enumerable<NgoPhoneUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutNgoInput>
    createMany?: NgoPhoneCreateManyNgoInputEnvelope
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
  }

  export type PostNgoCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutNgoInput>, Enumerable<PostNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutNgoInput>
    createMany?: PostNgoCreateManyNgoInputEnvelope
    connect?: Enumerable<PostNgoWhereUniqueInput>
  }

  export type CommentLikesCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutNgoInput>, Enumerable<CommentLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutNgoInput>
    createMany?: CommentLikesCreateManyNgoInputEnvelope
    connect?: Enumerable<CommentLikesWhereUniqueInput>
  }

  export type PostLikesCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutNgoInput>, Enumerable<PostLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutNgoInput>
    createMany?: PostLikesCreateManyNgoInputEnvelope
    connect?: Enumerable<PostLikesWhereUniqueInput>
  }

  export type AttachedLinkCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutNgoInput>, Enumerable<AttachedLinkUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutNgoInput>
    createMany?: AttachedLinkCreateManyNgoInputEnvelope
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
  }

  export type CampaignUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutNgoInput>, Enumerable<CampaignUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutNgoInput>
    createMany?: CampaignCreateManyNgoInputEnvelope
    connect?: Enumerable<CampaignWhereUniqueInput>
  }

  export type CommentNgoUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutNgoInput>, Enumerable<CommentNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutNgoInput>
    createMany?: CommentNgoCreateManyNgoInputEnvelope
    connect?: Enumerable<CommentNgoWhereUniqueInput>
  }

  export type FollowingUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutNgoInput>, Enumerable<FollowingUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutNgoInput>
    createMany?: FollowingCreateManyNgoInputEnvelope
    connect?: Enumerable<FollowingWhereUniqueInput>
  }

  export type NgoAddressUncheckedCreateNestedOneWithoutNgoInput = {
    create?: XOR<NgoAddressCreateWithoutNgoInput, NgoAddressUncheckedCreateWithoutNgoInput>
    connectOrCreate?: NgoAddressCreateOrConnectWithoutNgoInput
    connect?: NgoAddressWhereUniqueInput
  }

  export type NgoCausesUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutNgoInput>, Enumerable<NgoCausesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutNgoInput>
    createMany?: NgoCausesCreateManyNgoInputEnvelope
    connect?: Enumerable<NgoCausesWhereUniqueInput>
  }

  export type NgoPhoneUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutNgoInput>, Enumerable<NgoPhoneUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutNgoInput>
    createMany?: NgoPhoneCreateManyNgoInputEnvelope
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
  }

  export type PostNgoUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutNgoInput>, Enumerable<PostNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutNgoInput>
    createMany?: PostNgoCreateManyNgoInputEnvelope
    connect?: Enumerable<PostNgoWhereUniqueInput>
  }

  export type CommentLikesUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutNgoInput>, Enumerable<CommentLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutNgoInput>
    createMany?: CommentLikesCreateManyNgoInputEnvelope
    connect?: Enumerable<CommentLikesWhereUniqueInput>
  }

  export type PostLikesUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutNgoInput>, Enumerable<PostLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutNgoInput>
    createMany?: PostLikesCreateManyNgoInputEnvelope
    connect?: Enumerable<PostLikesWhereUniqueInput>
  }

  export type AttachedLinkUncheckedCreateNestedManyWithoutNgoInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutNgoInput>, Enumerable<AttachedLinkUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutNgoInput>
    createMany?: AttachedLinkCreateManyNgoInputEnvelope
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CampaignUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutNgoInput>, Enumerable<CampaignUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: CampaignCreateManyNgoInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CommentNgoUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutNgoInput>, Enumerable<CommentNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<CommentNgoUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: CommentNgoCreateManyNgoInputEnvelope
    set?: Enumerable<CommentNgoWhereUniqueInput>
    disconnect?: Enumerable<CommentNgoWhereUniqueInput>
    delete?: Enumerable<CommentNgoWhereUniqueInput>
    connect?: Enumerable<CommentNgoWhereUniqueInput>
    update?: Enumerable<CommentNgoUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<CommentNgoUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<CommentNgoScalarWhereInput>
  }

  export type FollowingUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutNgoInput>, Enumerable<FollowingUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<FollowingUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: FollowingCreateManyNgoInputEnvelope
    set?: Enumerable<FollowingWhereUniqueInput>
    disconnect?: Enumerable<FollowingWhereUniqueInput>
    delete?: Enumerable<FollowingWhereUniqueInput>
    connect?: Enumerable<FollowingWhereUniqueInput>
    update?: Enumerable<FollowingUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<FollowingUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<FollowingScalarWhereInput>
  }

  export type TypeUpdateOneRequiredWithoutNgoNestedInput = {
    create?: XOR<TypeCreateWithoutNgoInput, TypeUncheckedCreateWithoutNgoInput>
    connectOrCreate?: TypeCreateOrConnectWithoutNgoInput
    upsert?: TypeUpsertWithoutNgoInput
    connect?: TypeWhereUniqueInput
    update?: XOR<TypeUpdateWithoutNgoInput, TypeUncheckedUpdateWithoutNgoInput>
  }

  export type NgoAddressUpdateOneWithoutNgoNestedInput = {
    create?: XOR<NgoAddressCreateWithoutNgoInput, NgoAddressUncheckedCreateWithoutNgoInput>
    connectOrCreate?: NgoAddressCreateOrConnectWithoutNgoInput
    upsert?: NgoAddressUpsertWithoutNgoInput
    disconnect?: boolean
    delete?: boolean
    connect?: NgoAddressWhereUniqueInput
    update?: XOR<NgoAddressUpdateWithoutNgoInput, NgoAddressUncheckedUpdateWithoutNgoInput>
  }

  export type NgoCausesUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutNgoInput>, Enumerable<NgoCausesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<NgoCausesUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: NgoCausesCreateManyNgoInputEnvelope
    set?: Enumerable<NgoCausesWhereUniqueInput>
    disconnect?: Enumerable<NgoCausesWhereUniqueInput>
    delete?: Enumerable<NgoCausesWhereUniqueInput>
    connect?: Enumerable<NgoCausesWhereUniqueInput>
    update?: Enumerable<NgoCausesUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<NgoCausesUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<NgoCausesScalarWhereInput>
  }

  export type NgoPhoneUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutNgoInput>, Enumerable<NgoPhoneUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<NgoPhoneUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: NgoPhoneCreateManyNgoInputEnvelope
    set?: Enumerable<NgoPhoneWhereUniqueInput>
    disconnect?: Enumerable<NgoPhoneWhereUniqueInput>
    delete?: Enumerable<NgoPhoneWhereUniqueInput>
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
    update?: Enumerable<NgoPhoneUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<NgoPhoneUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<NgoPhoneScalarWhereInput>
  }

  export type PostNgoUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutNgoInput>, Enumerable<PostNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<PostNgoUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: PostNgoCreateManyNgoInputEnvelope
    set?: Enumerable<PostNgoWhereUniqueInput>
    disconnect?: Enumerable<PostNgoWhereUniqueInput>
    delete?: Enumerable<PostNgoWhereUniqueInput>
    connect?: Enumerable<PostNgoWhereUniqueInput>
    update?: Enumerable<PostNgoUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<PostNgoUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<PostNgoScalarWhereInput>
  }

  export type CommentLikesUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutNgoInput>, Enumerable<CommentLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<CommentLikesUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: CommentLikesCreateManyNgoInputEnvelope
    set?: Enumerable<CommentLikesWhereUniqueInput>
    disconnect?: Enumerable<CommentLikesWhereUniqueInput>
    delete?: Enumerable<CommentLikesWhereUniqueInput>
    connect?: Enumerable<CommentLikesWhereUniqueInput>
    update?: Enumerable<CommentLikesUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<CommentLikesUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<CommentLikesScalarWhereInput>
  }

  export type PostLikesUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutNgoInput>, Enumerable<PostLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<PostLikesUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: PostLikesCreateManyNgoInputEnvelope
    set?: Enumerable<PostLikesWhereUniqueInput>
    disconnect?: Enumerable<PostLikesWhereUniqueInput>
    delete?: Enumerable<PostLikesWhereUniqueInput>
    connect?: Enumerable<PostLikesWhereUniqueInput>
    update?: Enumerable<PostLikesUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<PostLikesUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<PostLikesScalarWhereInput>
  }

  export type AttachedLinkUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutNgoInput>, Enumerable<AttachedLinkUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<AttachedLinkUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: AttachedLinkCreateManyNgoInputEnvelope
    set?: Enumerable<AttachedLinkWhereUniqueInput>
    disconnect?: Enumerable<AttachedLinkWhereUniqueInput>
    delete?: Enumerable<AttachedLinkWhereUniqueInput>
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
    update?: Enumerable<AttachedLinkUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<AttachedLinkUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<AttachedLinkScalarWhereInput>
  }

  export type CampaignUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<CampaignCreateWithoutNgoInput>, Enumerable<CampaignUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CampaignCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<CampaignUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: CampaignCreateManyNgoInputEnvelope
    set?: Enumerable<CampaignWhereUniqueInput>
    disconnect?: Enumerable<CampaignWhereUniqueInput>
    delete?: Enumerable<CampaignWhereUniqueInput>
    connect?: Enumerable<CampaignWhereUniqueInput>
    update?: Enumerable<CampaignUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<CampaignUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<CampaignScalarWhereInput>
  }

  export type CommentNgoUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutNgoInput>, Enumerable<CommentNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<CommentNgoUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: CommentNgoCreateManyNgoInputEnvelope
    set?: Enumerable<CommentNgoWhereUniqueInput>
    disconnect?: Enumerable<CommentNgoWhereUniqueInput>
    delete?: Enumerable<CommentNgoWhereUniqueInput>
    connect?: Enumerable<CommentNgoWhereUniqueInput>
    update?: Enumerable<CommentNgoUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<CommentNgoUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<CommentNgoScalarWhereInput>
  }

  export type FollowingUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutNgoInput>, Enumerable<FollowingUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<FollowingUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: FollowingCreateManyNgoInputEnvelope
    set?: Enumerable<FollowingWhereUniqueInput>
    disconnect?: Enumerable<FollowingWhereUniqueInput>
    delete?: Enumerable<FollowingWhereUniqueInput>
    connect?: Enumerable<FollowingWhereUniqueInput>
    update?: Enumerable<FollowingUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<FollowingUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<FollowingScalarWhereInput>
  }

  export type NgoAddressUncheckedUpdateOneWithoutNgoNestedInput = {
    create?: XOR<NgoAddressCreateWithoutNgoInput, NgoAddressUncheckedCreateWithoutNgoInput>
    connectOrCreate?: NgoAddressCreateOrConnectWithoutNgoInput
    upsert?: NgoAddressUpsertWithoutNgoInput
    disconnect?: boolean
    delete?: boolean
    connect?: NgoAddressWhereUniqueInput
    update?: XOR<NgoAddressUpdateWithoutNgoInput, NgoAddressUncheckedUpdateWithoutNgoInput>
  }

  export type NgoCausesUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<NgoCausesCreateWithoutNgoInput>, Enumerable<NgoCausesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoCausesCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<NgoCausesUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: NgoCausesCreateManyNgoInputEnvelope
    set?: Enumerable<NgoCausesWhereUniqueInput>
    disconnect?: Enumerable<NgoCausesWhereUniqueInput>
    delete?: Enumerable<NgoCausesWhereUniqueInput>
    connect?: Enumerable<NgoCausesWhereUniqueInput>
    update?: Enumerable<NgoCausesUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<NgoCausesUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<NgoCausesScalarWhereInput>
  }

  export type NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<NgoPhoneCreateWithoutNgoInput>, Enumerable<NgoPhoneUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<NgoPhoneCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<NgoPhoneUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: NgoPhoneCreateManyNgoInputEnvelope
    set?: Enumerable<NgoPhoneWhereUniqueInput>
    disconnect?: Enumerable<NgoPhoneWhereUniqueInput>
    delete?: Enumerable<NgoPhoneWhereUniqueInput>
    connect?: Enumerable<NgoPhoneWhereUniqueInput>
    update?: Enumerable<NgoPhoneUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<NgoPhoneUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<NgoPhoneScalarWhereInput>
  }

  export type PostNgoUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutNgoInput>, Enumerable<PostNgoUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<PostNgoUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: PostNgoCreateManyNgoInputEnvelope
    set?: Enumerable<PostNgoWhereUniqueInput>
    disconnect?: Enumerable<PostNgoWhereUniqueInput>
    delete?: Enumerable<PostNgoWhereUniqueInput>
    connect?: Enumerable<PostNgoWhereUniqueInput>
    update?: Enumerable<PostNgoUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<PostNgoUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<PostNgoScalarWhereInput>
  }

  export type CommentLikesUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutNgoInput>, Enumerable<CommentLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<CommentLikesUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: CommentLikesCreateManyNgoInputEnvelope
    set?: Enumerable<CommentLikesWhereUniqueInput>
    disconnect?: Enumerable<CommentLikesWhereUniqueInput>
    delete?: Enumerable<CommentLikesWhereUniqueInput>
    connect?: Enumerable<CommentLikesWhereUniqueInput>
    update?: Enumerable<CommentLikesUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<CommentLikesUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<CommentLikesScalarWhereInput>
  }

  export type PostLikesUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutNgoInput>, Enumerable<PostLikesUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<PostLikesUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: PostLikesCreateManyNgoInputEnvelope
    set?: Enumerable<PostLikesWhereUniqueInput>
    disconnect?: Enumerable<PostLikesWhereUniqueInput>
    delete?: Enumerable<PostLikesWhereUniqueInput>
    connect?: Enumerable<PostLikesWhereUniqueInput>
    update?: Enumerable<PostLikesUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<PostLikesUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<PostLikesScalarWhereInput>
  }

  export type AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutNgoInput>, Enumerable<AttachedLinkUncheckedCreateWithoutNgoInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutNgoInput>
    upsert?: Enumerable<AttachedLinkUpsertWithWhereUniqueWithoutNgoInput>
    createMany?: AttachedLinkCreateManyNgoInputEnvelope
    set?: Enumerable<AttachedLinkWhereUniqueInput>
    disconnect?: Enumerable<AttachedLinkWhereUniqueInput>
    delete?: Enumerable<AttachedLinkWhereUniqueInput>
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
    update?: Enumerable<AttachedLinkUpdateWithWhereUniqueWithoutNgoInput>
    updateMany?: Enumerable<AttachedLinkUpdateManyWithWhereWithoutNgoInput>
    deleteMany?: Enumerable<AttachedLinkScalarWhereInput>
  }

  export type AddressCreateNestedOneWithoutNgo_addressInput = {
    create?: XOR<AddressCreateWithoutNgo_addressInput, AddressUncheckedCreateWithoutNgo_addressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutNgo_addressInput
    connect?: AddressWhereUniqueInput
  }

  export type NGOCreateNestedOneWithoutNgo_addressInput = {
    create?: XOR<NGOCreateWithoutNgo_addressInput, NGOUncheckedCreateWithoutNgo_addressInput>
    connectOrCreate?: NGOCreateOrConnectWithoutNgo_addressInput
    connect?: NGOWhereUniqueInput
  }

  export type AddressUpdateOneRequiredWithoutNgo_addressNestedInput = {
    create?: XOR<AddressCreateWithoutNgo_addressInput, AddressUncheckedCreateWithoutNgo_addressInput>
    connectOrCreate?: AddressCreateOrConnectWithoutNgo_addressInput
    upsert?: AddressUpsertWithoutNgo_addressInput
    connect?: AddressWhereUniqueInput
    update?: XOR<AddressUpdateWithoutNgo_addressInput, AddressUncheckedUpdateWithoutNgo_addressInput>
  }

  export type NGOUpdateOneRequiredWithoutNgo_addressNestedInput = {
    create?: XOR<NGOCreateWithoutNgo_addressInput, NGOUncheckedCreateWithoutNgo_addressInput>
    connectOrCreate?: NGOCreateOrConnectWithoutNgo_addressInput
    upsert?: NGOUpsertWithoutNgo_addressInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutNgo_addressInput, NGOUncheckedUpdateWithoutNgo_addressInput>
  }

  export type CausesCreateNestedOneWithoutNgo_causesInput = {
    create?: XOR<CausesCreateWithoutNgo_causesInput, CausesUncheckedCreateWithoutNgo_causesInput>
    connectOrCreate?: CausesCreateOrConnectWithoutNgo_causesInput
    connect?: CausesWhereUniqueInput
  }

  export type NGOCreateNestedOneWithoutNgo_causesInput = {
    create?: XOR<NGOCreateWithoutNgo_causesInput, NGOUncheckedCreateWithoutNgo_causesInput>
    connectOrCreate?: NGOCreateOrConnectWithoutNgo_causesInput
    connect?: NGOWhereUniqueInput
  }

  export type CausesUpdateOneRequiredWithoutNgo_causesNestedInput = {
    create?: XOR<CausesCreateWithoutNgo_causesInput, CausesUncheckedCreateWithoutNgo_causesInput>
    connectOrCreate?: CausesCreateOrConnectWithoutNgo_causesInput
    upsert?: CausesUpsertWithoutNgo_causesInput
    connect?: CausesWhereUniqueInput
    update?: XOR<CausesUpdateWithoutNgo_causesInput, CausesUncheckedUpdateWithoutNgo_causesInput>
  }

  export type NGOUpdateOneRequiredWithoutNgo_causesNestedInput = {
    create?: XOR<NGOCreateWithoutNgo_causesInput, NGOUncheckedCreateWithoutNgo_causesInput>
    connectOrCreate?: NGOCreateOrConnectWithoutNgo_causesInput
    upsert?: NGOUpsertWithoutNgo_causesInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutNgo_causesInput, NGOUncheckedUpdateWithoutNgo_causesInput>
  }

  export type NGOCreateNestedOneWithoutNgo_phoneInput = {
    create?: XOR<NGOCreateWithoutNgo_phoneInput, NGOUncheckedCreateWithoutNgo_phoneInput>
    connectOrCreate?: NGOCreateOrConnectWithoutNgo_phoneInput
    connect?: NGOWhereUniqueInput
  }

  export type PhoneCreateNestedOneWithoutNgo_phoneInput = {
    create?: XOR<PhoneCreateWithoutNgo_phoneInput, PhoneUncheckedCreateWithoutNgo_phoneInput>
    connectOrCreate?: PhoneCreateOrConnectWithoutNgo_phoneInput
    connect?: PhoneWhereUniqueInput
  }

  export type NGOUpdateOneRequiredWithoutNgo_phoneNestedInput = {
    create?: XOR<NGOCreateWithoutNgo_phoneInput, NGOUncheckedCreateWithoutNgo_phoneInput>
    connectOrCreate?: NGOCreateOrConnectWithoutNgo_phoneInput
    upsert?: NGOUpsertWithoutNgo_phoneInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutNgo_phoneInput, NGOUncheckedUpdateWithoutNgo_phoneInput>
  }

  export type PhoneUpdateOneRequiredWithoutNgo_phoneNestedInput = {
    create?: XOR<PhoneCreateWithoutNgo_phoneInput, PhoneUncheckedCreateWithoutNgo_phoneInput>
    connectOrCreate?: PhoneCreateOrConnectWithoutNgo_phoneInput
    upsert?: PhoneUpsertWithoutNgo_phoneInput
    connect?: PhoneWhereUniqueInput
    update?: XOR<PhoneUpdateWithoutNgo_phoneInput, PhoneUncheckedUpdateWithoutNgo_phoneInput>
  }

  export type PhoneCreateNestedOneWithoutUser_phoneInput = {
    create?: XOR<PhoneCreateWithoutUser_phoneInput, PhoneUncheckedCreateWithoutUser_phoneInput>
    connectOrCreate?: PhoneCreateOrConnectWithoutUser_phoneInput
    connect?: PhoneWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_phoneInput = {
    create?: XOR<UserCreateWithoutUser_phoneInput, UserUncheckedCreateWithoutUser_phoneInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_phoneInput
    connect?: UserWhereUniqueInput
  }

  export type PhoneUpdateOneRequiredWithoutUser_phoneNestedInput = {
    create?: XOR<PhoneCreateWithoutUser_phoneInput, PhoneUncheckedCreateWithoutUser_phoneInput>
    connectOrCreate?: PhoneCreateOrConnectWithoutUser_phoneInput
    upsert?: PhoneUpsertWithoutUser_phoneInput
    connect?: PhoneWhereUniqueInput
    update?: XOR<PhoneUpdateWithoutUser_phoneInput, PhoneUncheckedUpdateWithoutUser_phoneInput>
  }

  export type UserUpdateOneRequiredWithoutUser_phoneNestedInput = {
    create?: XOR<UserCreateWithoutUser_phoneInput, UserUncheckedCreateWithoutUser_phoneInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_phoneInput
    upsert?: UserUpsertWithoutUser_phoneInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUser_phoneInput, UserUncheckedUpdateWithoutUser_phoneInput>
  }

  export type NGOCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<NGOCreateWithoutTypeInput>, Enumerable<NGOUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<NGOCreateOrConnectWithoutTypeInput>
    createMany?: NGOCreateManyTypeInputEnvelope
    connect?: Enumerable<NGOWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<UserCreateWithoutTypeInput>, Enumerable<UserUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTypeInput>
    createMany?: UserCreateManyTypeInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type NGOUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<NGOCreateWithoutTypeInput>, Enumerable<NGOUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<NGOCreateOrConnectWithoutTypeInput>
    createMany?: NGOCreateManyTypeInputEnvelope
    connect?: Enumerable<NGOWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<UserCreateWithoutTypeInput>, Enumerable<UserUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTypeInput>
    createMany?: UserCreateManyTypeInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type NGOUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<NGOCreateWithoutTypeInput>, Enumerable<NGOUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<NGOCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<NGOUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: NGOCreateManyTypeInputEnvelope
    set?: Enumerable<NGOWhereUniqueInput>
    disconnect?: Enumerable<NGOWhereUniqueInput>
    delete?: Enumerable<NGOWhereUniqueInput>
    connect?: Enumerable<NGOWhereUniqueInput>
    update?: Enumerable<NGOUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<NGOUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<NGOScalarWhereInput>
  }

  export type UserUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutTypeInput>, Enumerable<UserUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: UserCreateManyTypeInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NGOUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<NGOCreateWithoutTypeInput>, Enumerable<NGOUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<NGOCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<NGOUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: NGOCreateManyTypeInputEnvelope
    set?: Enumerable<NGOWhereUniqueInput>
    disconnect?: Enumerable<NGOWhereUniqueInput>
    delete?: Enumerable<NGOWhereUniqueInput>
    connect?: Enumerable<NGOWhereUniqueInput>
    update?: Enumerable<NGOUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<NGOUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<NGOScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutTypeInput>, Enumerable<UserUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: UserCreateManyTypeInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type PostNgoCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutPostInput>, Enumerable<PostNgoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutPostInput>
    createMany?: PostNgoCreateManyPostInputEnvelope
    connect?: Enumerable<PostNgoWhereUniqueInput>
  }

  export type PostPhotoCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostPhotoCreateWithoutPostInput>, Enumerable<PostPhotoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostPhotoCreateOrConnectWithoutPostInput>
    createMany?: PostPhotoCreateManyPostInputEnvelope
    connect?: Enumerable<PostPhotoWhereUniqueInput>
  }

  export type PostUserCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutPostInput>, Enumerable<PostUserUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutPostInput>
    createMany?: PostUserCreateManyPostInputEnvelope
    connect?: Enumerable<PostUserWhereUniqueInput>
  }

  export type PostLikesCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutPostInput>, Enumerable<PostLikesUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutPostInput>
    createMany?: PostLikesCreateManyPostInputEnvelope
    connect?: Enumerable<PostLikesWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type PostNgoUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutPostInput>, Enumerable<PostNgoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutPostInput>
    createMany?: PostNgoCreateManyPostInputEnvelope
    connect?: Enumerable<PostNgoWhereUniqueInput>
  }

  export type PostPhotoUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostPhotoCreateWithoutPostInput>, Enumerable<PostPhotoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostPhotoCreateOrConnectWithoutPostInput>
    createMany?: PostPhotoCreateManyPostInputEnvelope
    connect?: Enumerable<PostPhotoWhereUniqueInput>
  }

  export type PostUserUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutPostInput>, Enumerable<PostUserUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutPostInput>
    createMany?: PostUserCreateManyPostInputEnvelope
    connect?: Enumerable<PostUserWhereUniqueInput>
  }

  export type PostLikesUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutPostInput>, Enumerable<PostLikesUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutPostInput>
    createMany?: PostLikesCreateManyPostInputEnvelope
    connect?: Enumerable<PostLikesWhereUniqueInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type PostNgoUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutPostInput>, Enumerable<PostNgoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostNgoUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostNgoCreateManyPostInputEnvelope
    set?: Enumerable<PostNgoWhereUniqueInput>
    disconnect?: Enumerable<PostNgoWhereUniqueInput>
    delete?: Enumerable<PostNgoWhereUniqueInput>
    connect?: Enumerable<PostNgoWhereUniqueInput>
    update?: Enumerable<PostNgoUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostNgoUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostNgoScalarWhereInput>
  }

  export type PostPhotoUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostPhotoCreateWithoutPostInput>, Enumerable<PostPhotoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostPhotoCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostPhotoUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostPhotoCreateManyPostInputEnvelope
    set?: Enumerable<PostPhotoWhereUniqueInput>
    disconnect?: Enumerable<PostPhotoWhereUniqueInput>
    delete?: Enumerable<PostPhotoWhereUniqueInput>
    connect?: Enumerable<PostPhotoWhereUniqueInput>
    update?: Enumerable<PostPhotoUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostPhotoUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostPhotoScalarWhereInput>
  }

  export type PostUserUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutPostInput>, Enumerable<PostUserUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostUserUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostUserCreateManyPostInputEnvelope
    set?: Enumerable<PostUserWhereUniqueInput>
    disconnect?: Enumerable<PostUserWhereUniqueInput>
    delete?: Enumerable<PostUserWhereUniqueInput>
    connect?: Enumerable<PostUserWhereUniqueInput>
    update?: Enumerable<PostUserUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostUserUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostUserScalarWhereInput>
  }

  export type PostLikesUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutPostInput>, Enumerable<PostLikesUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostLikesUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostLikesCreateManyPostInputEnvelope
    set?: Enumerable<PostLikesWhereUniqueInput>
    disconnect?: Enumerable<PostLikesWhereUniqueInput>
    delete?: Enumerable<PostLikesWhereUniqueInput>
    connect?: Enumerable<PostLikesWhereUniqueInput>
    update?: Enumerable<PostLikesUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostLikesUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostLikesScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutPostInput>, Enumerable<CommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: CommentCreateManyPostInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type PostNgoUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostNgoCreateWithoutPostInput>, Enumerable<PostNgoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostNgoCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostNgoUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostNgoCreateManyPostInputEnvelope
    set?: Enumerable<PostNgoWhereUniqueInput>
    disconnect?: Enumerable<PostNgoWhereUniqueInput>
    delete?: Enumerable<PostNgoWhereUniqueInput>
    connect?: Enumerable<PostNgoWhereUniqueInput>
    update?: Enumerable<PostNgoUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostNgoUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostNgoScalarWhereInput>
  }

  export type PostPhotoUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostPhotoCreateWithoutPostInput>, Enumerable<PostPhotoUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostPhotoCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostPhotoUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostPhotoCreateManyPostInputEnvelope
    set?: Enumerable<PostPhotoWhereUniqueInput>
    disconnect?: Enumerable<PostPhotoWhereUniqueInput>
    delete?: Enumerable<PostPhotoWhereUniqueInput>
    connect?: Enumerable<PostPhotoWhereUniqueInput>
    update?: Enumerable<PostPhotoUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostPhotoUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostPhotoScalarWhereInput>
  }

  export type PostUserUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostUserCreateWithoutPostInput>, Enumerable<PostUserUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostUserCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostUserUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostUserCreateManyPostInputEnvelope
    set?: Enumerable<PostUserWhereUniqueInput>
    disconnect?: Enumerable<PostUserWhereUniqueInput>
    delete?: Enumerable<PostUserWhereUniqueInput>
    connect?: Enumerable<PostUserWhereUniqueInput>
    update?: Enumerable<PostUserUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostUserUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostUserScalarWhereInput>
  }

  export type PostLikesUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostLikesCreateWithoutPostInput>, Enumerable<PostLikesUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikesCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostLikesUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostLikesCreateManyPostInputEnvelope
    set?: Enumerable<PostLikesWhereUniqueInput>
    disconnect?: Enumerable<PostLikesWhereUniqueInput>
    delete?: Enumerable<PostLikesWhereUniqueInput>
    connect?: Enumerable<PostLikesWhereUniqueInput>
    update?: Enumerable<PostLikesUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostLikesUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostLikesScalarWhereInput>
  }

  export type PostCreateNestedOneWithoutPost_photoInput = {
    create?: XOR<PostCreateWithoutPost_photoInput, PostUncheckedCreateWithoutPost_photoInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_photoInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPost_photoNestedInput = {
    create?: XOR<PostCreateWithoutPost_photoInput, PostUncheckedCreateWithoutPost_photoInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_photoInput
    upsert?: PostUpsertWithoutPost_photoInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutPost_photoInput, PostUncheckedUpdateWithoutPost_photoInput>
  }

  export type NGOCreateNestedOneWithoutPost_ngoInput = {
    create?: XOR<NGOCreateWithoutPost_ngoInput, NGOUncheckedCreateWithoutPost_ngoInput>
    connectOrCreate?: NGOCreateOrConnectWithoutPost_ngoInput
    connect?: NGOWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPost_ngoInput = {
    create?: XOR<PostCreateWithoutPost_ngoInput, PostUncheckedCreateWithoutPost_ngoInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_ngoInput
    connect?: PostWhereUniqueInput
  }

  export type NGOUpdateOneRequiredWithoutPost_ngoNestedInput = {
    create?: XOR<NGOCreateWithoutPost_ngoInput, NGOUncheckedCreateWithoutPost_ngoInput>
    connectOrCreate?: NGOCreateOrConnectWithoutPost_ngoInput
    upsert?: NGOUpsertWithoutPost_ngoInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutPost_ngoInput, NGOUncheckedUpdateWithoutPost_ngoInput>
  }

  export type PostUpdateOneRequiredWithoutPost_ngoNestedInput = {
    create?: XOR<PostCreateWithoutPost_ngoInput, PostUncheckedCreateWithoutPost_ngoInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_ngoInput
    upsert?: PostUpsertWithoutPost_ngoInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutPost_ngoInput, PostUncheckedUpdateWithoutPost_ngoInput>
  }

  export type PostCreateNestedOneWithoutPost_userInput = {
    create?: XOR<PostCreateWithoutPost_userInput, PostUncheckedCreateWithoutPost_userInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_userInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPost_userInput = {
    create?: XOR<UserCreateWithoutPost_userInput, UserUncheckedCreateWithoutPost_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutPost_userInput
    connect?: UserWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPost_userNestedInput = {
    create?: XOR<PostCreateWithoutPost_userInput, PostUncheckedCreateWithoutPost_userInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_userInput
    upsert?: PostUpsertWithoutPost_userInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutPost_userInput, PostUncheckedUpdateWithoutPost_userInput>
  }

  export type UserUpdateOneRequiredWithoutPost_userNestedInput = {
    create?: XOR<UserCreateWithoutPost_userInput, UserUncheckedCreateWithoutPost_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutPost_userInput
    upsert?: UserUpsertWithoutPost_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPost_userInput, UserUncheckedUpdateWithoutPost_userInput>
  }

  export type PostCreateNestedOneWithoutCommentInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    connect?: PostWhereUniqueInput
  }

  export type CommentNgoCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutCommentInput>, Enumerable<CommentNgoUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutCommentInput>
    createMany?: CommentNgoCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentNgoWhereUniqueInput>
  }

  export type CommentUserCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutCommentInput>, Enumerable<CommentUserUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutCommentInput>
    createMany?: CommentUserCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentUserWhereUniqueInput>
  }

  export type CommentLikesCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutCommentInput>, Enumerable<CommentLikesUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutCommentInput>
    createMany?: CommentLikesCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentLikesWhereUniqueInput>
  }

  export type CommentNgoUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutCommentInput>, Enumerable<CommentNgoUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutCommentInput>
    createMany?: CommentNgoCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentNgoWhereUniqueInput>
  }

  export type CommentUserUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutCommentInput>, Enumerable<CommentUserUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutCommentInput>
    createMany?: CommentUserCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentUserWhereUniqueInput>
  }

  export type CommentLikesUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutCommentInput>, Enumerable<CommentLikesUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutCommentInput>
    createMany?: CommentLikesCreateManyCommentInputEnvelope
    connect?: Enumerable<CommentLikesWhereUniqueInput>
  }

  export type PostUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    upsert?: PostUpsertWithoutCommentInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
  }

  export type CommentNgoUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutCommentInput>, Enumerable<CommentNgoUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentNgoUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentNgoCreateManyCommentInputEnvelope
    set?: Enumerable<CommentNgoWhereUniqueInput>
    disconnect?: Enumerable<CommentNgoWhereUniqueInput>
    delete?: Enumerable<CommentNgoWhereUniqueInput>
    connect?: Enumerable<CommentNgoWhereUniqueInput>
    update?: Enumerable<CommentNgoUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentNgoUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentNgoScalarWhereInput>
  }

  export type CommentUserUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutCommentInput>, Enumerable<CommentUserUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentUserUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentUserCreateManyCommentInputEnvelope
    set?: Enumerable<CommentUserWhereUniqueInput>
    disconnect?: Enumerable<CommentUserWhereUniqueInput>
    delete?: Enumerable<CommentUserWhereUniqueInput>
    connect?: Enumerable<CommentUserWhereUniqueInput>
    update?: Enumerable<CommentUserUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentUserUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentUserScalarWhereInput>
  }

  export type CommentLikesUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutCommentInput>, Enumerable<CommentLikesUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentLikesUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentLikesCreateManyCommentInputEnvelope
    set?: Enumerable<CommentLikesWhereUniqueInput>
    disconnect?: Enumerable<CommentLikesWhereUniqueInput>
    delete?: Enumerable<CommentLikesWhereUniqueInput>
    connect?: Enumerable<CommentLikesWhereUniqueInput>
    update?: Enumerable<CommentLikesUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentLikesUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentLikesScalarWhereInput>
  }

  export type CommentNgoUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<CommentNgoCreateWithoutCommentInput>, Enumerable<CommentNgoUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentNgoCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentNgoUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentNgoCreateManyCommentInputEnvelope
    set?: Enumerable<CommentNgoWhereUniqueInput>
    disconnect?: Enumerable<CommentNgoWhereUniqueInput>
    delete?: Enumerable<CommentNgoWhereUniqueInput>
    connect?: Enumerable<CommentNgoWhereUniqueInput>
    update?: Enumerable<CommentNgoUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentNgoUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentNgoScalarWhereInput>
  }

  export type CommentUserUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<CommentUserCreateWithoutCommentInput>, Enumerable<CommentUserUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentUserCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentUserUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentUserCreateManyCommentInputEnvelope
    set?: Enumerable<CommentUserWhereUniqueInput>
    disconnect?: Enumerable<CommentUserWhereUniqueInput>
    delete?: Enumerable<CommentUserWhereUniqueInput>
    connect?: Enumerable<CommentUserWhereUniqueInput>
    update?: Enumerable<CommentUserUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentUserUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentUserScalarWhereInput>
  }

  export type CommentLikesUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<CommentLikesCreateWithoutCommentInput>, Enumerable<CommentLikesUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<CommentLikesCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<CommentLikesUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: CommentLikesCreateManyCommentInputEnvelope
    set?: Enumerable<CommentLikesWhereUniqueInput>
    disconnect?: Enumerable<CommentLikesWhereUniqueInput>
    delete?: Enumerable<CommentLikesWhereUniqueInput>
    connect?: Enumerable<CommentLikesWhereUniqueInput>
    update?: Enumerable<CommentLikesUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<CommentLikesUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<CommentLikesScalarWhereInput>
  }

  export type CommentCreateNestedOneWithoutComment_userInput = {
    create?: XOR<CommentCreateWithoutComment_userInput, CommentUncheckedCreateWithoutComment_userInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_userInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComment_userInput = {
    create?: XOR<UserCreateWithoutComment_userInput, UserUncheckedCreateWithoutComment_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutComment_userInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutComment_userNestedInput = {
    create?: XOR<CommentCreateWithoutComment_userInput, CommentUncheckedCreateWithoutComment_userInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_userInput
    upsert?: CommentUpsertWithoutComment_userInput
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutComment_userInput, CommentUncheckedUpdateWithoutComment_userInput>
  }

  export type UserUpdateOneRequiredWithoutComment_userNestedInput = {
    create?: XOR<UserCreateWithoutComment_userInput, UserUncheckedCreateWithoutComment_userInput>
    connectOrCreate?: UserCreateOrConnectWithoutComment_userInput
    upsert?: UserUpsertWithoutComment_userInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutComment_userInput, UserUncheckedUpdateWithoutComment_userInput>
  }

  export type CommentCreateNestedOneWithoutComment_ngoInput = {
    create?: XOR<CommentCreateWithoutComment_ngoInput, CommentUncheckedCreateWithoutComment_ngoInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_ngoInput
    connect?: CommentWhereUniqueInput
  }

  export type NGOCreateNestedOneWithoutComment_ngoInput = {
    create?: XOR<NGOCreateWithoutComment_ngoInput, NGOUncheckedCreateWithoutComment_ngoInput>
    connectOrCreate?: NGOCreateOrConnectWithoutComment_ngoInput
    connect?: NGOWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutComment_ngoNestedInput = {
    create?: XOR<CommentCreateWithoutComment_ngoInput, CommentUncheckedCreateWithoutComment_ngoInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_ngoInput
    upsert?: CommentUpsertWithoutComment_ngoInput
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutComment_ngoInput, CommentUncheckedUpdateWithoutComment_ngoInput>
  }

  export type NGOUpdateOneRequiredWithoutComment_ngoNestedInput = {
    create?: XOR<NGOCreateWithoutComment_ngoInput, NGOUncheckedCreateWithoutComment_ngoInput>
    connectOrCreate?: NGOCreateOrConnectWithoutComment_ngoInput
    upsert?: NGOUpsertWithoutComment_ngoInput
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutComment_ngoInput, NGOUncheckedUpdateWithoutComment_ngoInput>
  }

  export type NGOCreateNestedOneWithoutComment_likesInput = {
    create?: XOR<NGOCreateWithoutComment_likesInput, NGOUncheckedCreateWithoutComment_likesInput>
    connectOrCreate?: NGOCreateOrConnectWithoutComment_likesInput
    connect?: NGOWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComment_likesInput = {
    create?: XOR<UserCreateWithoutComment_likesInput, UserUncheckedCreateWithoutComment_likesInput>
    connectOrCreate?: UserCreateOrConnectWithoutComment_likesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutComment_likesInput = {
    create?: XOR<CommentCreateWithoutComment_likesInput, CommentUncheckedCreateWithoutComment_likesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_likesInput
    connect?: CommentWhereUniqueInput
  }

  export type NGOUpdateOneWithoutComment_likesNestedInput = {
    create?: XOR<NGOCreateWithoutComment_likesInput, NGOUncheckedCreateWithoutComment_likesInput>
    connectOrCreate?: NGOCreateOrConnectWithoutComment_likesInput
    upsert?: NGOUpsertWithoutComment_likesInput
    disconnect?: boolean
    delete?: boolean
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutComment_likesInput, NGOUncheckedUpdateWithoutComment_likesInput>
  }

  export type UserUpdateOneWithoutComment_likesNestedInput = {
    create?: XOR<UserCreateWithoutComment_likesInput, UserUncheckedCreateWithoutComment_likesInput>
    connectOrCreate?: UserCreateOrConnectWithoutComment_likesInput
    upsert?: UserUpsertWithoutComment_likesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutComment_likesInput, UserUncheckedUpdateWithoutComment_likesInput>
  }

  export type CommentUpdateOneRequiredWithoutComment_likesNestedInput = {
    create?: XOR<CommentCreateWithoutComment_likesInput, CommentUncheckedCreateWithoutComment_likesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_likesInput
    upsert?: CommentUpsertWithoutComment_likesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutComment_likesInput, CommentUncheckedUpdateWithoutComment_likesInput>
  }

  export type NGOCreateNestedOneWithoutPost_likesInput = {
    create?: XOR<NGOCreateWithoutPost_likesInput, NGOUncheckedCreateWithoutPost_likesInput>
    connectOrCreate?: NGOCreateOrConnectWithoutPost_likesInput
    connect?: NGOWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPost_likesInput = {
    create?: XOR<UserCreateWithoutPost_likesInput, UserUncheckedCreateWithoutPost_likesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPost_likesInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPost_likesInput = {
    create?: XOR<PostCreateWithoutPost_likesInput, PostUncheckedCreateWithoutPost_likesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_likesInput
    connect?: PostWhereUniqueInput
  }

  export type NGOUpdateOneWithoutPost_likesNestedInput = {
    create?: XOR<NGOCreateWithoutPost_likesInput, NGOUncheckedCreateWithoutPost_likesInput>
    connectOrCreate?: NGOCreateOrConnectWithoutPost_likesInput
    upsert?: NGOUpsertWithoutPost_likesInput
    disconnect?: boolean
    delete?: boolean
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutPost_likesInput, NGOUncheckedUpdateWithoutPost_likesInput>
  }

  export type UserUpdateOneWithoutPost_likesNestedInput = {
    create?: XOR<UserCreateWithoutPost_likesInput, UserUncheckedCreateWithoutPost_likesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPost_likesInput
    upsert?: UserUpsertWithoutPost_likesInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPost_likesInput, UserUncheckedUpdateWithoutPost_likesInput>
  }

  export type PostUpdateOneRequiredWithoutPost_likesNestedInput = {
    create?: XOR<PostCreateWithoutPost_likesInput, PostUncheckedCreateWithoutPost_likesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPost_likesInput
    upsert?: PostUpsertWithoutPost_likesInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutPost_likesInput, PostUncheckedUpdateWithoutPost_likesInput>
  }

  export type SourceCreateNestedOneWithoutAttached_linkInput = {
    create?: XOR<SourceCreateWithoutAttached_linkInput, SourceUncheckedCreateWithoutAttached_linkInput>
    connectOrCreate?: SourceCreateOrConnectWithoutAttached_linkInput
    connect?: SourceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAttached_linkInput = {
    create?: XOR<UserCreateWithoutAttached_linkInput, UserUncheckedCreateWithoutAttached_linkInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttached_linkInput
    connect?: UserWhereUniqueInput
  }

  export type NGOCreateNestedOneWithoutAttached_linkInput = {
    create?: XOR<NGOCreateWithoutAttached_linkInput, NGOUncheckedCreateWithoutAttached_linkInput>
    connectOrCreate?: NGOCreateOrConnectWithoutAttached_linkInput
    connect?: NGOWhereUniqueInput
  }

  export type SourceUpdateOneRequiredWithoutAttached_linkNestedInput = {
    create?: XOR<SourceCreateWithoutAttached_linkInput, SourceUncheckedCreateWithoutAttached_linkInput>
    connectOrCreate?: SourceCreateOrConnectWithoutAttached_linkInput
    upsert?: SourceUpsertWithoutAttached_linkInput
    connect?: SourceWhereUniqueInput
    update?: XOR<SourceUpdateWithoutAttached_linkInput, SourceUncheckedUpdateWithoutAttached_linkInput>
  }

  export type UserUpdateOneWithoutAttached_linkNestedInput = {
    create?: XOR<UserCreateWithoutAttached_linkInput, UserUncheckedCreateWithoutAttached_linkInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttached_linkInput
    upsert?: UserUpsertWithoutAttached_linkInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAttached_linkInput, UserUncheckedUpdateWithoutAttached_linkInput>
  }

  export type NGOUpdateOneWithoutAttached_linkNestedInput = {
    create?: XOR<NGOCreateWithoutAttached_linkInput, NGOUncheckedCreateWithoutAttached_linkInput>
    connectOrCreate?: NGOCreateOrConnectWithoutAttached_linkInput
    upsert?: NGOUpsertWithoutAttached_linkInput
    disconnect?: boolean
    delete?: boolean
    connect?: NGOWhereUniqueInput
    update?: XOR<NGOUpdateWithoutAttached_linkInput, NGOUncheckedUpdateWithoutAttached_linkInput>
  }

  export type AttachedLinkCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutSourceInput>, Enumerable<AttachedLinkUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutSourceInput>
    createMany?: AttachedLinkCreateManySourceInputEnvelope
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
  }

  export type AttachedLinkUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutSourceInput>, Enumerable<AttachedLinkUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutSourceInput>
    createMany?: AttachedLinkCreateManySourceInputEnvelope
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
  }

  export type AttachedLinkUpdateManyWithoutSourceNestedInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutSourceInput>, Enumerable<AttachedLinkUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<AttachedLinkUpsertWithWhereUniqueWithoutSourceInput>
    createMany?: AttachedLinkCreateManySourceInputEnvelope
    set?: Enumerable<AttachedLinkWhereUniqueInput>
    disconnect?: Enumerable<AttachedLinkWhereUniqueInput>
    delete?: Enumerable<AttachedLinkWhereUniqueInput>
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
    update?: Enumerable<AttachedLinkUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<AttachedLinkUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<AttachedLinkScalarWhereInput>
  }

  export type AttachedLinkUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<Enumerable<AttachedLinkCreateWithoutSourceInput>, Enumerable<AttachedLinkUncheckedCreateWithoutSourceInput>>
    connectOrCreate?: Enumerable<AttachedLinkCreateOrConnectWithoutSourceInput>
    upsert?: Enumerable<AttachedLinkUpsertWithWhereUniqueWithoutSourceInput>
    createMany?: AttachedLinkCreateManySourceInputEnvelope
    set?: Enumerable<AttachedLinkWhereUniqueInput>
    disconnect?: Enumerable<AttachedLinkWhereUniqueInput>
    delete?: Enumerable<AttachedLinkWhereUniqueInput>
    connect?: Enumerable<AttachedLinkWhereUniqueInput>
    update?: Enumerable<AttachedLinkUpdateWithWhereUniqueWithoutSourceInput>
    updateMany?: Enumerable<AttachedLinkUpdateManyWithWhereWithoutSourceInput>
    deleteMany?: Enumerable<AttachedLinkScalarWhereInput>
  }

  export type CampaignParticipantsCreateNestedManyWithoutStatusInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutStatusInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutStatusInput>
    createMany?: CampaignParticipantsCreateManyStatusInputEnvelope
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
  }

  export type FollowingCreateNestedManyWithoutStatusInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutStatusInput>, Enumerable<FollowingUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutStatusInput>
    createMany?: FollowingCreateManyStatusInputEnvelope
    connect?: Enumerable<FollowingWhereUniqueInput>
  }

  export type CampaignParticipantsUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutStatusInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutStatusInput>
    createMany?: CampaignParticipantsCreateManyStatusInputEnvelope
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
  }

  export type FollowingUncheckedCreateNestedManyWithoutStatusInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutStatusInput>, Enumerable<FollowingUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutStatusInput>
    createMany?: FollowingCreateManyStatusInputEnvelope
    connect?: Enumerable<FollowingWhereUniqueInput>
  }

  export type CampaignParticipantsUpdateManyWithoutStatusNestedInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutStatusInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutStatusInput>
    upsert?: Enumerable<CampaignParticipantsUpsertWithWhereUniqueWithoutStatusInput>
    createMany?: CampaignParticipantsCreateManyStatusInputEnvelope
    set?: Enumerable<CampaignParticipantsWhereUniqueInput>
    disconnect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    delete?: Enumerable<CampaignParticipantsWhereUniqueInput>
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    update?: Enumerable<CampaignParticipantsUpdateWithWhereUniqueWithoutStatusInput>
    updateMany?: Enumerable<CampaignParticipantsUpdateManyWithWhereWithoutStatusInput>
    deleteMany?: Enumerable<CampaignParticipantsScalarWhereInput>
  }

  export type FollowingUpdateManyWithoutStatusNestedInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutStatusInput>, Enumerable<FollowingUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutStatusInput>
    upsert?: Enumerable<FollowingUpsertWithWhereUniqueWithoutStatusInput>
    createMany?: FollowingCreateManyStatusInputEnvelope
    set?: Enumerable<FollowingWhereUniqueInput>
    disconnect?: Enumerable<FollowingWhereUniqueInput>
    delete?: Enumerable<FollowingWhereUniqueInput>
    connect?: Enumerable<FollowingWhereUniqueInput>
    update?: Enumerable<FollowingUpdateWithWhereUniqueWithoutStatusInput>
    updateMany?: Enumerable<FollowingUpdateManyWithWhereWithoutStatusInput>
    deleteMany?: Enumerable<FollowingScalarWhereInput>
  }

  export type CampaignParticipantsUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<Enumerable<CampaignParticipantsCreateWithoutStatusInput>, Enumerable<CampaignParticipantsUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<CampaignParticipantsCreateOrConnectWithoutStatusInput>
    upsert?: Enumerable<CampaignParticipantsUpsertWithWhereUniqueWithoutStatusInput>
    createMany?: CampaignParticipantsCreateManyStatusInputEnvelope
    set?: Enumerable<CampaignParticipantsWhereUniqueInput>
    disconnect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    delete?: Enumerable<CampaignParticipantsWhereUniqueInput>
    connect?: Enumerable<CampaignParticipantsWhereUniqueInput>
    update?: Enumerable<CampaignParticipantsUpdateWithWhereUniqueWithoutStatusInput>
    updateMany?: Enumerable<CampaignParticipantsUpdateManyWithWhereWithoutStatusInput>
    deleteMany?: Enumerable<CampaignParticipantsScalarWhereInput>
  }

  export type FollowingUncheckedUpdateManyWithoutStatusNestedInput = {
    create?: XOR<Enumerable<FollowingCreateWithoutStatusInput>, Enumerable<FollowingUncheckedCreateWithoutStatusInput>>
    connectOrCreate?: Enumerable<FollowingCreateOrConnectWithoutStatusInput>
    upsert?: Enumerable<FollowingUpsertWithWhereUniqueWithoutStatusInput>
    createMany?: FollowingCreateManyStatusInputEnvelope
    set?: Enumerable<FollowingWhereUniqueInput>
    disconnect?: Enumerable<FollowingWhereUniqueInput>
    delete?: Enumerable<FollowingWhereUniqueInput>
    connect?: Enumerable<FollowingWhereUniqueInput>
    update?: Enumerable<FollowingUpdateWithWhereUniqueWithoutStatusInput>
    updateMany?: Enumerable<FollowingUpdateManyWithWhereWithoutStatusInput>
    deleteMany?: Enumerable<FollowingScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type CampaignParticipantsCreateWithoutUserInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_participantsInput
    status: StatusCreateNestedOneWithoutCampaignParticipantsInput
  }

  export type CampaignParticipantsUncheckedCreateWithoutUserInput = {
    id?: string
    id_campaign: string
    id_status: string
  }

  export type CampaignParticipantsCreateOrConnectWithoutUserInput = {
    where: CampaignParticipantsWhereUniqueInput
    create: XOR<CampaignParticipantsCreateWithoutUserInput, CampaignParticipantsUncheckedCreateWithoutUserInput>
  }

  export type CampaignParticipantsCreateManyUserInputEnvelope = {
    data: Enumerable<CampaignParticipantsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommentUserCreateWithoutUserInput = {
    id?: string
    comment: CommentCreateNestedOneWithoutComment_userInput
  }

  export type CommentUserUncheckedCreateWithoutUserInput = {
    id?: string
    id_comment: string
  }

  export type CommentUserCreateOrConnectWithoutUserInput = {
    where: CommentUserWhereUniqueInput
    create: XOR<CommentUserCreateWithoutUserInput, CommentUserUncheckedCreateWithoutUserInput>
  }

  export type CommentUserCreateManyUserInputEnvelope = {
    data: Enumerable<CommentUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FollowingCreateWithoutUserInput = {
    id?: string
    status: StatusCreateNestedOneWithoutFollowingInput
    ngo: NGOCreateNestedOneWithoutFollowingInput
  }

  export type FollowingUncheckedCreateWithoutUserInput = {
    id?: string
    id_ngo: string
    id_status: string
  }

  export type FollowingCreateOrConnectWithoutUserInput = {
    where: FollowingWhereUniqueInput
    create: XOR<FollowingCreateWithoutUserInput, FollowingUncheckedCreateWithoutUserInput>
  }

  export type FollowingCreateManyUserInputEnvelope = {
    data: Enumerable<FollowingCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PostUserCreateWithoutUserInput = {
    id?: string
    post: PostCreateNestedOneWithoutPost_userInput
  }

  export type PostUserUncheckedCreateWithoutUserInput = {
    id?: string
    id_post: string
  }

  export type PostUserCreateOrConnectWithoutUserInput = {
    where: PostUserWhereUniqueInput
    create: XOR<PostUserCreateWithoutUserInput, PostUserUncheckedCreateWithoutUserInput>
  }

  export type PostUserCreateManyUserInputEnvelope = {
    data: Enumerable<PostUserCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type GenderCreateWithoutUserInput = {
    id?: string
    name: string
    abbreviation: string
  }

  export type GenderUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    abbreviation: string
  }

  export type GenderCreateOrConnectWithoutUserInput = {
    where: GenderWhereUniqueInput
    create: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
  }

  export type TypeCreateWithoutUserInput = {
    id?: string
    name: string
    ngo?: NGOCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    ngo?: NGOUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeCreateOrConnectWithoutUserInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutUserInput, TypeUncheckedCreateWithoutUserInput>
  }

  export type UserAddressCreateWithoutUserInput = {
    id?: string
    address: AddressCreateNestedOneWithoutUser_addressInput
  }

  export type UserAddressUncheckedCreateWithoutUserInput = {
    id?: string
    id_address: string
  }

  export type UserAddressCreateOrConnectWithoutUserInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserPhoneCreateWithoutUserInput = {
    id?: string
    phone: PhoneCreateNestedOneWithoutUser_phoneInput
  }

  export type UserPhoneUncheckedCreateWithoutUserInput = {
    id?: string
    id_phone: string
  }

  export type UserPhoneCreateOrConnectWithoutUserInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type CommentLikesCreateWithoutUserInput = {
    id?: string
    ngo?: NGOCreateNestedOneWithoutComment_likesInput
    comment: CommentCreateNestedOneWithoutComment_likesInput
  }

  export type CommentLikesUncheckedCreateWithoutUserInput = {
    id?: string
    id_comment: string
    id_ngo?: string | null
  }

  export type CommentLikesCreateOrConnectWithoutUserInput = {
    where: CommentLikesWhereUniqueInput
    create: XOR<CommentLikesCreateWithoutUserInput, CommentLikesUncheckedCreateWithoutUserInput>
  }

  export type CommentLikesCreateManyUserInputEnvelope = {
    data: Enumerable<CommentLikesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PostLikesCreateWithoutUserInput = {
    id?: string
    ngo?: NGOCreateNestedOneWithoutPost_likesInput
    post: PostCreateNestedOneWithoutPost_likesInput
  }

  export type PostLikesUncheckedCreateWithoutUserInput = {
    id?: string
    id_ngo?: string | null
    id_post: string
  }

  export type PostLikesCreateOrConnectWithoutUserInput = {
    where: PostLikesWhereUniqueInput
    create: XOR<PostLikesCreateWithoutUserInput, PostLikesUncheckedCreateWithoutUserInput>
  }

  export type PostLikesCreateManyUserInputEnvelope = {
    data: Enumerable<PostLikesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AttachedLinkCreateWithoutUserInput = {
    id?: string
    attached_link: string
    source: SourceCreateNestedOneWithoutAttached_linkInput
    ngo?: NGOCreateNestedOneWithoutAttached_linkInput
  }

  export type AttachedLinkUncheckedCreateWithoutUserInput = {
    id?: string
    attached_link: string
    id_source: string
    id_ngo?: string | null
  }

  export type AttachedLinkCreateOrConnectWithoutUserInput = {
    where: AttachedLinkWhereUniqueInput
    create: XOR<AttachedLinkCreateWithoutUserInput, AttachedLinkUncheckedCreateWithoutUserInput>
  }

  export type AttachedLinkCreateManyUserInputEnvelope = {
    data: Enumerable<AttachedLinkCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CampaignParticipantsUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignParticipantsWhereUniqueInput
    update: XOR<CampaignParticipantsUpdateWithoutUserInput, CampaignParticipantsUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignParticipantsCreateWithoutUserInput, CampaignParticipantsUncheckedCreateWithoutUserInput>
  }

  export type CampaignParticipantsUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignParticipantsWhereUniqueInput
    data: XOR<CampaignParticipantsUpdateWithoutUserInput, CampaignParticipantsUncheckedUpdateWithoutUserInput>
  }

  export type CampaignParticipantsUpdateManyWithWhereWithoutUserInput = {
    where: CampaignParticipantsScalarWhereInput
    data: XOR<CampaignParticipantsUpdateManyMutationInput, CampaignParticipantsUncheckedUpdateManyWithoutSupported_campaignsInput>
  }

  export type CampaignParticipantsScalarWhereInput = {
    AND?: Enumerable<CampaignParticipantsScalarWhereInput>
    OR?: Enumerable<CampaignParticipantsScalarWhereInput>
    NOT?: Enumerable<CampaignParticipantsScalarWhereInput>
    id?: StringFilter | string
    id_campaign?: StringFilter | string
    id_user?: StringFilter | string
    id_status?: StringFilter | string
  }

  export type CommentUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentUserWhereUniqueInput
    update: XOR<CommentUserUpdateWithoutUserInput, CommentUserUncheckedUpdateWithoutUserInput>
    create: XOR<CommentUserCreateWithoutUserInput, CommentUserUncheckedCreateWithoutUserInput>
  }

  export type CommentUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentUserWhereUniqueInput
    data: XOR<CommentUserUpdateWithoutUserInput, CommentUserUncheckedUpdateWithoutUserInput>
  }

  export type CommentUserUpdateManyWithWhereWithoutUserInput = {
    where: CommentUserScalarWhereInput
    data: XOR<CommentUserUpdateManyMutationInput, CommentUserUncheckedUpdateManyWithoutComment_userInput>
  }

  export type CommentUserScalarWhereInput = {
    AND?: Enumerable<CommentUserScalarWhereInput>
    OR?: Enumerable<CommentUserScalarWhereInput>
    NOT?: Enumerable<CommentUserScalarWhereInput>
    id?: StringFilter | string
    id_comment?: StringFilter | string
    id_user?: StringFilter | string
  }

  export type FollowingUpsertWithWhereUniqueWithoutUserInput = {
    where: FollowingWhereUniqueInput
    update: XOR<FollowingUpdateWithoutUserInput, FollowingUncheckedUpdateWithoutUserInput>
    create: XOR<FollowingCreateWithoutUserInput, FollowingUncheckedCreateWithoutUserInput>
  }

  export type FollowingUpdateWithWhereUniqueWithoutUserInput = {
    where: FollowingWhereUniqueInput
    data: XOR<FollowingUpdateWithoutUserInput, FollowingUncheckedUpdateWithoutUserInput>
  }

  export type FollowingUpdateManyWithWhereWithoutUserInput = {
    where: FollowingScalarWhereInput
    data: XOR<FollowingUpdateManyMutationInput, FollowingUncheckedUpdateManyWithoutFollowingInput>
  }

  export type FollowingScalarWhereInput = {
    AND?: Enumerable<FollowingScalarWhereInput>
    OR?: Enumerable<FollowingScalarWhereInput>
    NOT?: Enumerable<FollowingScalarWhereInput>
    id?: StringFilter | string
    id_user?: StringFilter | string
    id_ngo?: StringFilter | string
    id_status?: StringFilter | string
  }

  export type PostUserUpsertWithWhereUniqueWithoutUserInput = {
    where: PostUserWhereUniqueInput
    update: XOR<PostUserUpdateWithoutUserInput, PostUserUncheckedUpdateWithoutUserInput>
    create: XOR<PostUserCreateWithoutUserInput, PostUserUncheckedCreateWithoutUserInput>
  }

  export type PostUserUpdateWithWhereUniqueWithoutUserInput = {
    where: PostUserWhereUniqueInput
    data: XOR<PostUserUpdateWithoutUserInput, PostUserUncheckedUpdateWithoutUserInput>
  }

  export type PostUserUpdateManyWithWhereWithoutUserInput = {
    where: PostUserScalarWhereInput
    data: XOR<PostUserUpdateManyMutationInput, PostUserUncheckedUpdateManyWithoutPost_userInput>
  }

  export type PostUserScalarWhereInput = {
    AND?: Enumerable<PostUserScalarWhereInput>
    OR?: Enumerable<PostUserScalarWhereInput>
    NOT?: Enumerable<PostUserScalarWhereInput>
    id?: StringFilter | string
    id_post?: StringFilter | string
    id_user?: StringFilter | string
  }

  export type GenderUpsertWithoutUserInput = {
    update: XOR<GenderUpdateWithoutUserInput, GenderUncheckedUpdateWithoutUserInput>
    create: XOR<GenderCreateWithoutUserInput, GenderUncheckedCreateWithoutUserInput>
  }

  export type GenderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type GenderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUpsertWithoutUserInput = {
    update: XOR<TypeUpdateWithoutUserInput, TypeUncheckedUpdateWithoutUserInput>
    create: XOR<TypeCreateWithoutUserInput, TypeUncheckedCreateWithoutUserInput>
  }

  export type TypeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type UserAddressUpsertWithoutUserInput = {
    update: XOR<UserAddressUpdateWithoutUserInput, UserAddressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAddressCreateWithoutUserInput, UserAddressUncheckedCreateWithoutUserInput>
  }

  export type UserAddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneRequiredWithoutUser_addressNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type UserPhoneUpsertWithoutUserInput = {
    update: XOR<UserPhoneUpdateWithoutUserInput, UserPhoneUncheckedUpdateWithoutUserInput>
    create: XOR<UserPhoneCreateWithoutUserInput, UserPhoneUncheckedCreateWithoutUserInput>
  }

  export type UserPhoneUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: PhoneUpdateOneRequiredWithoutUser_phoneNestedInput
  }

  export type UserPhoneUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_phone?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikesUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentLikesWhereUniqueInput
    update: XOR<CommentLikesUpdateWithoutUserInput, CommentLikesUncheckedUpdateWithoutUserInput>
    create: XOR<CommentLikesCreateWithoutUserInput, CommentLikesUncheckedCreateWithoutUserInput>
  }

  export type CommentLikesUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentLikesWhereUniqueInput
    data: XOR<CommentLikesUpdateWithoutUserInput, CommentLikesUncheckedUpdateWithoutUserInput>
  }

  export type CommentLikesUpdateManyWithWhereWithoutUserInput = {
    where: CommentLikesScalarWhereInput
    data: XOR<CommentLikesUpdateManyMutationInput, CommentLikesUncheckedUpdateManyWithoutComment_likesInput>
  }

  export type CommentLikesScalarWhereInput = {
    AND?: Enumerable<CommentLikesScalarWhereInput>
    OR?: Enumerable<CommentLikesScalarWhereInput>
    NOT?: Enumerable<CommentLikesScalarWhereInput>
    id?: StringFilter | string
    id_comment?: StringFilter | string
    id_user?: StringNullableFilter | string | null
    id_ngo?: StringNullableFilter | string | null
  }

  export type PostLikesUpsertWithWhereUniqueWithoutUserInput = {
    where: PostLikesWhereUniqueInput
    update: XOR<PostLikesUpdateWithoutUserInput, PostLikesUncheckedUpdateWithoutUserInput>
    create: XOR<PostLikesCreateWithoutUserInput, PostLikesUncheckedCreateWithoutUserInput>
  }

  export type PostLikesUpdateWithWhereUniqueWithoutUserInput = {
    where: PostLikesWhereUniqueInput
    data: XOR<PostLikesUpdateWithoutUserInput, PostLikesUncheckedUpdateWithoutUserInput>
  }

  export type PostLikesUpdateManyWithWhereWithoutUserInput = {
    where: PostLikesScalarWhereInput
    data: XOR<PostLikesUpdateManyMutationInput, PostLikesUncheckedUpdateManyWithoutPost_likesInput>
  }

  export type PostLikesScalarWhereInput = {
    AND?: Enumerable<PostLikesScalarWhereInput>
    OR?: Enumerable<PostLikesScalarWhereInput>
    NOT?: Enumerable<PostLikesScalarWhereInput>
    id?: StringFilter | string
    id_user?: StringNullableFilter | string | null
    id_ngo?: StringNullableFilter | string | null
    id_post?: StringFilter | string
  }

  export type AttachedLinkUpsertWithWhereUniqueWithoutUserInput = {
    where: AttachedLinkWhereUniqueInput
    update: XOR<AttachedLinkUpdateWithoutUserInput, AttachedLinkUncheckedUpdateWithoutUserInput>
    create: XOR<AttachedLinkCreateWithoutUserInput, AttachedLinkUncheckedCreateWithoutUserInput>
  }

  export type AttachedLinkUpdateWithWhereUniqueWithoutUserInput = {
    where: AttachedLinkWhereUniqueInput
    data: XOR<AttachedLinkUpdateWithoutUserInput, AttachedLinkUncheckedUpdateWithoutUserInput>
  }

  export type AttachedLinkUpdateManyWithWhereWithoutUserInput = {
    where: AttachedLinkScalarWhereInput
    data: XOR<AttachedLinkUpdateManyMutationInput, AttachedLinkUncheckedUpdateManyWithoutAttached_linkInput>
  }

  export type AttachedLinkScalarWhereInput = {
    AND?: Enumerable<AttachedLinkScalarWhereInput>
    OR?: Enumerable<AttachedLinkScalarWhereInput>
    NOT?: Enumerable<AttachedLinkScalarWhereInput>
    id?: StringFilter | string
    attached_link?: StringFilter | string
    id_source?: StringFilter | string
    id_user?: StringNullableFilter | string | null
    id_ngo?: StringNullableFilter | string | null
  }

  export type UserCreateWithoutGenderInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGenderInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGenderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGenderInput, UserUncheckedCreateWithoutGenderInput>
  }

  export type UserCreateManyGenderInputEnvelope = {
    data: Enumerable<UserCreateManyGenderInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutGenderInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutGenderInput, UserUncheckedUpdateWithoutGenderInput>
    create: XOR<UserCreateWithoutGenderInput, UserUncheckedCreateWithoutGenderInput>
  }

  export type UserUpdateWithWhereUniqueWithoutGenderInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutGenderInput, UserUncheckedUpdateWithoutGenderInput>
  }

  export type UserUpdateManyWithWhereWithoutGenderInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    cpf?: StringFilter | string
    id_gender?: StringFilter | string
    birthdate?: DateTimeFilter | Date | string
    rg?: StringNullableFilter | string | null
    id_type?: StringFilter | string
    description?: StringNullableFilter | string | null
    banner_photo?: StringFilter | string
    photo_url?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
  }

  export type NgoPhoneCreateWithoutPhoneInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutNgo_phoneInput
  }

  export type NgoPhoneUncheckedCreateWithoutPhoneInput = {
    id?: string
    id_ngo: string
  }

  export type NgoPhoneCreateOrConnectWithoutPhoneInput = {
    where: NgoPhoneWhereUniqueInput
    create: XOR<NgoPhoneCreateWithoutPhoneInput, NgoPhoneUncheckedCreateWithoutPhoneInput>
  }

  export type NgoPhoneCreateManyPhoneInputEnvelope = {
    data: Enumerable<NgoPhoneCreateManyPhoneInput>
    skipDuplicates?: boolean
  }

  export type UserPhoneCreateWithoutPhoneInput = {
    id?: string
    user: UserCreateNestedOneWithoutUser_phoneInput
  }

  export type UserPhoneUncheckedCreateWithoutPhoneInput = {
    id?: string
    id_user: string
  }

  export type UserPhoneCreateOrConnectWithoutPhoneInput = {
    where: UserPhoneWhereUniqueInput
    create: XOR<UserPhoneCreateWithoutPhoneInput, UserPhoneUncheckedCreateWithoutPhoneInput>
  }

  export type UserPhoneCreateManyPhoneInputEnvelope = {
    data: Enumerable<UserPhoneCreateManyPhoneInput>
    skipDuplicates?: boolean
  }

  export type NgoPhoneUpsertWithWhereUniqueWithoutPhoneInput = {
    where: NgoPhoneWhereUniqueInput
    update: XOR<NgoPhoneUpdateWithoutPhoneInput, NgoPhoneUncheckedUpdateWithoutPhoneInput>
    create: XOR<NgoPhoneCreateWithoutPhoneInput, NgoPhoneUncheckedCreateWithoutPhoneInput>
  }

  export type NgoPhoneUpdateWithWhereUniqueWithoutPhoneInput = {
    where: NgoPhoneWhereUniqueInput
    data: XOR<NgoPhoneUpdateWithoutPhoneInput, NgoPhoneUncheckedUpdateWithoutPhoneInput>
  }

  export type NgoPhoneUpdateManyWithWhereWithoutPhoneInput = {
    where: NgoPhoneScalarWhereInput
    data: XOR<NgoPhoneUpdateManyMutationInput, NgoPhoneUncheckedUpdateManyWithoutNgo_phoneInput>
  }

  export type NgoPhoneScalarWhereInput = {
    AND?: Enumerable<NgoPhoneScalarWhereInput>
    OR?: Enumerable<NgoPhoneScalarWhereInput>
    NOT?: Enumerable<NgoPhoneScalarWhereInput>
    id?: StringFilter | string
    id_ngo?: StringFilter | string
    id_phone?: StringFilter | string
  }

  export type UserPhoneUpsertWithWhereUniqueWithoutPhoneInput = {
    where: UserPhoneWhereUniqueInput
    update: XOR<UserPhoneUpdateWithoutPhoneInput, UserPhoneUncheckedUpdateWithoutPhoneInput>
    create: XOR<UserPhoneCreateWithoutPhoneInput, UserPhoneUncheckedCreateWithoutPhoneInput>
  }

  export type UserPhoneUpdateWithWhereUniqueWithoutPhoneInput = {
    where: UserPhoneWhereUniqueInput
    data: XOR<UserPhoneUpdateWithoutPhoneInput, UserPhoneUncheckedUpdateWithoutPhoneInput>
  }

  export type UserPhoneUpdateManyWithWhereWithoutPhoneInput = {
    where: UserPhoneScalarWhereInput
    data: XOR<UserPhoneUpdateManyMutationInput, UserPhoneUncheckedUpdateManyWithoutUser_phoneInput>
  }

  export type UserPhoneScalarWhereInput = {
    AND?: Enumerable<UserPhoneScalarWhereInput>
    OR?: Enumerable<UserPhoneScalarWhereInput>
    NOT?: Enumerable<UserPhoneScalarWhereInput>
    id?: StringFilter | string
    id_phone?: StringFilter | string
    id_user?: StringFilter | string
  }

  export type CampaignAddressCreateWithoutAddressInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_addressInput
  }

  export type CampaignAddressUncheckedCreateWithoutAddressInput = {
    id?: string
    id_campaign: string
  }

  export type CampaignAddressCreateOrConnectWithoutAddressInput = {
    where: CampaignAddressWhereUniqueInput
    create: XOR<CampaignAddressCreateWithoutAddressInput, CampaignAddressUncheckedCreateWithoutAddressInput>
  }

  export type CampaignAddressCreateManyAddressInputEnvelope = {
    data: Enumerable<CampaignAddressCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type NgoAddressCreateWithoutAddressInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutNgo_addressInput
  }

  export type NgoAddressUncheckedCreateWithoutAddressInput = {
    id?: string
    id_ngo: string
  }

  export type NgoAddressCreateOrConnectWithoutAddressInput = {
    where: NgoAddressWhereUniqueInput
    create: XOR<NgoAddressCreateWithoutAddressInput, NgoAddressUncheckedCreateWithoutAddressInput>
  }

  export type NgoAddressCreateManyAddressInputEnvelope = {
    data: Enumerable<NgoAddressCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type UserAddressCreateWithoutAddressInput = {
    id?: string
    user: UserCreateNestedOneWithoutUser_addressInput
  }

  export type UserAddressUncheckedCreateWithoutAddressInput = {
    id?: string
    id_user: string
  }

  export type UserAddressCreateOrConnectWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    create: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput>
  }

  export type UserAddressCreateManyAddressInputEnvelope = {
    data: Enumerable<UserAddressCreateManyAddressInput>
    skipDuplicates?: boolean
  }

  export type CampaignAddressUpsertWithWhereUniqueWithoutAddressInput = {
    where: CampaignAddressWhereUniqueInput
    update: XOR<CampaignAddressUpdateWithoutAddressInput, CampaignAddressUncheckedUpdateWithoutAddressInput>
    create: XOR<CampaignAddressCreateWithoutAddressInput, CampaignAddressUncheckedCreateWithoutAddressInput>
  }

  export type CampaignAddressUpdateWithWhereUniqueWithoutAddressInput = {
    where: CampaignAddressWhereUniqueInput
    data: XOR<CampaignAddressUpdateWithoutAddressInput, CampaignAddressUncheckedUpdateWithoutAddressInput>
  }

  export type CampaignAddressUpdateManyWithWhereWithoutAddressInput = {
    where: CampaignAddressScalarWhereInput
    data: XOR<CampaignAddressUpdateManyMutationInput, CampaignAddressUncheckedUpdateManyWithoutCampaign_addressInput>
  }

  export type CampaignAddressScalarWhereInput = {
    AND?: Enumerable<CampaignAddressScalarWhereInput>
    OR?: Enumerable<CampaignAddressScalarWhereInput>
    NOT?: Enumerable<CampaignAddressScalarWhereInput>
    id?: StringFilter | string
    id_campaign?: StringFilter | string
    id_address?: StringFilter | string
  }

  export type NgoAddressUpsertWithWhereUniqueWithoutAddressInput = {
    where: NgoAddressWhereUniqueInput
    update: XOR<NgoAddressUpdateWithoutAddressInput, NgoAddressUncheckedUpdateWithoutAddressInput>
    create: XOR<NgoAddressCreateWithoutAddressInput, NgoAddressUncheckedCreateWithoutAddressInput>
  }

  export type NgoAddressUpdateWithWhereUniqueWithoutAddressInput = {
    where: NgoAddressWhereUniqueInput
    data: XOR<NgoAddressUpdateWithoutAddressInput, NgoAddressUncheckedUpdateWithoutAddressInput>
  }

  export type NgoAddressUpdateManyWithWhereWithoutAddressInput = {
    where: NgoAddressScalarWhereInput
    data: XOR<NgoAddressUpdateManyMutationInput, NgoAddressUncheckedUpdateManyWithoutNgo_addressInput>
  }

  export type NgoAddressScalarWhereInput = {
    AND?: Enumerable<NgoAddressScalarWhereInput>
    OR?: Enumerable<NgoAddressScalarWhereInput>
    NOT?: Enumerable<NgoAddressScalarWhereInput>
    id?: StringFilter | string
    id_ngo?: StringFilter | string
    id_address?: StringFilter | string
  }

  export type UserAddressUpsertWithWhereUniqueWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    update: XOR<UserAddressUpdateWithoutAddressInput, UserAddressUncheckedUpdateWithoutAddressInput>
    create: XOR<UserAddressCreateWithoutAddressInput, UserAddressUncheckedCreateWithoutAddressInput>
  }

  export type UserAddressUpdateWithWhereUniqueWithoutAddressInput = {
    where: UserAddressWhereUniqueInput
    data: XOR<UserAddressUpdateWithoutAddressInput, UserAddressUncheckedUpdateWithoutAddressInput>
  }

  export type UserAddressUpdateManyWithWhereWithoutAddressInput = {
    where: UserAddressScalarWhereInput
    data: XOR<UserAddressUpdateManyMutationInput, UserAddressUncheckedUpdateManyWithoutUser_addressInput>
  }

  export type UserAddressScalarWhereInput = {
    AND?: Enumerable<UserAddressScalarWhereInput>
    OR?: Enumerable<UserAddressScalarWhereInput>
    NOT?: Enumerable<UserAddressScalarWhereInput>
    id?: StringFilter | string
    id_address?: StringFilter | string
    id_user?: StringFilter | string
  }

  export type AddressCreateWithoutUser_addressInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    campaign_address?: CampaignAddressCreateNestedManyWithoutAddressInput
    ngo_address?: NgoAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUser_addressInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    campaign_address?: CampaignAddressUncheckedCreateNestedManyWithoutAddressInput
    ngo_address?: NgoAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUser_addressInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUser_addressInput, AddressUncheckedCreateWithoutUser_addressInput>
  }

  export type UserCreateWithoutUser_addressInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_addressInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_addressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
  }

  export type AddressUpsertWithoutUser_addressInput = {
    update: XOR<AddressUpdateWithoutUser_addressInput, AddressUncheckedUpdateWithoutUser_addressInput>
    create: XOR<AddressCreateWithoutUser_addressInput, AddressUncheckedCreateWithoutUser_addressInput>
  }

  export type AddressUpdateWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_address?: CampaignAddressUpdateManyWithoutAddressNestedInput
    ngo_address?: NgoAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_address?: CampaignAddressUncheckedUpdateManyWithoutAddressNestedInput
    ngo_address?: NgoAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type UserUpsertWithoutUser_addressInput = {
    update: XOR<UserUpdateWithoutUser_addressInput, UserUncheckedUpdateWithoutUser_addressInput>
    create: XOR<UserCreateWithoutUser_addressInput, UserUncheckedCreateWithoutUser_addressInput>
  }

  export type UserUpdateWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NGOCreateWithoutCampaignInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutCampaignInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutCampaignInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutCampaignInput, NGOUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAddressCreateWithoutCampaignInput = {
    id?: string
    address: AddressCreateNestedOneWithoutCampaign_addressInput
  }

  export type CampaignAddressUncheckedCreateWithoutCampaignInput = {
    id?: string
    id_address: string
  }

  export type CampaignAddressCreateOrConnectWithoutCampaignInput = {
    where: CampaignAddressWhereUniqueInput
    create: XOR<CampaignAddressCreateWithoutCampaignInput, CampaignAddressUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignCausesCreateWithoutCampaignInput = {
    id?: string
    causes: CausesCreateNestedOneWithoutCampaign_causesInput
  }

  export type CampaignCausesUncheckedCreateWithoutCampaignInput = {
    id?: string
    id_cause: string
  }

  export type CampaignCausesCreateOrConnectWithoutCampaignInput = {
    where: CampaignCausesWhereUniqueInput
    create: XOR<CampaignCausesCreateWithoutCampaignInput, CampaignCausesUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignCausesCreateManyCampaignInputEnvelope = {
    data: Enumerable<CampaignCausesCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type CampaignParticipantsCreateWithoutCampaignInput = {
    id?: string
    user: UserCreateNestedOneWithoutSupported_campaignsInput
    status: StatusCreateNestedOneWithoutCampaignParticipantsInput
  }

  export type CampaignParticipantsUncheckedCreateWithoutCampaignInput = {
    id?: string
    id_user: string
    id_status: string
  }

  export type CampaignParticipantsCreateOrConnectWithoutCampaignInput = {
    where: CampaignParticipantsWhereUniqueInput
    create: XOR<CampaignParticipantsCreateWithoutCampaignInput, CampaignParticipantsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignParticipantsCreateManyCampaignInputEnvelope = {
    data: Enumerable<CampaignParticipantsCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type CampaignPhotosCreateWithoutCampaignInput = {
    id?: string
    photo_url: string
  }

  export type CampaignPhotosUncheckedCreateWithoutCampaignInput = {
    id?: string
    photo_url: string
  }

  export type CampaignPhotosCreateOrConnectWithoutCampaignInput = {
    where: CampaignPhotosWhereUniqueInput
    create: XOR<CampaignPhotosCreateWithoutCampaignInput, CampaignPhotosUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignPhotosCreateManyCampaignInputEnvelope = {
    data: Enumerable<CampaignPhotosCreateManyCampaignInput>
    skipDuplicates?: boolean
  }

  export type NGOUpsertWithoutCampaignInput = {
    update: XOR<NGOUpdateWithoutCampaignInput, NGOUncheckedUpdateWithoutCampaignInput>
    create: XOR<NGOCreateWithoutCampaignInput, NGOUncheckedCreateWithoutCampaignInput>
  }

  export type NGOUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type CampaignAddressUpsertWithoutCampaignInput = {
    update: XOR<CampaignAddressUpdateWithoutCampaignInput, CampaignAddressUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignAddressCreateWithoutCampaignInput, CampaignAddressUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAddressUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneRequiredWithoutCampaign_addressNestedInput
  }

  export type CampaignAddressUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignCausesWhereUniqueInput
    update: XOR<CampaignCausesUpdateWithoutCampaignInput, CampaignCausesUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignCausesCreateWithoutCampaignInput, CampaignCausesUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignCausesUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignCausesWhereUniqueInput
    data: XOR<CampaignCausesUpdateWithoutCampaignInput, CampaignCausesUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignCausesUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignCausesScalarWhereInput
    data: XOR<CampaignCausesUpdateManyMutationInput, CampaignCausesUncheckedUpdateManyWithoutCampaign_causesInput>
  }

  export type CampaignCausesScalarWhereInput = {
    AND?: Enumerable<CampaignCausesScalarWhereInput>
    OR?: Enumerable<CampaignCausesScalarWhereInput>
    NOT?: Enumerable<CampaignCausesScalarWhereInput>
    id?: StringFilter | string
    id_cause?: StringFilter | string
    id_campaign?: StringFilter | string
  }

  export type CampaignParticipantsUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignParticipantsWhereUniqueInput
    update: XOR<CampaignParticipantsUpdateWithoutCampaignInput, CampaignParticipantsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignParticipantsCreateWithoutCampaignInput, CampaignParticipantsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignParticipantsUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignParticipantsWhereUniqueInput
    data: XOR<CampaignParticipantsUpdateWithoutCampaignInput, CampaignParticipantsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignParticipantsUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignParticipantsScalarWhereInput
    data: XOR<CampaignParticipantsUpdateManyMutationInput, CampaignParticipantsUncheckedUpdateManyWithoutCampaign_participantsInput>
  }

  export type CampaignPhotosUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignPhotosWhereUniqueInput
    update: XOR<CampaignPhotosUpdateWithoutCampaignInput, CampaignPhotosUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignPhotosCreateWithoutCampaignInput, CampaignPhotosUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignPhotosUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignPhotosWhereUniqueInput
    data: XOR<CampaignPhotosUpdateWithoutCampaignInput, CampaignPhotosUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignPhotosUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignPhotosScalarWhereInput
    data: XOR<CampaignPhotosUpdateManyMutationInput, CampaignPhotosUncheckedUpdateManyWithoutCampaign_photosInput>
  }

  export type CampaignPhotosScalarWhereInput = {
    AND?: Enumerable<CampaignPhotosScalarWhereInput>
    OR?: Enumerable<CampaignPhotosScalarWhereInput>
    NOT?: Enumerable<CampaignPhotosScalarWhereInput>
    id?: StringFilter | string
    photo_url?: StringFilter | string
    id_campaign?: StringFilter | string
  }

  export type CampaignCreateWithoutCampaign_addressInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    ngo: NGOCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_addressInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsUncheckedCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_addressInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_addressInput, CampaignUncheckedCreateWithoutCampaign_addressInput>
  }

  export type AddressCreateWithoutCampaign_addressInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    ngo_address?: NgoAddressCreateNestedManyWithoutAddressInput
    user_address?: UserAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCampaign_addressInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    ngo_address?: NgoAddressUncheckedCreateNestedManyWithoutAddressInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCampaign_addressInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCampaign_addressInput, AddressUncheckedCreateWithoutCampaign_addressInput>
  }

  export type CampaignUpsertWithoutCampaign_addressInput = {
    update: XOR<CampaignUpdateWithoutCampaign_addressInput, CampaignUncheckedUpdateWithoutCampaign_addressInput>
    create: XOR<CampaignCreateWithoutCampaign_addressInput, CampaignUncheckedCreateWithoutCampaign_addressInput>
  }

  export type CampaignUpdateWithoutCampaign_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    ngo?: NGOUpdateOneRequiredWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    id_ngo?: StringFieldUpdateOperationsInput | string
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type AddressUpsertWithoutCampaign_addressInput = {
    update: XOR<AddressUpdateWithoutCampaign_addressInput, AddressUncheckedUpdateWithoutCampaign_addressInput>
    create: XOR<AddressCreateWithoutCampaign_addressInput, AddressUncheckedCreateWithoutCampaign_addressInput>
  }

  export type AddressUpdateWithoutCampaign_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_address?: NgoAddressUpdateManyWithoutAddressNestedInput
    user_address?: UserAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCampaign_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_address?: NgoAddressUncheckedUpdateManyWithoutAddressNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type CampaignCreateWithoutCampaign_causesInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    ngo: NGOCreateNestedOneWithoutCampaignInput
    campaign_address?: CampaignAddressCreateNestedOneWithoutCampaignInput
    campaign_participants?: CampaignParticipantsCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_causesInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_address?: CampaignAddressUncheckedCreateNestedOneWithoutCampaignInput
    campaign_participants?: CampaignParticipantsUncheckedCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_causesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_causesInput, CampaignUncheckedCreateWithoutCampaign_causesInput>
  }

  export type CausesCreateWithoutCampaign_causesInput = {
    id?: string
    title: string
    description?: string | null
    ngo_causes?: NgoCausesCreateNestedManyWithoutCausesInput
  }

  export type CausesUncheckedCreateWithoutCampaign_causesInput = {
    id?: string
    title: string
    description?: string | null
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutCausesInput
  }

  export type CausesCreateOrConnectWithoutCampaign_causesInput = {
    where: CausesWhereUniqueInput
    create: XOR<CausesCreateWithoutCampaign_causesInput, CausesUncheckedCreateWithoutCampaign_causesInput>
  }

  export type CampaignUpsertWithoutCampaign_causesInput = {
    update: XOR<CampaignUpdateWithoutCampaign_causesInput, CampaignUncheckedUpdateWithoutCampaign_causesInput>
    create: XOR<CampaignCreateWithoutCampaign_causesInput, CampaignUncheckedCreateWithoutCampaign_causesInput>
  }

  export type CampaignUpdateWithoutCampaign_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    ngo?: NGOUpdateOneRequiredWithoutCampaignNestedInput
    campaign_address?: CampaignAddressUpdateOneWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    id_ngo?: StringFieldUpdateOperationsInput | string
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_address?: CampaignAddressUncheckedUpdateOneWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CausesUpsertWithoutCampaign_causesInput = {
    update: XOR<CausesUpdateWithoutCampaign_causesInput, CausesUncheckedUpdateWithoutCampaign_causesInput>
    create: XOR<CausesCreateWithoutCampaign_causesInput, CausesUncheckedCreateWithoutCampaign_causesInput>
  }

  export type CausesUpdateWithoutCampaign_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_causes?: NgoCausesUpdateManyWithoutCausesNestedInput
  }

  export type CausesUncheckedUpdateWithoutCampaign_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutCausesNestedInput
  }

  export type CampaignCreateWithoutCampaign_participantsInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    ngo: NGOCreateNestedOneWithoutCampaignInput
    campaign_address?: CampaignAddressCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_participantsInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_address?: CampaignAddressUncheckedCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_participantsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_participantsInput, CampaignUncheckedCreateWithoutCampaign_participantsInput>
  }

  export type UserCreateWithoutSupported_campaignsInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSupported_campaignsInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSupported_campaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupported_campaignsInput, UserUncheckedCreateWithoutSupported_campaignsInput>
  }

  export type StatusCreateWithoutCampaignParticipantsInput = {
    id?: string
    name: string
    Following?: FollowingCreateNestedManyWithoutStatusInput
  }

  export type StatusUncheckedCreateWithoutCampaignParticipantsInput = {
    id?: string
    name: string
    Following?: FollowingUncheckedCreateNestedManyWithoutStatusInput
  }

  export type StatusCreateOrConnectWithoutCampaignParticipantsInput = {
    where: StatusWhereUniqueInput
    create: XOR<StatusCreateWithoutCampaignParticipantsInput, StatusUncheckedCreateWithoutCampaignParticipantsInput>
  }

  export type CampaignUpsertWithoutCampaign_participantsInput = {
    update: XOR<CampaignUpdateWithoutCampaign_participantsInput, CampaignUncheckedUpdateWithoutCampaign_participantsInput>
    create: XOR<CampaignCreateWithoutCampaign_participantsInput, CampaignUncheckedCreateWithoutCampaign_participantsInput>
  }

  export type CampaignUpdateWithoutCampaign_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    ngo?: NGOUpdateOneRequiredWithoutCampaignNestedInput
    campaign_address?: CampaignAddressUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    id_ngo?: StringFieldUpdateOperationsInput | string
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_address?: CampaignAddressUncheckedUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutSupported_campaignsInput = {
    update: XOR<UserUpdateWithoutSupported_campaignsInput, UserUncheckedUpdateWithoutSupported_campaignsInput>
    create: XOR<UserCreateWithoutSupported_campaignsInput, UserUncheckedCreateWithoutSupported_campaignsInput>
  }

  export type UserUpdateWithoutSupported_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSupported_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StatusUpsertWithoutCampaignParticipantsInput = {
    update: XOR<StatusUpdateWithoutCampaignParticipantsInput, StatusUncheckedUpdateWithoutCampaignParticipantsInput>
    create: XOR<StatusCreateWithoutCampaignParticipantsInput, StatusUncheckedCreateWithoutCampaignParticipantsInput>
  }

  export type StatusUpdateWithoutCampaignParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Following?: FollowingUpdateManyWithoutStatusNestedInput
  }

  export type StatusUncheckedUpdateWithoutCampaignParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    Following?: FollowingUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type CampaignCreateWithoutCampaign_photosInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    ngo: NGOCreateNestedOneWithoutCampaignInput
    campaign_address?: CampaignAddressCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCampaign_photosInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    id_ngo: string
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_address?: CampaignAddressUncheckedCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCampaign_photosInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCampaign_photosInput, CampaignUncheckedCreateWithoutCampaign_photosInput>
  }

  export type CampaignUpsertWithoutCampaign_photosInput = {
    update: XOR<CampaignUpdateWithoutCampaign_photosInput, CampaignUncheckedUpdateWithoutCampaign_photosInput>
    create: XOR<CampaignCreateWithoutCampaign_photosInput, CampaignUncheckedCreateWithoutCampaign_photosInput>
  }

  export type CampaignUpdateWithoutCampaign_photosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    ngo?: NGOUpdateOneRequiredWithoutCampaignNestedInput
    campaign_address?: CampaignAddressUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCampaign_photosInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    id_ngo?: StringFieldUpdateOperationsInput | string
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_address?: CampaignAddressUncheckedUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCausesCreateWithoutCausesInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_causesInput
  }

  export type CampaignCausesUncheckedCreateWithoutCausesInput = {
    id?: string
    id_campaign: string
  }

  export type CampaignCausesCreateOrConnectWithoutCausesInput = {
    where: CampaignCausesWhereUniqueInput
    create: XOR<CampaignCausesCreateWithoutCausesInput, CampaignCausesUncheckedCreateWithoutCausesInput>
  }

  export type CampaignCausesCreateManyCausesInputEnvelope = {
    data: Enumerable<CampaignCausesCreateManyCausesInput>
    skipDuplicates?: boolean
  }

  export type NgoCausesCreateWithoutCausesInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutNgo_causesInput
  }

  export type NgoCausesUncheckedCreateWithoutCausesInput = {
    id?: string
    id_ngo: string
  }

  export type NgoCausesCreateOrConnectWithoutCausesInput = {
    where: NgoCausesWhereUniqueInput
    create: XOR<NgoCausesCreateWithoutCausesInput, NgoCausesUncheckedCreateWithoutCausesInput>
  }

  export type NgoCausesCreateManyCausesInputEnvelope = {
    data: Enumerable<NgoCausesCreateManyCausesInput>
    skipDuplicates?: boolean
  }

  export type CampaignCausesUpsertWithWhereUniqueWithoutCausesInput = {
    where: CampaignCausesWhereUniqueInput
    update: XOR<CampaignCausesUpdateWithoutCausesInput, CampaignCausesUncheckedUpdateWithoutCausesInput>
    create: XOR<CampaignCausesCreateWithoutCausesInput, CampaignCausesUncheckedCreateWithoutCausesInput>
  }

  export type CampaignCausesUpdateWithWhereUniqueWithoutCausesInput = {
    where: CampaignCausesWhereUniqueInput
    data: XOR<CampaignCausesUpdateWithoutCausesInput, CampaignCausesUncheckedUpdateWithoutCausesInput>
  }

  export type CampaignCausesUpdateManyWithWhereWithoutCausesInput = {
    where: CampaignCausesScalarWhereInput
    data: XOR<CampaignCausesUpdateManyMutationInput, CampaignCausesUncheckedUpdateManyWithoutCampaign_causesInput>
  }

  export type NgoCausesUpsertWithWhereUniqueWithoutCausesInput = {
    where: NgoCausesWhereUniqueInput
    update: XOR<NgoCausesUpdateWithoutCausesInput, NgoCausesUncheckedUpdateWithoutCausesInput>
    create: XOR<NgoCausesCreateWithoutCausesInput, NgoCausesUncheckedCreateWithoutCausesInput>
  }

  export type NgoCausesUpdateWithWhereUniqueWithoutCausesInput = {
    where: NgoCausesWhereUniqueInput
    data: XOR<NgoCausesUpdateWithoutCausesInput, NgoCausesUncheckedUpdateWithoutCausesInput>
  }

  export type NgoCausesUpdateManyWithWhereWithoutCausesInput = {
    where: NgoCausesScalarWhereInput
    data: XOR<NgoCausesUpdateManyMutationInput, NgoCausesUncheckedUpdateManyWithoutNgo_causesInput>
  }

  export type NgoCausesScalarWhereInput = {
    AND?: Enumerable<NgoCausesScalarWhereInput>
    OR?: Enumerable<NgoCausesScalarWhereInput>
    NOT?: Enumerable<NgoCausesScalarWhereInput>
    id?: StringFilter | string
    id_causes?: StringFilter | string
    id_ngo?: StringFilter | string
  }

  export type StatusCreateWithoutFollowingInput = {
    id?: string
    name: string
    CampaignParticipants?: CampaignParticipantsCreateNestedManyWithoutStatusInput
  }

  export type StatusUncheckedCreateWithoutFollowingInput = {
    id?: string
    name: string
    CampaignParticipants?: CampaignParticipantsUncheckedCreateNestedManyWithoutStatusInput
  }

  export type StatusCreateOrConnectWithoutFollowingInput = {
    where: StatusWhereUniqueInput
    create: XOR<StatusCreateWithoutFollowingInput, StatusUncheckedCreateWithoutFollowingInput>
  }

  export type NGOCreateWithoutFollowingInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutFollowingInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutFollowingInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutFollowingInput, NGOUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowingInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type StatusUpsertWithoutFollowingInput = {
    update: XOR<StatusUpdateWithoutFollowingInput, StatusUncheckedUpdateWithoutFollowingInput>
    create: XOR<StatusCreateWithoutFollowingInput, StatusUncheckedCreateWithoutFollowingInput>
  }

  export type StatusUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    CampaignParticipants?: CampaignParticipantsUpdateManyWithoutStatusNestedInput
  }

  export type StatusUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    CampaignParticipants?: CampaignParticipantsUncheckedUpdateManyWithoutStatusNestedInput
  }

  export type NGOUpsertWithoutFollowingInput = {
    update: XOR<NGOUpdateWithoutFollowingInput, NGOUncheckedUpdateWithoutFollowingInput>
    create: XOR<NGOCreateWithoutFollowingInput, NGOUncheckedCreateWithoutFollowingInput>
  }

  export type NGOUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignCreateWithoutNgoInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_address?: CampaignAddressCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutNgoInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
    campaign_address?: CampaignAddressUncheckedCreateNestedOneWithoutCampaignInput
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCampaignInput
    campaign_participants?: CampaignParticipantsUncheckedCreateNestedManyWithoutCampaignInput
    campaign_photos?: CampaignPhotosUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutNgoInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutNgoInput, CampaignUncheckedCreateWithoutNgoInput>
  }

  export type CampaignCreateManyNgoInputEnvelope = {
    data: Enumerable<CampaignCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type CommentNgoCreateWithoutNgoInput = {
    id?: string
    comment: CommentCreateNestedOneWithoutComment_ngoInput
  }

  export type CommentNgoUncheckedCreateWithoutNgoInput = {
    id?: string
    id_comment: string
  }

  export type CommentNgoCreateOrConnectWithoutNgoInput = {
    where: CommentNgoWhereUniqueInput
    create: XOR<CommentNgoCreateWithoutNgoInput, CommentNgoUncheckedCreateWithoutNgoInput>
  }

  export type CommentNgoCreateManyNgoInputEnvelope = {
    data: Enumerable<CommentNgoCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type FollowingCreateWithoutNgoInput = {
    id?: string
    status: StatusCreateNestedOneWithoutFollowingInput
    user: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowingUncheckedCreateWithoutNgoInput = {
    id?: string
    id_user: string
    id_status: string
  }

  export type FollowingCreateOrConnectWithoutNgoInput = {
    where: FollowingWhereUniqueInput
    create: XOR<FollowingCreateWithoutNgoInput, FollowingUncheckedCreateWithoutNgoInput>
  }

  export type FollowingCreateManyNgoInputEnvelope = {
    data: Enumerable<FollowingCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type TypeCreateWithoutNgoInput = {
    id?: string
    name: string
    user?: UserCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateWithoutNgoInput = {
    id?: string
    name: string
    user?: UserUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeCreateOrConnectWithoutNgoInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutNgoInput, TypeUncheckedCreateWithoutNgoInput>
  }

  export type NgoAddressCreateWithoutNgoInput = {
    id?: string
    address: AddressCreateNestedOneWithoutNgo_addressInput
  }

  export type NgoAddressUncheckedCreateWithoutNgoInput = {
    id?: string
    id_address: string
  }

  export type NgoAddressCreateOrConnectWithoutNgoInput = {
    where: NgoAddressWhereUniqueInput
    create: XOR<NgoAddressCreateWithoutNgoInput, NgoAddressUncheckedCreateWithoutNgoInput>
  }

  export type NgoCausesCreateWithoutNgoInput = {
    id?: string
    causes: CausesCreateNestedOneWithoutNgo_causesInput
  }

  export type NgoCausesUncheckedCreateWithoutNgoInput = {
    id?: string
    id_causes: string
  }

  export type NgoCausesCreateOrConnectWithoutNgoInput = {
    where: NgoCausesWhereUniqueInput
    create: XOR<NgoCausesCreateWithoutNgoInput, NgoCausesUncheckedCreateWithoutNgoInput>
  }

  export type NgoCausesCreateManyNgoInputEnvelope = {
    data: Enumerable<NgoCausesCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type NgoPhoneCreateWithoutNgoInput = {
    id?: string
    phone: PhoneCreateNestedOneWithoutNgo_phoneInput
  }

  export type NgoPhoneUncheckedCreateWithoutNgoInput = {
    id?: string
    id_phone: string
  }

  export type NgoPhoneCreateOrConnectWithoutNgoInput = {
    where: NgoPhoneWhereUniqueInput
    create: XOR<NgoPhoneCreateWithoutNgoInput, NgoPhoneUncheckedCreateWithoutNgoInput>
  }

  export type NgoPhoneCreateManyNgoInputEnvelope = {
    data: Enumerable<NgoPhoneCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type PostNgoCreateWithoutNgoInput = {
    id?: string
    post: PostCreateNestedOneWithoutPost_ngoInput
  }

  export type PostNgoUncheckedCreateWithoutNgoInput = {
    id?: string
    id_post: string
  }

  export type PostNgoCreateOrConnectWithoutNgoInput = {
    where: PostNgoWhereUniqueInput
    create: XOR<PostNgoCreateWithoutNgoInput, PostNgoUncheckedCreateWithoutNgoInput>
  }

  export type PostNgoCreateManyNgoInputEnvelope = {
    data: Enumerable<PostNgoCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type CommentLikesCreateWithoutNgoInput = {
    id?: string
    user?: UserCreateNestedOneWithoutComment_likesInput
    comment: CommentCreateNestedOneWithoutComment_likesInput
  }

  export type CommentLikesUncheckedCreateWithoutNgoInput = {
    id?: string
    id_comment: string
    id_user?: string | null
  }

  export type CommentLikesCreateOrConnectWithoutNgoInput = {
    where: CommentLikesWhereUniqueInput
    create: XOR<CommentLikesCreateWithoutNgoInput, CommentLikesUncheckedCreateWithoutNgoInput>
  }

  export type CommentLikesCreateManyNgoInputEnvelope = {
    data: Enumerable<CommentLikesCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type PostLikesCreateWithoutNgoInput = {
    id?: string
    user?: UserCreateNestedOneWithoutPost_likesInput
    post: PostCreateNestedOneWithoutPost_likesInput
  }

  export type PostLikesUncheckedCreateWithoutNgoInput = {
    id?: string
    id_user?: string | null
    id_post: string
  }

  export type PostLikesCreateOrConnectWithoutNgoInput = {
    where: PostLikesWhereUniqueInput
    create: XOR<PostLikesCreateWithoutNgoInput, PostLikesUncheckedCreateWithoutNgoInput>
  }

  export type PostLikesCreateManyNgoInputEnvelope = {
    data: Enumerable<PostLikesCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type AttachedLinkCreateWithoutNgoInput = {
    id?: string
    attached_link: string
    source: SourceCreateNestedOneWithoutAttached_linkInput
    user?: UserCreateNestedOneWithoutAttached_linkInput
  }

  export type AttachedLinkUncheckedCreateWithoutNgoInput = {
    id?: string
    attached_link: string
    id_source: string
    id_user?: string | null
  }

  export type AttachedLinkCreateOrConnectWithoutNgoInput = {
    where: AttachedLinkWhereUniqueInput
    create: XOR<AttachedLinkCreateWithoutNgoInput, AttachedLinkUncheckedCreateWithoutNgoInput>
  }

  export type AttachedLinkCreateManyNgoInputEnvelope = {
    data: Enumerable<AttachedLinkCreateManyNgoInput>
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithWhereUniqueWithoutNgoInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutNgoInput, CampaignUncheckedUpdateWithoutNgoInput>
    create: XOR<CampaignCreateWithoutNgoInput, CampaignUncheckedCreateWithoutNgoInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutNgoInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutNgoInput, CampaignUncheckedUpdateWithoutNgoInput>
  }

  export type CampaignUpdateManyWithWhereWithoutNgoInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: Enumerable<CampaignScalarWhereInput>
    OR?: Enumerable<CampaignScalarWhereInput>
    NOT?: Enumerable<CampaignScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    description?: StringNullableFilter | string | null
    begin_date?: DateTimeFilter | Date | string
    end_date?: DateTimeFilter | Date | string
    home_office?: BoolFilter | boolean
    id_ngo?: StringFilter | string
    how_to_contribute?: StringFilter | string
    prerequisites?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    is_active?: BoolFilter | boolean
  }

  export type CommentNgoUpsertWithWhereUniqueWithoutNgoInput = {
    where: CommentNgoWhereUniqueInput
    update: XOR<CommentNgoUpdateWithoutNgoInput, CommentNgoUncheckedUpdateWithoutNgoInput>
    create: XOR<CommentNgoCreateWithoutNgoInput, CommentNgoUncheckedCreateWithoutNgoInput>
  }

  export type CommentNgoUpdateWithWhereUniqueWithoutNgoInput = {
    where: CommentNgoWhereUniqueInput
    data: XOR<CommentNgoUpdateWithoutNgoInput, CommentNgoUncheckedUpdateWithoutNgoInput>
  }

  export type CommentNgoUpdateManyWithWhereWithoutNgoInput = {
    where: CommentNgoScalarWhereInput
    data: XOR<CommentNgoUpdateManyMutationInput, CommentNgoUncheckedUpdateManyWithoutComment_ngoInput>
  }

  export type CommentNgoScalarWhereInput = {
    AND?: Enumerable<CommentNgoScalarWhereInput>
    OR?: Enumerable<CommentNgoScalarWhereInput>
    NOT?: Enumerable<CommentNgoScalarWhereInput>
    id?: StringFilter | string
    id_comment?: StringFilter | string
    id_ngo?: StringFilter | string
  }

  export type FollowingUpsertWithWhereUniqueWithoutNgoInput = {
    where: FollowingWhereUniqueInput
    update: XOR<FollowingUpdateWithoutNgoInput, FollowingUncheckedUpdateWithoutNgoInput>
    create: XOR<FollowingCreateWithoutNgoInput, FollowingUncheckedCreateWithoutNgoInput>
  }

  export type FollowingUpdateWithWhereUniqueWithoutNgoInput = {
    where: FollowingWhereUniqueInput
    data: XOR<FollowingUpdateWithoutNgoInput, FollowingUncheckedUpdateWithoutNgoInput>
  }

  export type FollowingUpdateManyWithWhereWithoutNgoInput = {
    where: FollowingScalarWhereInput
    data: XOR<FollowingUpdateManyMutationInput, FollowingUncheckedUpdateManyWithoutFollowingInput>
  }

  export type TypeUpsertWithoutNgoInput = {
    update: XOR<TypeUpdateWithoutNgoInput, TypeUncheckedUpdateWithoutNgoInput>
    create: XOR<TypeCreateWithoutNgoInput, TypeUncheckedCreateWithoutNgoInput>
  }

  export type TypeUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type NgoAddressUpsertWithoutNgoInput = {
    update: XOR<NgoAddressUpdateWithoutNgoInput, NgoAddressUncheckedUpdateWithoutNgoInput>
    create: XOR<NgoAddressCreateWithoutNgoInput, NgoAddressUncheckedCreateWithoutNgoInput>
  }

  export type NgoAddressUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: AddressUpdateOneRequiredWithoutNgo_addressNestedInput
  }

  export type NgoAddressUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_address?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesUpsertWithWhereUniqueWithoutNgoInput = {
    where: NgoCausesWhereUniqueInput
    update: XOR<NgoCausesUpdateWithoutNgoInput, NgoCausesUncheckedUpdateWithoutNgoInput>
    create: XOR<NgoCausesCreateWithoutNgoInput, NgoCausesUncheckedCreateWithoutNgoInput>
  }

  export type NgoCausesUpdateWithWhereUniqueWithoutNgoInput = {
    where: NgoCausesWhereUniqueInput
    data: XOR<NgoCausesUpdateWithoutNgoInput, NgoCausesUncheckedUpdateWithoutNgoInput>
  }

  export type NgoCausesUpdateManyWithWhereWithoutNgoInput = {
    where: NgoCausesScalarWhereInput
    data: XOR<NgoCausesUpdateManyMutationInput, NgoCausesUncheckedUpdateManyWithoutNgo_causesInput>
  }

  export type NgoPhoneUpsertWithWhereUniqueWithoutNgoInput = {
    where: NgoPhoneWhereUniqueInput
    update: XOR<NgoPhoneUpdateWithoutNgoInput, NgoPhoneUncheckedUpdateWithoutNgoInput>
    create: XOR<NgoPhoneCreateWithoutNgoInput, NgoPhoneUncheckedCreateWithoutNgoInput>
  }

  export type NgoPhoneUpdateWithWhereUniqueWithoutNgoInput = {
    where: NgoPhoneWhereUniqueInput
    data: XOR<NgoPhoneUpdateWithoutNgoInput, NgoPhoneUncheckedUpdateWithoutNgoInput>
  }

  export type NgoPhoneUpdateManyWithWhereWithoutNgoInput = {
    where: NgoPhoneScalarWhereInput
    data: XOR<NgoPhoneUpdateManyMutationInput, NgoPhoneUncheckedUpdateManyWithoutNgo_phoneInput>
  }

  export type PostNgoUpsertWithWhereUniqueWithoutNgoInput = {
    where: PostNgoWhereUniqueInput
    update: XOR<PostNgoUpdateWithoutNgoInput, PostNgoUncheckedUpdateWithoutNgoInput>
    create: XOR<PostNgoCreateWithoutNgoInput, PostNgoUncheckedCreateWithoutNgoInput>
  }

  export type PostNgoUpdateWithWhereUniqueWithoutNgoInput = {
    where: PostNgoWhereUniqueInput
    data: XOR<PostNgoUpdateWithoutNgoInput, PostNgoUncheckedUpdateWithoutNgoInput>
  }

  export type PostNgoUpdateManyWithWhereWithoutNgoInput = {
    where: PostNgoScalarWhereInput
    data: XOR<PostNgoUpdateManyMutationInput, PostNgoUncheckedUpdateManyWithoutPost_ngoInput>
  }

  export type PostNgoScalarWhereInput = {
    AND?: Enumerable<PostNgoScalarWhereInput>
    OR?: Enumerable<PostNgoScalarWhereInput>
    NOT?: Enumerable<PostNgoScalarWhereInput>
    id?: StringFilter | string
    id_post?: StringFilter | string
    id_ngo?: StringFilter | string
  }

  export type CommentLikesUpsertWithWhereUniqueWithoutNgoInput = {
    where: CommentLikesWhereUniqueInput
    update: XOR<CommentLikesUpdateWithoutNgoInput, CommentLikesUncheckedUpdateWithoutNgoInput>
    create: XOR<CommentLikesCreateWithoutNgoInput, CommentLikesUncheckedCreateWithoutNgoInput>
  }

  export type CommentLikesUpdateWithWhereUniqueWithoutNgoInput = {
    where: CommentLikesWhereUniqueInput
    data: XOR<CommentLikesUpdateWithoutNgoInput, CommentLikesUncheckedUpdateWithoutNgoInput>
  }

  export type CommentLikesUpdateManyWithWhereWithoutNgoInput = {
    where: CommentLikesScalarWhereInput
    data: XOR<CommentLikesUpdateManyMutationInput, CommentLikesUncheckedUpdateManyWithoutComment_likesInput>
  }

  export type PostLikesUpsertWithWhereUniqueWithoutNgoInput = {
    where: PostLikesWhereUniqueInput
    update: XOR<PostLikesUpdateWithoutNgoInput, PostLikesUncheckedUpdateWithoutNgoInput>
    create: XOR<PostLikesCreateWithoutNgoInput, PostLikesUncheckedCreateWithoutNgoInput>
  }

  export type PostLikesUpdateWithWhereUniqueWithoutNgoInput = {
    where: PostLikesWhereUniqueInput
    data: XOR<PostLikesUpdateWithoutNgoInput, PostLikesUncheckedUpdateWithoutNgoInput>
  }

  export type PostLikesUpdateManyWithWhereWithoutNgoInput = {
    where: PostLikesScalarWhereInput
    data: XOR<PostLikesUpdateManyMutationInput, PostLikesUncheckedUpdateManyWithoutPost_likesInput>
  }

  export type AttachedLinkUpsertWithWhereUniqueWithoutNgoInput = {
    where: AttachedLinkWhereUniqueInput
    update: XOR<AttachedLinkUpdateWithoutNgoInput, AttachedLinkUncheckedUpdateWithoutNgoInput>
    create: XOR<AttachedLinkCreateWithoutNgoInput, AttachedLinkUncheckedCreateWithoutNgoInput>
  }

  export type AttachedLinkUpdateWithWhereUniqueWithoutNgoInput = {
    where: AttachedLinkWhereUniqueInput
    data: XOR<AttachedLinkUpdateWithoutNgoInput, AttachedLinkUncheckedUpdateWithoutNgoInput>
  }

  export type AttachedLinkUpdateManyWithWhereWithoutNgoInput = {
    where: AttachedLinkScalarWhereInput
    data: XOR<AttachedLinkUpdateManyMutationInput, AttachedLinkUncheckedUpdateManyWithoutAttached_linkInput>
  }

  export type AddressCreateWithoutNgo_addressInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    campaign_address?: CampaignAddressCreateNestedManyWithoutAddressInput
    user_address?: UserAddressCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutNgo_addressInput = {
    id?: string
    postal_code: string
    number: string
    complement?: string | null
    campaign_address?: CampaignAddressUncheckedCreateNestedManyWithoutAddressInput
    user_address?: UserAddressUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutNgo_addressInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutNgo_addressInput, AddressUncheckedCreateWithoutNgo_addressInput>
  }

  export type NGOCreateWithoutNgo_addressInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutNgo_addressInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutNgo_addressInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutNgo_addressInput, NGOUncheckedCreateWithoutNgo_addressInput>
  }

  export type AddressUpsertWithoutNgo_addressInput = {
    update: XOR<AddressUpdateWithoutNgo_addressInput, AddressUncheckedUpdateWithoutNgo_addressInput>
    create: XOR<AddressCreateWithoutNgo_addressInput, AddressUncheckedCreateWithoutNgo_addressInput>
  }

  export type AddressUpdateWithoutNgo_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_address?: CampaignAddressUpdateManyWithoutAddressNestedInput
    user_address?: UserAddressUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutNgo_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_address?: CampaignAddressUncheckedUpdateManyWithoutAddressNestedInput
    user_address?: UserAddressUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type NGOUpsertWithoutNgo_addressInput = {
    update: XOR<NGOUpdateWithoutNgo_addressInput, NGOUncheckedUpdateWithoutNgo_addressInput>
    create: XOR<NGOCreateWithoutNgo_addressInput, NGOUncheckedCreateWithoutNgo_addressInput>
  }

  export type NGOUpdateWithoutNgo_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutNgo_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type CausesCreateWithoutNgo_causesInput = {
    id?: string
    title: string
    description?: string | null
    campaign_causes?: CampaignCausesCreateNestedManyWithoutCausesInput
  }

  export type CausesUncheckedCreateWithoutNgo_causesInput = {
    id?: string
    title: string
    description?: string | null
    campaign_causes?: CampaignCausesUncheckedCreateNestedManyWithoutCausesInput
  }

  export type CausesCreateOrConnectWithoutNgo_causesInput = {
    where: CausesWhereUniqueInput
    create: XOR<CausesCreateWithoutNgo_causesInput, CausesUncheckedCreateWithoutNgo_causesInput>
  }

  export type NGOCreateWithoutNgo_causesInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutNgo_causesInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutNgo_causesInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutNgo_causesInput, NGOUncheckedCreateWithoutNgo_causesInput>
  }

  export type CausesUpsertWithoutNgo_causesInput = {
    update: XOR<CausesUpdateWithoutNgo_causesInput, CausesUncheckedUpdateWithoutNgo_causesInput>
    create: XOR<CausesCreateWithoutNgo_causesInput, CausesUncheckedCreateWithoutNgo_causesInput>
  }

  export type CausesUpdateWithoutNgo_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_causes?: CampaignCausesUpdateManyWithoutCausesNestedInput
  }

  export type CausesUncheckedUpdateWithoutNgo_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCausesNestedInput
  }

  export type NGOUpsertWithoutNgo_causesInput = {
    update: XOR<NGOUpdateWithoutNgo_causesInput, NGOUncheckedUpdateWithoutNgo_causesInput>
    create: XOR<NGOCreateWithoutNgo_causesInput, NGOUncheckedCreateWithoutNgo_causesInput>
  }

  export type NGOUpdateWithoutNgo_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutNgo_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type NGOCreateWithoutNgo_phoneInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutNgo_phoneInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutNgo_phoneInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutNgo_phoneInput, NGOUncheckedCreateWithoutNgo_phoneInput>
  }

  export type PhoneCreateWithoutNgo_phoneInput = {
    id?: string
    number?: string | null
    user_phone?: UserPhoneCreateNestedManyWithoutPhoneInput
  }

  export type PhoneUncheckedCreateWithoutNgo_phoneInput = {
    id?: string
    number?: string | null
    user_phone?: UserPhoneUncheckedCreateNestedManyWithoutPhoneInput
  }

  export type PhoneCreateOrConnectWithoutNgo_phoneInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutNgo_phoneInput, PhoneUncheckedCreateWithoutNgo_phoneInput>
  }

  export type NGOUpsertWithoutNgo_phoneInput = {
    update: XOR<NGOUpdateWithoutNgo_phoneInput, NGOUncheckedUpdateWithoutNgo_phoneInput>
    create: XOR<NGOCreateWithoutNgo_phoneInput, NGOUncheckedCreateWithoutNgo_phoneInput>
  }

  export type NGOUpdateWithoutNgo_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutNgo_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type PhoneUpsertWithoutNgo_phoneInput = {
    update: XOR<PhoneUpdateWithoutNgo_phoneInput, PhoneUncheckedUpdateWithoutNgo_phoneInput>
    create: XOR<PhoneCreateWithoutNgo_phoneInput, PhoneUncheckedCreateWithoutNgo_phoneInput>
  }

  export type PhoneUpdateWithoutNgo_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone?: UserPhoneUpdateManyWithoutPhoneNestedInput
  }

  export type PhoneUncheckedUpdateWithoutNgo_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    user_phone?: UserPhoneUncheckedUpdateManyWithoutPhoneNestedInput
  }

  export type PhoneCreateWithoutUser_phoneInput = {
    id?: string
    number?: string | null
    ngo_phone?: NgoPhoneCreateNestedManyWithoutPhoneInput
  }

  export type PhoneUncheckedCreateWithoutUser_phoneInput = {
    id?: string
    number?: string | null
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutPhoneInput
  }

  export type PhoneCreateOrConnectWithoutUser_phoneInput = {
    where: PhoneWhereUniqueInput
    create: XOR<PhoneCreateWithoutUser_phoneInput, PhoneUncheckedCreateWithoutUser_phoneInput>
  }

  export type UserCreateWithoutUser_phoneInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_phoneInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_phoneInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_phoneInput, UserUncheckedCreateWithoutUser_phoneInput>
  }

  export type PhoneUpsertWithoutUser_phoneInput = {
    update: XOR<PhoneUpdateWithoutUser_phoneInput, PhoneUncheckedUpdateWithoutUser_phoneInput>
    create: XOR<PhoneCreateWithoutUser_phoneInput, PhoneUncheckedCreateWithoutUser_phoneInput>
  }

  export type PhoneUpdateWithoutUser_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_phone?: NgoPhoneUpdateManyWithoutPhoneNestedInput
  }

  export type PhoneUncheckedUpdateWithoutUser_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutPhoneNestedInput
  }

  export type UserUpsertWithoutUser_phoneInput = {
    update: XOR<UserUpdateWithoutUser_phoneInput, UserUncheckedUpdateWithoutUser_phoneInput>
    create: XOR<UserCreateWithoutUser_phoneInput, UserUncheckedCreateWithoutUser_phoneInput>
  }

  export type UserUpdateWithoutUser_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NGOCreateWithoutTypeInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutTypeInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutTypeInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutTypeInput, NGOUncheckedCreateWithoutTypeInput>
  }

  export type NGOCreateManyTypeInputEnvelope = {
    data: Enumerable<NGOCreateManyTypeInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTypeInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTypeInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTypeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTypeInput, UserUncheckedCreateWithoutTypeInput>
  }

  export type UserCreateManyTypeInputEnvelope = {
    data: Enumerable<UserCreateManyTypeInput>
    skipDuplicates?: boolean
  }

  export type NGOUpsertWithWhereUniqueWithoutTypeInput = {
    where: NGOWhereUniqueInput
    update: XOR<NGOUpdateWithoutTypeInput, NGOUncheckedUpdateWithoutTypeInput>
    create: XOR<NGOCreateWithoutTypeInput, NGOUncheckedCreateWithoutTypeInput>
  }

  export type NGOUpdateWithWhereUniqueWithoutTypeInput = {
    where: NGOWhereUniqueInput
    data: XOR<NGOUpdateWithoutTypeInput, NGOUncheckedUpdateWithoutTypeInput>
  }

  export type NGOUpdateManyWithWhereWithoutTypeInput = {
    where: NGOScalarWhereInput
    data: XOR<NGOUpdateManyMutationInput, NGOUncheckedUpdateManyWithoutNgoInput>
  }

  export type NGOScalarWhereInput = {
    AND?: Enumerable<NGOScalarWhereInput>
    OR?: Enumerable<NGOScalarWhereInput>
    NOT?: Enumerable<NGOScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    cnpj?: StringFilter | string
    foundation_date?: DateTimeNullableFilter | Date | string | null
    description?: StringNullableFilter | string | null
    email?: StringFilter | string
    password?: StringFilter | string
    id_type?: StringFilter | string
    photo_url?: StringFilter | string
    banner_photo?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutTypeInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTypeInput, UserUncheckedUpdateWithoutTypeInput>
    create: XOR<UserCreateWithoutTypeInput, UserUncheckedCreateWithoutTypeInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTypeInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTypeInput, UserUncheckedUpdateWithoutTypeInput>
  }

  export type UserUpdateManyWithWhereWithoutTypeInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    created_at?: Date | string
    comment_ngo?: CommentNgoCreateNestedManyWithoutCommentInput
    comment_user?: CommentUserCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    created_at?: Date | string
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutCommentInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: Enumerable<CommentCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type PostNgoCreateWithoutPostInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutPost_ngoInput
  }

  export type PostNgoUncheckedCreateWithoutPostInput = {
    id?: string
    id_ngo: string
  }

  export type PostNgoCreateOrConnectWithoutPostInput = {
    where: PostNgoWhereUniqueInput
    create: XOR<PostNgoCreateWithoutPostInput, PostNgoUncheckedCreateWithoutPostInput>
  }

  export type PostNgoCreateManyPostInputEnvelope = {
    data: Enumerable<PostNgoCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type PostPhotoCreateWithoutPostInput = {
    id?: string
    photo_url: string
  }

  export type PostPhotoUncheckedCreateWithoutPostInput = {
    id?: string
    photo_url: string
  }

  export type PostPhotoCreateOrConnectWithoutPostInput = {
    where: PostPhotoWhereUniqueInput
    create: XOR<PostPhotoCreateWithoutPostInput, PostPhotoUncheckedCreateWithoutPostInput>
  }

  export type PostPhotoCreateManyPostInputEnvelope = {
    data: Enumerable<PostPhotoCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type PostUserCreateWithoutPostInput = {
    id?: string
    user: UserCreateNestedOneWithoutPost_userInput
  }

  export type PostUserUncheckedCreateWithoutPostInput = {
    id?: string
    id_user: string
  }

  export type PostUserCreateOrConnectWithoutPostInput = {
    where: PostUserWhereUniqueInput
    create: XOR<PostUserCreateWithoutPostInput, PostUserUncheckedCreateWithoutPostInput>
  }

  export type PostUserCreateManyPostInputEnvelope = {
    data: Enumerable<PostUserCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type PostLikesCreateWithoutPostInput = {
    id?: string
    ngo?: NGOCreateNestedOneWithoutPost_likesInput
    user?: UserCreateNestedOneWithoutPost_likesInput
  }

  export type PostLikesUncheckedCreateWithoutPostInput = {
    id?: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type PostLikesCreateOrConnectWithoutPostInput = {
    where: PostLikesWhereUniqueInput
    create: XOR<PostLikesCreateWithoutPostInput, PostLikesUncheckedCreateWithoutPostInput>
  }

  export type PostLikesCreateManyPostInputEnvelope = {
    data: Enumerable<PostLikesCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    id?: StringFilter | string
    content?: StringFilter | string
    created_at?: DateTimeFilter | Date | string
    id_post?: StringFilter | string
  }

  export type PostNgoUpsertWithWhereUniqueWithoutPostInput = {
    where: PostNgoWhereUniqueInput
    update: XOR<PostNgoUpdateWithoutPostInput, PostNgoUncheckedUpdateWithoutPostInput>
    create: XOR<PostNgoCreateWithoutPostInput, PostNgoUncheckedCreateWithoutPostInput>
  }

  export type PostNgoUpdateWithWhereUniqueWithoutPostInput = {
    where: PostNgoWhereUniqueInput
    data: XOR<PostNgoUpdateWithoutPostInput, PostNgoUncheckedUpdateWithoutPostInput>
  }

  export type PostNgoUpdateManyWithWhereWithoutPostInput = {
    where: PostNgoScalarWhereInput
    data: XOR<PostNgoUpdateManyMutationInput, PostNgoUncheckedUpdateManyWithoutPost_ngoInput>
  }

  export type PostPhotoUpsertWithWhereUniqueWithoutPostInput = {
    where: PostPhotoWhereUniqueInput
    update: XOR<PostPhotoUpdateWithoutPostInput, PostPhotoUncheckedUpdateWithoutPostInput>
    create: XOR<PostPhotoCreateWithoutPostInput, PostPhotoUncheckedCreateWithoutPostInput>
  }

  export type PostPhotoUpdateWithWhereUniqueWithoutPostInput = {
    where: PostPhotoWhereUniqueInput
    data: XOR<PostPhotoUpdateWithoutPostInput, PostPhotoUncheckedUpdateWithoutPostInput>
  }

  export type PostPhotoUpdateManyWithWhereWithoutPostInput = {
    where: PostPhotoScalarWhereInput
    data: XOR<PostPhotoUpdateManyMutationInput, PostPhotoUncheckedUpdateManyWithoutPost_photoInput>
  }

  export type PostPhotoScalarWhereInput = {
    AND?: Enumerable<PostPhotoScalarWhereInput>
    OR?: Enumerable<PostPhotoScalarWhereInput>
    NOT?: Enumerable<PostPhotoScalarWhereInput>
    id?: StringFilter | string
    id_post?: StringFilter | string
    photo_url?: StringFilter | string
  }

  export type PostUserUpsertWithWhereUniqueWithoutPostInput = {
    where: PostUserWhereUniqueInput
    update: XOR<PostUserUpdateWithoutPostInput, PostUserUncheckedUpdateWithoutPostInput>
    create: XOR<PostUserCreateWithoutPostInput, PostUserUncheckedCreateWithoutPostInput>
  }

  export type PostUserUpdateWithWhereUniqueWithoutPostInput = {
    where: PostUserWhereUniqueInput
    data: XOR<PostUserUpdateWithoutPostInput, PostUserUncheckedUpdateWithoutPostInput>
  }

  export type PostUserUpdateManyWithWhereWithoutPostInput = {
    where: PostUserScalarWhereInput
    data: XOR<PostUserUpdateManyMutationInput, PostUserUncheckedUpdateManyWithoutPost_userInput>
  }

  export type PostLikesUpsertWithWhereUniqueWithoutPostInput = {
    where: PostLikesWhereUniqueInput
    update: XOR<PostLikesUpdateWithoutPostInput, PostLikesUncheckedUpdateWithoutPostInput>
    create: XOR<PostLikesCreateWithoutPostInput, PostLikesUncheckedCreateWithoutPostInput>
  }

  export type PostLikesUpdateWithWhereUniqueWithoutPostInput = {
    where: PostLikesWhereUniqueInput
    data: XOR<PostLikesUpdateWithoutPostInput, PostLikesUncheckedUpdateWithoutPostInput>
  }

  export type PostLikesUpdateManyWithWhereWithoutPostInput = {
    where: PostLikesScalarWhereInput
    data: XOR<PostLikesUpdateManyMutationInput, PostLikesUncheckedUpdateManyWithoutPost_likesInput>
  }

  export type PostCreateWithoutPost_photoInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoCreateNestedManyWithoutPostInput
    post_user?: PostUserCreateNestedManyWithoutPostInput
    post_likes?: PostLikesCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPost_photoInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutPostInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutPostInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPost_photoInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPost_photoInput, PostUncheckedCreateWithoutPost_photoInput>
  }

  export type PostUpsertWithoutPost_photoInput = {
    update: XOR<PostUpdateWithoutPost_photoInput, PostUncheckedUpdateWithoutPost_photoInput>
    create: XOR<PostCreateWithoutPost_photoInput, PostUncheckedCreateWithoutPost_photoInput>
  }

  export type PostUpdateWithoutPost_photoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUpdateManyWithoutPostNestedInput
    post_user?: PostUserUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPost_photoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutPostNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type NGOCreateWithoutPost_ngoInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutPost_ngoInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutPost_ngoInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutPost_ngoInput, NGOUncheckedCreateWithoutPost_ngoInput>
  }

  export type PostCreateWithoutPost_ngoInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoCreateNestedManyWithoutPostInput
    post_user?: PostUserCreateNestedManyWithoutPostInput
    post_likes?: PostLikesCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPost_ngoInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoUncheckedCreateNestedManyWithoutPostInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutPostInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPost_ngoInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPost_ngoInput, PostUncheckedCreateWithoutPost_ngoInput>
  }

  export type NGOUpsertWithoutPost_ngoInput = {
    update: XOR<NGOUpdateWithoutPost_ngoInput, NGOUncheckedUpdateWithoutPost_ngoInput>
    create: XOR<NGOCreateWithoutPost_ngoInput, NGOUncheckedCreateWithoutPost_ngoInput>
  }

  export type NGOUpdateWithoutPost_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutPost_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type PostUpsertWithoutPost_ngoInput = {
    update: XOR<PostUpdateWithoutPost_ngoInput, PostUncheckedUpdateWithoutPost_ngoInput>
    create: XOR<PostCreateWithoutPost_ngoInput, PostUncheckedCreateWithoutPost_ngoInput>
  }

  export type PostUpdateWithoutPost_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUpdateManyWithoutPostNestedInput
    post_user?: PostUserUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPost_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUncheckedUpdateManyWithoutPostNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutPost_userInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoCreateNestedManyWithoutPostInput
    post_likes?: PostLikesCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPost_userInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoUncheckedCreateNestedManyWithoutPostInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPost_userInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPost_userInput, PostUncheckedCreateWithoutPost_userInput>
  }

  export type UserCreateWithoutPost_userInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPost_userInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPost_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPost_userInput, UserUncheckedCreateWithoutPost_userInput>
  }

  export type PostUpsertWithoutPost_userInput = {
    update: XOR<PostUpdateWithoutPost_userInput, PostUncheckedUpdateWithoutPost_userInput>
    create: XOR<PostCreateWithoutPost_userInput, PostUncheckedCreateWithoutPost_userInput>
  }

  export type PostUpdateWithoutPost_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPost_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUncheckedUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutPost_userInput = {
    update: XOR<UserUpdateWithoutPost_userInput, UserUncheckedUpdateWithoutPost_userInput>
    create: XOR<UserCreateWithoutPost_userInput, UserUncheckedCreateWithoutPost_userInput>
  }

  export type UserUpdateWithoutPost_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPost_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCreateWithoutCommentInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    post_ngo?: PostNgoCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoCreateNestedManyWithoutPostInput
    post_user?: PostUserCreateNestedManyWithoutPostInput
    post_likes?: PostLikesCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoUncheckedCreateNestedManyWithoutPostInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutPostInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
  }

  export type CommentNgoCreateWithoutCommentInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutComment_ngoInput
  }

  export type CommentNgoUncheckedCreateWithoutCommentInput = {
    id?: string
    id_ngo: string
  }

  export type CommentNgoCreateOrConnectWithoutCommentInput = {
    where: CommentNgoWhereUniqueInput
    create: XOR<CommentNgoCreateWithoutCommentInput, CommentNgoUncheckedCreateWithoutCommentInput>
  }

  export type CommentNgoCreateManyCommentInputEnvelope = {
    data: Enumerable<CommentNgoCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type CommentUserCreateWithoutCommentInput = {
    id?: string
    user: UserCreateNestedOneWithoutComment_userInput
  }

  export type CommentUserUncheckedCreateWithoutCommentInput = {
    id?: string
    id_user: string
  }

  export type CommentUserCreateOrConnectWithoutCommentInput = {
    where: CommentUserWhereUniqueInput
    create: XOR<CommentUserCreateWithoutCommentInput, CommentUserUncheckedCreateWithoutCommentInput>
  }

  export type CommentUserCreateManyCommentInputEnvelope = {
    data: Enumerable<CommentUserCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type CommentLikesCreateWithoutCommentInput = {
    id?: string
    ngo?: NGOCreateNestedOneWithoutComment_likesInput
    user?: UserCreateNestedOneWithoutComment_likesInput
  }

  export type CommentLikesUncheckedCreateWithoutCommentInput = {
    id?: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type CommentLikesCreateOrConnectWithoutCommentInput = {
    where: CommentLikesWhereUniqueInput
    create: XOR<CommentLikesCreateWithoutCommentInput, CommentLikesUncheckedCreateWithoutCommentInput>
  }

  export type CommentLikesCreateManyCommentInputEnvelope = {
    data: Enumerable<CommentLikesCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentInput = {
    update: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
  }

  export type PostUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_ngo?: PostNgoUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUpdateManyWithoutPostNestedInput
    post_user?: PostUserUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_ngo?: PostNgoUncheckedUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUncheckedUpdateManyWithoutPostNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutPostNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentNgoUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentNgoWhereUniqueInput
    update: XOR<CommentNgoUpdateWithoutCommentInput, CommentNgoUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentNgoCreateWithoutCommentInput, CommentNgoUncheckedCreateWithoutCommentInput>
  }

  export type CommentNgoUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentNgoWhereUniqueInput
    data: XOR<CommentNgoUpdateWithoutCommentInput, CommentNgoUncheckedUpdateWithoutCommentInput>
  }

  export type CommentNgoUpdateManyWithWhereWithoutCommentInput = {
    where: CommentNgoScalarWhereInput
    data: XOR<CommentNgoUpdateManyMutationInput, CommentNgoUncheckedUpdateManyWithoutComment_ngoInput>
  }

  export type CommentUserUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentUserWhereUniqueInput
    update: XOR<CommentUserUpdateWithoutCommentInput, CommentUserUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentUserCreateWithoutCommentInput, CommentUserUncheckedCreateWithoutCommentInput>
  }

  export type CommentUserUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentUserWhereUniqueInput
    data: XOR<CommentUserUpdateWithoutCommentInput, CommentUserUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUserUpdateManyWithWhereWithoutCommentInput = {
    where: CommentUserScalarWhereInput
    data: XOR<CommentUserUpdateManyMutationInput, CommentUserUncheckedUpdateManyWithoutComment_userInput>
  }

  export type CommentLikesUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentLikesWhereUniqueInput
    update: XOR<CommentLikesUpdateWithoutCommentInput, CommentLikesUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentLikesCreateWithoutCommentInput, CommentLikesUncheckedCreateWithoutCommentInput>
  }

  export type CommentLikesUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentLikesWhereUniqueInput
    data: XOR<CommentLikesUpdateWithoutCommentInput, CommentLikesUncheckedUpdateWithoutCommentInput>
  }

  export type CommentLikesUpdateManyWithWhereWithoutCommentInput = {
    where: CommentLikesScalarWhereInput
    data: XOR<CommentLikesUpdateManyMutationInput, CommentLikesUncheckedUpdateManyWithoutComment_likesInput>
  }

  export type CommentCreateWithoutComment_userInput = {
    id?: string
    content: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutCommentInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutComment_userInput = {
    id?: string
    content: string
    created_at?: Date | string
    id_post: string
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutComment_userInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutComment_userInput, CommentUncheckedCreateWithoutComment_userInput>
  }

  export type UserCreateWithoutComment_userInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComment_userInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComment_userInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComment_userInput, UserUncheckedCreateWithoutComment_userInput>
  }

  export type CommentUpsertWithoutComment_userInput = {
    update: XOR<CommentUpdateWithoutComment_userInput, CommentUncheckedUpdateWithoutComment_userInput>
    create: XOR<CommentCreateWithoutComment_userInput, CommentUncheckedCreateWithoutComment_userInput>
  }

  export type CommentUpdateWithoutComment_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutComment_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_post?: StringFieldUpdateOperationsInput | string
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutComment_userInput = {
    update: XOR<UserUpdateWithoutComment_userInput, UserUncheckedUpdateWithoutComment_userInput>
    create: XOR<UserCreateWithoutComment_userInput, UserUncheckedCreateWithoutComment_userInput>
  }

  export type UserUpdateWithoutComment_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComment_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutComment_ngoInput = {
    id?: string
    content: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutCommentInput
    comment_user?: CommentUserCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutComment_ngoInput = {
    id?: string
    content: string
    created_at?: Date | string
    id_post: string
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutCommentInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutComment_ngoInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutComment_ngoInput, CommentUncheckedCreateWithoutComment_ngoInput>
  }

  export type NGOCreateWithoutComment_ngoInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutComment_ngoInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutComment_ngoInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutComment_ngoInput, NGOUncheckedCreateWithoutComment_ngoInput>
  }

  export type CommentUpsertWithoutComment_ngoInput = {
    update: XOR<CommentUpdateWithoutComment_ngoInput, CommentUncheckedUpdateWithoutComment_ngoInput>
    create: XOR<CommentCreateWithoutComment_ngoInput, CommentUncheckedCreateWithoutComment_ngoInput>
  }

  export type CommentUpdateWithoutComment_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentNestedInput
    comment_user?: CommentUserUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutComment_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_post?: StringFieldUpdateOperationsInput | string
    comment_user?: CommentUserUncheckedUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type NGOUpsertWithoutComment_ngoInput = {
    update: XOR<NGOUpdateWithoutComment_ngoInput, NGOUncheckedUpdateWithoutComment_ngoInput>
    create: XOR<NGOCreateWithoutComment_ngoInput, NGOUncheckedCreateWithoutComment_ngoInput>
  }

  export type NGOUpdateWithoutComment_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutComment_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type NGOCreateWithoutComment_likesInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutComment_likesInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutComment_likesInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutComment_likesInput, NGOUncheckedCreateWithoutComment_likesInput>
  }

  export type UserCreateWithoutComment_likesInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComment_likesInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComment_likesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComment_likesInput, UserUncheckedCreateWithoutComment_likesInput>
  }

  export type CommentCreateWithoutComment_likesInput = {
    id?: string
    content: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutCommentInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutCommentInput
    comment_user?: CommentUserCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutComment_likesInput = {
    id?: string
    content: string
    created_at?: Date | string
    id_post: string
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutCommentInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutComment_likesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutComment_likesInput, CommentUncheckedCreateWithoutComment_likesInput>
  }

  export type NGOUpsertWithoutComment_likesInput = {
    update: XOR<NGOUpdateWithoutComment_likesInput, NGOUncheckedUpdateWithoutComment_likesInput>
    create: XOR<NGOCreateWithoutComment_likesInput, NGOUncheckedCreateWithoutComment_likesInput>
  }

  export type NGOUpdateWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type UserUpsertWithoutComment_likesInput = {
    update: XOR<UserUpdateWithoutComment_likesInput, UserUncheckedUpdateWithoutComment_likesInput>
    create: XOR<UserCreateWithoutComment_likesInput, UserUncheckedCreateWithoutComment_likesInput>
  }

  export type UserUpdateWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutComment_likesInput = {
    update: XOR<CommentUpdateWithoutComment_likesInput, CommentUncheckedUpdateWithoutComment_likesInput>
    create: XOR<CommentCreateWithoutComment_likesInput, CommentUncheckedCreateWithoutComment_likesInput>
  }

  export type CommentUpdateWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutCommentNestedInput
    comment_user?: CommentUserUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_post?: StringFieldUpdateOperationsInput | string
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutCommentNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type NGOCreateWithoutPost_likesInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutPost_likesInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutPost_likesInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutPost_likesInput, NGOUncheckedCreateWithoutPost_likesInput>
  }

  export type UserCreateWithoutPost_likesInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPost_likesInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    attached_link?: AttachedLinkUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPost_likesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPost_likesInput, UserUncheckedCreateWithoutPost_likesInput>
  }

  export type PostCreateWithoutPost_likesInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoCreateNestedManyWithoutPostInput
    post_user?: PostUserCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPost_likesInput = {
    id?: string
    content?: string | null
    created_at?: Date | string
    comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutPostInput
    post_photo?: PostPhotoUncheckedCreateNestedManyWithoutPostInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPost_likesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPost_likesInput, PostUncheckedCreateWithoutPost_likesInput>
  }

  export type NGOUpsertWithoutPost_likesInput = {
    update: XOR<NGOUpdateWithoutPost_likesInput, NGOUncheckedUpdateWithoutPost_likesInput>
    create: XOR<NGOCreateWithoutPost_likesInput, NGOUncheckedCreateWithoutPost_likesInput>
  }

  export type NGOUpdateWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type UserUpsertWithoutPost_likesInput = {
    update: XOR<UserUpdateWithoutPost_likesInput, UserUncheckedUpdateWithoutPost_likesInput>
    create: XOR<UserCreateWithoutPost_likesInput, UserUncheckedCreateWithoutPost_likesInput>
  }

  export type UserUpdateWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostUpsertWithoutPost_likesInput = {
    update: XOR<PostUpdateWithoutPost_likesInput, PostUncheckedUpdateWithoutPost_likesInput>
    create: XOR<PostCreateWithoutPost_likesInput, PostUncheckedCreateWithoutPost_likesInput>
  }

  export type PostUpdateWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUpdateManyWithoutPostNestedInput
    post_user?: PostUserUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutPostNestedInput
    post_photo?: PostPhotoUncheckedUpdateManyWithoutPostNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutPostNestedInput
  }

  export type SourceCreateWithoutAttached_linkInput = {
    id?: string
    name: string
  }

  export type SourceUncheckedCreateWithoutAttached_linkInput = {
    id?: string
    name: string
  }

  export type SourceCreateOrConnectWithoutAttached_linkInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutAttached_linkInput, SourceUncheckedCreateWithoutAttached_linkInput>
  }

  export type UserCreateWithoutAttached_linkInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsCreateNestedManyWithoutUserInput
    comment_user?: CommentUserCreateNestedManyWithoutUserInput
    following?: FollowingCreateNestedManyWithoutUserInput
    post_user?: PostUserCreateNestedManyWithoutUserInput
    gender: GenderCreateNestedOneWithoutUserInput
    type: TypeCreateNestedOneWithoutUserInput
    user_address?: UserAddressCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesCreateNestedManyWithoutUserInput
    post_likes?: PostLikesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttached_linkInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
    supported_campaigns?: CampaignParticipantsUncheckedCreateNestedManyWithoutUserInput
    comment_user?: CommentUserUncheckedCreateNestedManyWithoutUserInput
    following?: FollowingUncheckedCreateNestedManyWithoutUserInput
    post_user?: PostUserUncheckedCreateNestedManyWithoutUserInput
    user_address?: UserAddressUncheckedCreateNestedOneWithoutUserInput
    user_phone?: UserPhoneUncheckedCreateNestedOneWithoutUserInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutUserInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttached_linkInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttached_linkInput, UserUncheckedCreateWithoutAttached_linkInput>
  }

  export type NGOCreateWithoutAttached_linkInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoCreateNestedManyWithoutNgoInput
    following?: FollowingCreateNestedManyWithoutNgoInput
    type: TypeCreateNestedOneWithoutNgoInput
    ngo_address?: NgoAddressCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesCreateNestedManyWithoutNgoInput
  }

  export type NGOUncheckedCreateWithoutAttached_linkInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    id_type: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
    campaign?: CampaignUncheckedCreateNestedManyWithoutNgoInput
    comment_ngo?: CommentNgoUncheckedCreateNestedManyWithoutNgoInput
    following?: FollowingUncheckedCreateNestedManyWithoutNgoInput
    ngo_address?: NgoAddressUncheckedCreateNestedOneWithoutNgoInput
    ngo_causes?: NgoCausesUncheckedCreateNestedManyWithoutNgoInput
    ngo_phone?: NgoPhoneUncheckedCreateNestedManyWithoutNgoInput
    post_ngo?: PostNgoUncheckedCreateNestedManyWithoutNgoInput
    comment_likes?: CommentLikesUncheckedCreateNestedManyWithoutNgoInput
    post_likes?: PostLikesUncheckedCreateNestedManyWithoutNgoInput
  }

  export type NGOCreateOrConnectWithoutAttached_linkInput = {
    where: NGOWhereUniqueInput
    create: XOR<NGOCreateWithoutAttached_linkInput, NGOUncheckedCreateWithoutAttached_linkInput>
  }

  export type SourceUpsertWithoutAttached_linkInput = {
    update: XOR<SourceUpdateWithoutAttached_linkInput, SourceUncheckedUpdateWithoutAttached_linkInput>
    create: XOR<SourceCreateWithoutAttached_linkInput, SourceUncheckedCreateWithoutAttached_linkInput>
  }

  export type SourceUpdateWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutAttached_linkInput = {
    update: XOR<UserUpdateWithoutAttached_linkInput, UserUncheckedUpdateWithoutAttached_linkInput>
    create: XOR<UserCreateWithoutAttached_linkInput, UserUncheckedCreateWithoutAttached_linkInput>
  }

  export type UserUpdateWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NGOUpsertWithoutAttached_linkInput = {
    update: XOR<NGOUpdateWithoutAttached_linkInput, NGOUncheckedUpdateWithoutAttached_linkInput>
    create: XOR<NGOCreateWithoutAttached_linkInput, NGOUncheckedCreateWithoutAttached_linkInput>
  }

  export type NGOUpdateWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    type?: TypeUpdateOneRequiredWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    id_type?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type AttachedLinkCreateWithoutSourceInput = {
    id?: string
    attached_link: string
    user?: UserCreateNestedOneWithoutAttached_linkInput
    ngo?: NGOCreateNestedOneWithoutAttached_linkInput
  }

  export type AttachedLinkUncheckedCreateWithoutSourceInput = {
    id?: string
    attached_link: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type AttachedLinkCreateOrConnectWithoutSourceInput = {
    where: AttachedLinkWhereUniqueInput
    create: XOR<AttachedLinkCreateWithoutSourceInput, AttachedLinkUncheckedCreateWithoutSourceInput>
  }

  export type AttachedLinkCreateManySourceInputEnvelope = {
    data: Enumerable<AttachedLinkCreateManySourceInput>
    skipDuplicates?: boolean
  }

  export type AttachedLinkUpsertWithWhereUniqueWithoutSourceInput = {
    where: AttachedLinkWhereUniqueInput
    update: XOR<AttachedLinkUpdateWithoutSourceInput, AttachedLinkUncheckedUpdateWithoutSourceInput>
    create: XOR<AttachedLinkCreateWithoutSourceInput, AttachedLinkUncheckedCreateWithoutSourceInput>
  }

  export type AttachedLinkUpdateWithWhereUniqueWithoutSourceInput = {
    where: AttachedLinkWhereUniqueInput
    data: XOR<AttachedLinkUpdateWithoutSourceInput, AttachedLinkUncheckedUpdateWithoutSourceInput>
  }

  export type AttachedLinkUpdateManyWithWhereWithoutSourceInput = {
    where: AttachedLinkScalarWhereInput
    data: XOR<AttachedLinkUpdateManyMutationInput, AttachedLinkUncheckedUpdateManyWithoutAttached_linkInput>
  }

  export type CampaignParticipantsCreateWithoutStatusInput = {
    id?: string
    campaign: CampaignCreateNestedOneWithoutCampaign_participantsInput
    user: UserCreateNestedOneWithoutSupported_campaignsInput
  }

  export type CampaignParticipantsUncheckedCreateWithoutStatusInput = {
    id?: string
    id_campaign: string
    id_user: string
  }

  export type CampaignParticipantsCreateOrConnectWithoutStatusInput = {
    where: CampaignParticipantsWhereUniqueInput
    create: XOR<CampaignParticipantsCreateWithoutStatusInput, CampaignParticipantsUncheckedCreateWithoutStatusInput>
  }

  export type CampaignParticipantsCreateManyStatusInputEnvelope = {
    data: Enumerable<CampaignParticipantsCreateManyStatusInput>
    skipDuplicates?: boolean
  }

  export type FollowingCreateWithoutStatusInput = {
    id?: string
    ngo: NGOCreateNestedOneWithoutFollowingInput
    user: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowingUncheckedCreateWithoutStatusInput = {
    id?: string
    id_user: string
    id_ngo: string
  }

  export type FollowingCreateOrConnectWithoutStatusInput = {
    where: FollowingWhereUniqueInput
    create: XOR<FollowingCreateWithoutStatusInput, FollowingUncheckedCreateWithoutStatusInput>
  }

  export type FollowingCreateManyStatusInputEnvelope = {
    data: Enumerable<FollowingCreateManyStatusInput>
    skipDuplicates?: boolean
  }

  export type CampaignParticipantsUpsertWithWhereUniqueWithoutStatusInput = {
    where: CampaignParticipantsWhereUniqueInput
    update: XOR<CampaignParticipantsUpdateWithoutStatusInput, CampaignParticipantsUncheckedUpdateWithoutStatusInput>
    create: XOR<CampaignParticipantsCreateWithoutStatusInput, CampaignParticipantsUncheckedCreateWithoutStatusInput>
  }

  export type CampaignParticipantsUpdateWithWhereUniqueWithoutStatusInput = {
    where: CampaignParticipantsWhereUniqueInput
    data: XOR<CampaignParticipantsUpdateWithoutStatusInput, CampaignParticipantsUncheckedUpdateWithoutStatusInput>
  }

  export type CampaignParticipantsUpdateManyWithWhereWithoutStatusInput = {
    where: CampaignParticipantsScalarWhereInput
    data: XOR<CampaignParticipantsUpdateManyMutationInput, CampaignParticipantsUncheckedUpdateManyWithoutCampaignParticipantsInput>
  }

  export type FollowingUpsertWithWhereUniqueWithoutStatusInput = {
    where: FollowingWhereUniqueInput
    update: XOR<FollowingUpdateWithoutStatusInput, FollowingUncheckedUpdateWithoutStatusInput>
    create: XOR<FollowingCreateWithoutStatusInput, FollowingUncheckedCreateWithoutStatusInput>
  }

  export type FollowingUpdateWithWhereUniqueWithoutStatusInput = {
    where: FollowingWhereUniqueInput
    data: XOR<FollowingUpdateWithoutStatusInput, FollowingUncheckedUpdateWithoutStatusInput>
  }

  export type FollowingUpdateManyWithWhereWithoutStatusInput = {
    where: FollowingScalarWhereInput
    data: XOR<FollowingUpdateManyMutationInput, FollowingUncheckedUpdateManyWithoutFollowingInput>
  }

  export type CampaignParticipantsCreateManyUserInput = {
    id?: string
    id_campaign: string
    id_status: string
  }

  export type CommentUserCreateManyUserInput = {
    id?: string
    id_comment: string
  }

  export type FollowingCreateManyUserInput = {
    id?: string
    id_ngo: string
    id_status: string
  }

  export type PostUserCreateManyUserInput = {
    id?: string
    id_post: string
  }

  export type CommentLikesCreateManyUserInput = {
    id?: string
    id_comment: string
    id_ngo?: string | null
  }

  export type PostLikesCreateManyUserInput = {
    id?: string
    id_ngo?: string | null
    id_post: string
  }

  export type AttachedLinkCreateManyUserInput = {
    id?: string
    attached_link: string
    id_source: string
    id_ngo?: string | null
  }

  export type CampaignParticipantsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_participantsNestedInput
    status?: StatusUpdateOneRequiredWithoutCampaignParticipantsNestedInput
  }

  export type CampaignParticipantsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsUncheckedUpdateManyWithoutSupported_campaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: CommentUpdateOneRequiredWithoutComment_userNestedInput
  }

  export type CommentUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUserUncheckedUpdateManyWithoutComment_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FollowingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StatusUpdateOneRequiredWithoutFollowingNestedInput
    ngo?: NGOUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type FollowingUncheckedUpdateManyWithoutFollowingInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type PostUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutPost_userNestedInput
  }

  export type PostUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type PostUserUncheckedUpdateManyWithoutPost_userInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneWithoutComment_likesNestedInput
    comment?: CommentUpdateOneRequiredWithoutComment_likesNestedInput
  }

  export type CommentLikesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentLikesUncheckedUpdateManyWithoutComment_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostLikesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneWithoutPost_likesNestedInput
    post?: PostUpdateOneRequiredWithoutPost_likesNestedInput
  }

  export type PostLikesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikesUncheckedUpdateManyWithoutPost_likesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type AttachedLinkUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    source?: SourceUpdateOneRequiredWithoutAttached_linkNestedInput
    ngo?: NGOUpdateOneWithoutAttached_linkNestedInput
  }

  export type AttachedLinkUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    id_source?: StringFieldUpdateOperationsInput | string
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachedLinkUncheckedUpdateManyWithoutAttached_linkInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    id_source?: StringFieldUpdateOperationsInput | string
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyGenderInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    birthdate: Date | string
    rg?: string | null
    id_type: string
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
  }

  export type UserUpdateWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    type?: TypeUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    id_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NgoPhoneCreateManyPhoneInput = {
    id?: string
    id_ngo: string
  }

  export type UserPhoneCreateManyPhoneInput = {
    id?: string
    id_user: string
  }

  export type NgoPhoneUpdateWithoutPhoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutNgo_phoneNestedInput
  }

  export type NgoPhoneUncheckedUpdateWithoutPhoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type NgoPhoneUncheckedUpdateManyWithoutNgo_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type UserPhoneUpdateWithoutPhoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUser_phoneNestedInput
  }

  export type UserPhoneUncheckedUpdateWithoutPhoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserPhoneUncheckedUpdateManyWithoutUser_phoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignAddressCreateManyAddressInput = {
    id?: string
    id_campaign: string
  }

  export type NgoAddressCreateManyAddressInput = {
    id?: string
    id_ngo: string
  }

  export type UserAddressCreateManyAddressInput = {
    id?: string
    id_user: string
  }

  export type CampaignAddressUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_addressNestedInput
  }

  export type CampaignAddressUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignAddressUncheckedUpdateManyWithoutCampaign_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type NgoAddressUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutNgo_addressNestedInput
  }

  export type NgoAddressUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type NgoAddressUncheckedUpdateManyWithoutNgo_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUser_addressNestedInput
  }

  export type UserAddressUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserAddressUncheckedUpdateManyWithoutUser_addressInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesCreateManyCampaignInput = {
    id?: string
    id_cause: string
  }

  export type CampaignParticipantsCreateManyCampaignInput = {
    id?: string
    id_user: string
    id_status: string
  }

  export type CampaignPhotosCreateManyCampaignInput = {
    id?: string
    photo_url: string
  }

  export type CampaignCausesUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    causes?: CausesUpdateOneRequiredWithoutCampaign_causesNestedInput
  }

  export type CampaignCausesUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_cause?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesUncheckedUpdateManyWithoutCampaign_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_cause?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutSupported_campaignsNestedInput
    status?: StatusUpdateOneRequiredWithoutCampaignParticipantsNestedInput
  }

  export type CampaignParticipantsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsUncheckedUpdateManyWithoutCampaign_participantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignPhotosUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignPhotosUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignPhotosUncheckedUpdateManyWithoutCampaign_photosInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCausesCreateManyCausesInput = {
    id?: string
    id_campaign: string
  }

  export type NgoCausesCreateManyCausesInput = {
    id?: string
    id_ngo: string
  }

  export type CampaignCausesUpdateWithoutCausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_causesNestedInput
  }

  export type CampaignCausesUncheckedUpdateWithoutCausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesUpdateWithoutCausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutNgo_causesNestedInput
  }

  export type NgoCausesUncheckedUpdateWithoutCausesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesUncheckedUpdateManyWithoutNgo_causesInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignCreateManyNgoInput = {
    id?: string
    title: string
    description?: string | null
    begin_date: Date | string
    end_date: Date | string
    home_office?: boolean
    how_to_contribute: string
    prerequisites: string
    created_at?: Date | string
    is_active?: boolean
  }

  export type CommentNgoCreateManyNgoInput = {
    id?: string
    id_comment: string
  }

  export type FollowingCreateManyNgoInput = {
    id?: string
    id_user: string
    id_status: string
  }

  export type NgoCausesCreateManyNgoInput = {
    id?: string
    id_causes: string
  }

  export type NgoPhoneCreateManyNgoInput = {
    id?: string
    id_phone: string
  }

  export type PostNgoCreateManyNgoInput = {
    id?: string
    id_post: string
  }

  export type CommentLikesCreateManyNgoInput = {
    id?: string
    id_comment: string
    id_user?: string | null
  }

  export type PostLikesCreateManyNgoInput = {
    id?: string
    id_user?: string | null
    id_post: string
  }

  export type AttachedLinkCreateManyNgoInput = {
    id?: string
    attached_link: string
    id_source: string
    id_user?: string | null
  }

  export type CampaignUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_address?: CampaignAddressUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    campaign_address?: CampaignAddressUncheckedUpdateOneWithoutCampaignNestedInput
    campaign_causes?: CampaignCausesUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_participants?: CampaignParticipantsUncheckedUpdateManyWithoutCampaignNestedInput
    campaign_photos?: CampaignPhotosUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    begin_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    home_office?: BoolFieldUpdateOperationsInput | boolean
    how_to_contribute?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentNgoUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: CommentUpdateOneRequiredWithoutComment_ngoNestedInput
  }

  export type CommentNgoUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
  }

  export type CommentNgoUncheckedUpdateManyWithoutComment_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
  }

  export type FollowingUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StatusUpdateOneRequiredWithoutFollowingNestedInput
    user?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowingUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_status?: StringFieldUpdateOperationsInput | string
  }

  export type NgoCausesUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    causes?: CausesUpdateOneRequiredWithoutNgo_causesNestedInput
  }

  export type NgoCausesUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_causes?: StringFieldUpdateOperationsInput | string
  }

  export type NgoPhoneUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: PhoneUpdateOneRequiredWithoutNgo_phoneNestedInput
  }

  export type NgoPhoneUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_phone?: StringFieldUpdateOperationsInput | string
  }

  export type PostNgoUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: PostUpdateOneRequiredWithoutPost_ngoNestedInput
  }

  export type PostNgoUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type PostNgoUncheckedUpdateManyWithoutPost_ngoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikesUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutComment_likesNestedInput
    comment?: CommentUpdateOneRequiredWithoutComment_likesNestedInput
  }

  export type CommentLikesUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_comment?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostLikesUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutPost_likesNestedInput
    post?: PostUpdateOneRequiredWithoutPost_likesNestedInput
  }

  export type PostLikesUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_post?: StringFieldUpdateOperationsInput | string
  }

  export type AttachedLinkUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    source?: SourceUpdateOneRequiredWithoutAttached_linkNestedInput
    user?: UserUpdateOneWithoutAttached_linkNestedInput
  }

  export type AttachedLinkUncheckedUpdateWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    id_source?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NGOCreateManyTypeInput = {
    id?: string
    name: string
    cnpj: string
    foundation_date?: Date | string | null
    description?: string | null
    email: string
    password: string
    photo_url?: string
    banner_photo?: string
    created_at?: Date | string
  }

  export type UserCreateManyTypeInput = {
    id?: string
    name: string
    email: string
    password: string
    cpf: string
    id_gender: string
    birthdate: Date | string
    rg?: string | null
    description?: string | null
    banner_photo?: string
    photo_url?: string
    created_at?: Date | string
  }

  export type NGOUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUpdateManyWithoutNgoNestedInput
    following?: FollowingUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUncheckedUpdateManyWithoutNgoNestedInput
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutNgoNestedInput
    following?: FollowingUncheckedUpdateManyWithoutNgoNestedInput
    ngo_address?: NgoAddressUncheckedUpdateOneWithoutNgoNestedInput
    ngo_causes?: NgoCausesUncheckedUpdateManyWithoutNgoNestedInput
    ngo_phone?: NgoPhoneUncheckedUpdateManyWithoutNgoNestedInput
    post_ngo?: PostNgoUncheckedUpdateManyWithoutNgoNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutNgoNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutNgoNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutNgoNestedInput
  }

  export type NGOUncheckedUpdateManyWithoutNgoInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    cnpj?: StringFieldUpdateOperationsInput | string
    foundation_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    banner_photo?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUpdateManyWithoutUserNestedInput
    following?: FollowingUpdateManyWithoutUserNestedInput
    post_user?: PostUserUpdateManyWithoutUserNestedInput
    gender?: GenderUpdateOneRequiredWithoutUserNestedInput
    user_address?: UserAddressUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cpf?: StringFieldUpdateOperationsInput | string
    id_gender?: StringFieldUpdateOperationsInput | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    banner_photo?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supported_campaigns?: CampaignParticipantsUncheckedUpdateManyWithoutUserNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowingUncheckedUpdateManyWithoutUserNestedInput
    post_user?: PostUserUncheckedUpdateManyWithoutUserNestedInput
    user_address?: UserAddressUncheckedUpdateOneWithoutUserNestedInput
    user_phone?: UserPhoneUncheckedUpdateOneWithoutUserNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutUserNestedInput
    post_likes?: PostLikesUncheckedUpdateManyWithoutUserNestedInput
    attached_link?: AttachedLinkUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateManyPostInput = {
    id?: string
    content: string
    created_at?: Date | string
  }

  export type PostNgoCreateManyPostInput = {
    id?: string
    id_ngo: string
  }

  export type PostPhotoCreateManyPostInput = {
    id?: string
    photo_url: string
  }

  export type PostUserCreateManyPostInput = {
    id?: string
    id_user: string
  }

  export type PostLikesCreateManyPostInput = {
    id?: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_ngo?: CommentNgoUpdateManyWithoutCommentNestedInput
    comment_user?: CommentUserUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment_ngo?: CommentNgoUncheckedUpdateManyWithoutCommentNestedInput
    comment_user?: CommentUserUncheckedUpdateManyWithoutCommentNestedInput
    comment_likes?: CommentLikesUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostNgoUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutPost_ngoNestedInput
  }

  export type PostNgoUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type PostPhotoUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type PostPhotoUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type PostPhotoUncheckedUpdateManyWithoutPost_photoInput = {
    id?: StringFieldUpdateOperationsInput | string
    photo_url?: StringFieldUpdateOperationsInput | string
  }

  export type PostUserUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPost_userNestedInput
  }

  export type PostUserUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikesUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneWithoutPost_likesNestedInput
    user?: UserUpdateOneWithoutPost_likesNestedInput
  }

  export type PostLikesUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentNgoCreateManyCommentInput = {
    id?: string
    id_ngo: string
  }

  export type CommentUserCreateManyCommentInput = {
    id?: string
    id_user: string
  }

  export type CommentLikesCreateManyCommentInput = {
    id?: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type CommentNgoUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutComment_ngoNestedInput
  }

  export type CommentNgoUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUserUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutComment_userNestedInput
  }

  export type CommentUserUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CommentLikesUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneWithoutComment_likesNestedInput
    user?: UserUpdateOneWithoutComment_likesNestedInput
  }

  export type CommentLikesUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachedLinkCreateManySourceInput = {
    id?: string
    attached_link: string
    id_user?: string | null
    id_ngo?: string | null
  }

  export type AttachedLinkUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneWithoutAttached_linkNestedInput
    ngo?: NGOUpdateOneWithoutAttached_linkNestedInput
  }

  export type AttachedLinkUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    attached_link?: StringFieldUpdateOperationsInput | string
    id_user?: NullableStringFieldUpdateOperationsInput | string | null
    id_ngo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignParticipantsCreateManyStatusInput = {
    id?: string
    id_campaign: string
    id_user: string
  }

  export type FollowingCreateManyStatusInput = {
    id?: string
    id_user: string
    id_ngo: string
  }

  export type CampaignParticipantsUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCampaign_participantsNestedInput
    user?: UserUpdateOneRequiredWithoutSupported_campaignsNestedInput
  }

  export type CampaignParticipantsUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type CampaignParticipantsUncheckedUpdateManyWithoutCampaignParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_campaign?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type FollowingUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    ngo?: NGOUpdateOneRequiredWithoutFollowingNestedInput
    user?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowingUncheckedUpdateWithoutStatusInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_user?: StringFieldUpdateOperationsInput | string
    id_ngo?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}